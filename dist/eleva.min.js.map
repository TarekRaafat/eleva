{"version":3,"file":"eleva.min.js","sources":["../src/modules/TemplateEngine.js","../src/modules/Signal.js","../src/modules/Emitter.js","../src/modules/Renderer.js","../src/core/Eleva.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A secure template engine that handles interpolation and dynamic attribute parsing.\n * Provides a safe way to evaluate expressions in templates while preventing XSS attacks.\n * All methods are static and can be called directly on the class.\n *\n * @example\n * const template = \"Hello, {{name}}!\";\n * const data = { name: \"World\" };\n * const result = TemplateEngine.parse(template, data); // Returns: \"Hello, World!\"\n */\nexport class TemplateEngine {\n  /**\n   * @private {RegExp} Regular expression for matching template expressions in the format {{ expression }}\n   */\n  static expressionPattern = /\\{\\{\\s*(.*?)\\s*\\}\\}/g;\n\n  /**\n   * Parses a template string, replacing expressions with their evaluated values.\n   * Expressions are evaluated in the provided data context.\n   *\n   * @public\n   * @static\n   * @param {string} template - The template string to parse.\n   * @param {Object} data - The data context for evaluating expressions.\n   * @returns {string} The parsed template with expressions replaced by their values.\n   * @example\n   * const result = TemplateEngine.parse(\"{{user.name}} is {{user.age}} years old\", {\n   *   user: { name: \"John\", age: 30 }\n   * }); // Returns: \"John is 30 years old\"\n   */\n  static parse(template, data) {\n    if (typeof template !== \"string\") return template;\n    return template.replace(this.expressionPattern, (_, expression) =>\n      this.evaluate(expression, data)\n    );\n  }\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   *\n   * @public\n   * @static\n   * @param {string} expression - The expression to evaluate.\n   * @param {Object} data - The data context for evaluation.\n   * @returns {*} The result of the evaluation, or an empty string if evaluation fails.\n   * @example\n   * const result = TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } }); // Returns: \"John\"\n   * const age = TemplateEngine.evaluate(\"user.age\", { user: { age: 30 } }); // Returns: 30\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    try {\n      return new Function(\"data\", `with(data) { return ${expression}; }`)(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\n/**\n * @class âš¡ Signal\n * @classdesc A reactive data holder that enables fine-grained reactivity in the Eleva framework.\n * Signals notify registered watchers when their value changes, enabling efficient DOM updates\n * through targeted patching rather than full re-renders.\n *\n * @example\n * const count = new Signal(0);\n * count.watch((value) => console.log(`Count changed to: ${value}`));\n * count.value = 1; // Logs: \"Count changed to: 1\"\n */\nexport class Signal {\n  /**\n   * Creates a new Signal instance with the specified initial value.\n   *\n   * @public\n   * @param {*} value - The initial value of the signal.\n   */\n  constructor(value) {\n    /** @private {T} Internal storage for the signal's current value, where T is the type of the initial value */\n    this._value = value;\n    /** @private {Set<function(T): void>} Collection of callback functions to be notified when value changes, where T is the value type */\n    this._watchers = new Set();\n    /** @private {boolean} Flag to prevent multiple synchronous watcher notifications and batch updates into microtasks */\n    this._pending = false;\n  }\n\n  /**\n   * Gets the current value of the signal.\n   *\n   * @public\n   * @returns {T} The current value, where T is the type of the initial value.\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Sets a new value for the signal and notifies all registered watchers if the value has changed.\n   * The notification is batched using microtasks to prevent multiple synchronous updates.\n   *\n   * @public\n   * @param {T} newVal - The new value to set, where T is the type of the initial value.\n   * @returns {void}\n   */\n  set value(newVal) {\n    if (this._value === newVal) return;\n\n    this._value = newVal;\n    this._notify();\n  }\n\n  /**\n   * Registers a watcher function that will be called whenever the signal's value changes.\n   * The watcher will receive the new value as its argument.\n   *\n   * @public\n   * @param {function(T): void} fn - The callback function to invoke on value change, where T is the value type.\n   * @returns {function(): boolean} A function to unsubscribe the watcher.\n   * @example\n   * const unsubscribe = signal.watch((value) => console.log(value));\n   * // Later...\n   * unsubscribe(); // Stops watching for changes\n   */\n  watch(fn) {\n    this._watchers.add(fn);\n    return () => this._watchers.delete(fn);\n  }\n\n  /**\n   * Notifies all registered watchers of a value change using microtask scheduling.\n   * Uses a pending flag to batch multiple synchronous updates into a single notification.\n   * All watcher callbacks receive the current value when executed.\n   *\n   * @private\n   * @returns {void}\n   */\n  _notify() {\n    if (this._pending) return;\n\n    this._pending = true;\n    queueMicrotask(() => {\n      this._watchers.forEach((fn) => fn(this._value));\n      this._pending = false;\n    });\n  }\n}\n","\"use strict\";\n\n/**\n * @class ðŸ“¡ Emitter\n * @classdesc A robust event emitter that enables inter-component communication through a publish-subscribe pattern.\n * Components can emit events and listen for events from other components, facilitating loose coupling\n * and reactive updates across the application.\n *\n * @example\n * const emitter = new Emitter();\n * emitter.on('user:login', (user) => console.log(`User logged in: ${user.name}`));\n * emitter.emit('user:login', { name: 'John' }); // Logs: \"User logged in: John\"\n */\nexport class Emitter {\n  /**\n   * Creates a new Emitter instance.\n   *\n   * @public\n   */\n  constructor() {\n    /** @private {Map<string, Set<function(any): void>>} Map of event names to their registered handler functions */\n    this._events = new Map();\n  }\n\n  /**\n   * Registers an event handler for the specified event name.\n   * The handler will be called with the event data when the event is emitted.\n   *\n   * @public\n   * @param {string} event - The name of the event to listen for.\n   * @param {function(any): void} handler - The callback function to invoke when the event occurs.\n   * @returns {function(): boolean} A function to unsubscribe the event handler.\n   * @example\n   * const unsubscribe = emitter.on('user:login', (user) => console.log(user));\n   * // Later...\n   * unsubscribe(); // Stops listening for the event\n   */\n  on(event, handler) {\n    if (!this._events.has(event)) this._events.set(event, new Set());\n\n    this._events.get(event).add(handler);\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Removes an event handler for the specified event name.\n   * If no handler is provided, all handlers for the event are removed.\n   *\n   * @public\n   * @param {string} event - The name of the event.\n   * @param {function(any): void} [handler] - The specific handler function to remove.\n   * @returns {void}\n   */\n  off(event, handler) {\n    if (!this._events.has(event)) return;\n    if (handler) {\n      const handlers = this._events.get(event);\n      handlers.delete(handler);\n      // Remove the event if there are no handlers left\n      if (handlers.size === 0) this._events.delete(event);\n    } else {\n      this._events.delete(event);\n    }\n  }\n\n  /**\n   * Emits an event with the specified data to all registered handlers.\n   * Handlers are called synchronously in the order they were registered.\n   *\n   * @public\n   * @param {string} event - The name of the event to emit.\n   * @param {...any} args - Optional arguments to pass to the event handlers.\n   * @returns {void}\n   */\n  emit(event, ...args) {\n    if (!this._events.has(event)) return;\n    this._events.get(event).forEach((handler) => handler(...args));\n  }\n}\n","\"use strict\";\n\n/**\n * @class ðŸŽ¨ Renderer\n * @classdesc A DOM renderer that handles efficient DOM updates through patching and diffing.\n * Provides methods for updating the DOM by comparing new and old structures and applying\n * only the necessary changes, minimizing layout thrashing and improving performance.\n *\n * @example\n * const renderer = new Renderer();\n * const container = document.getElementById(\"app\");\n * const newHtml = \"<div>Updated content</div>\";\n * renderer.patchDOM(container, newHtml);\n */\nexport class Renderer {\n  /**\n   * Patches the DOM of a container element with new HTML content.\n   * This method efficiently updates the DOM by comparing the new content with the existing\n   * content and applying only the necessary changes.\n   *\n   * @public\n   * @param {HTMLElement} container - The container element to patch.\n   * @param {string} newHtml - The new HTML content to apply.\n   * @returns {void}\n   * @throws {Error} If container is not an HTMLElement or newHtml is not a string.\n   */\n  patchDOM(container, newHtml) {\n    if (!(container instanceof HTMLElement)) {\n      throw new Error(\"Container must be an HTMLElement\");\n    }\n    if (typeof newHtml !== \"string\") {\n      throw new Error(\"newHtml must be a string\");\n    }\n\n    const temp = document.createElement(\"div\");\n    temp.innerHTML = newHtml;\n    this._diff(container, temp);\n    temp.innerHTML = \"\";\n  }\n\n  /**\n   * Diffs two DOM trees (old and new) and applies updates to the old DOM.\n   * This method recursively compares nodes and their attributes, applying only\n   * the necessary changes to minimize DOM operations.\n   *\n   * @private\n   * @param {HTMLElement} oldParent - The original DOM element.\n   * @param {HTMLElement} newParent - The new DOM element.\n   * @returns {void}\n   * @throws {Error} If either parent is not an HTMLElement.\n   */\n  _diff(oldParent, newParent) {\n    if (\n      !(oldParent instanceof HTMLElement) ||\n      !(newParent instanceof HTMLElement)\n    ) {\n      throw new Error(\"Both parents must be HTMLElements\");\n    }\n\n    if (oldParent.isEqualNode(newParent)) return;\n\n    const oldChildren = oldParent.childNodes;\n    const newChildren = newParent.childNodes;\n    const maxLength = Math.max(oldChildren.length, newChildren.length);\n\n    for (let i = 0; i < maxLength; i++) {\n      const oldNode = oldChildren[i];\n      const newNode = newChildren[i];\n\n      if (!oldNode && !newNode) continue;\n\n      if (!oldNode && newNode) {\n        oldParent.appendChild(newNode.cloneNode(true));\n        continue;\n      }\n      if (oldNode && !newNode) {\n        oldParent.removeChild(oldNode);\n        continue;\n      }\n\n      const isSameType =\n        oldNode.nodeType === newNode.nodeType &&\n        oldNode.nodeName === newNode.nodeName;\n\n      if (!isSameType) {\n        oldParent.replaceChild(newNode.cloneNode(true), oldNode);\n        continue;\n      }\n\n      if (oldNode.nodeType === Node.ELEMENT_NODE) {\n        const oldKey = oldNode.getAttribute(\"key\");\n        const newKey = newNode.getAttribute(\"key\");\n\n        if (oldKey !== newKey && (oldKey || newKey)) {\n          oldParent.replaceChild(newNode.cloneNode(true), oldNode);\n          continue;\n        }\n\n        this._updateAttributes(oldNode, newNode);\n        this._diff(oldNode, newNode);\n      } else if (\n        oldNode.nodeType === Node.TEXT_NODE &&\n        oldNode.nodeValue !== newNode.nodeValue\n      ) {\n        oldNode.nodeValue = newNode.nodeValue;\n      }\n    }\n  }\n\n  /**\n   * Updates the attributes of an element to match those of a new element.\n   * Handles special cases for ARIA attributes, data attributes, and boolean properties.\n   *\n   * @private\n   * @param {HTMLElement} oldEl - The element to update.\n   * @param {HTMLElement} newEl - The element providing the updated attributes.\n   * @returns {void}\n   * @throws {Error} If either element is not an HTMLElement.\n   */\n  _updateAttributes(oldEl, newEl) {\n    if (!(oldEl instanceof HTMLElement) || !(newEl instanceof HTMLElement)) {\n      throw new Error(\"Both elements must be HTMLElements\");\n    }\n\n    const oldAttrs = oldEl.attributes;\n    const newAttrs = newEl.attributes;\n\n    // Remove old attributes\n    for (const { name } of oldAttrs) {\n      if (!newEl.hasAttribute(name)) {\n        oldEl.removeAttribute(name);\n      }\n    }\n\n    // Update/add new attributes\n    for (const attr of newAttrs) {\n      const { name, value } = attr;\n      if (name.startsWith(\"@\")) continue;\n\n      if (oldEl.getAttribute(name) === value) continue;\n\n      oldEl.setAttribute(name, value);\n\n      if (name.startsWith(\"aria-\")) {\n        const prop =\n          \"aria\" +\n          name.slice(5).replace(/-([a-z])/g, (_, l) => l.toUpperCase());\n        oldEl[prop] = value;\n      } else if (name.startsWith(\"data-\")) {\n        oldEl.dataset[name.slice(5)] = value;\n      } else {\n        const prop = name.replace(/-([a-z])/g, (_, l) => l.toUpperCase());\n        if (prop in oldEl) {\n          const descriptor = Object.getOwnPropertyDescriptor(\n            Object.getPrototypeOf(oldEl),\n            prop\n          );\n          const isBoolean =\n            typeof oldEl[prop] === \"boolean\" ||\n            (descriptor?.get &&\n              typeof descriptor.get.call(oldEl) === \"boolean\");\n\n          if (isBoolean) {\n            oldEl[prop] =\n              value !== \"false\" &&\n              (value === \"\" || value === prop || value === \"true\");\n          } else {\n            oldEl[prop] = value;\n          }\n        }\n      }\n    }\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\nimport { Signal } from \"../modules/Signal.js\";\nimport { Emitter } from \"../modules/Emitter.js\";\nimport { Renderer } from \"../modules/Renderer.js\";\n\n/**\n * @typedef {Object} ComponentDefinition\n * @property {function(Object<string, any>): (Object<string, any>|Promise<Object<string, any>>)} [setup]\n *           Optional setup function that initializes the component's state and returns reactive data\n * @property {function(Object<string, any>): string} template\n *           Required function that defines the component's HTML structure\n * @property {function(Object<string, any>): string} [style]\n *           Optional function that provides component-scoped CSS styles\n * @property {Object<string, ComponentDefinition>} [children]\n *           Optional object defining nested child components\n */\n\n/**\n * @typedef {Object} ElevaPlugin\n * @property {function(Eleva, Object<string, any>): void} install\n *           Function that installs the plugin into the Eleva instance\n * @property {string} name\n *           Unique identifier name for the plugin\n */\n\n/**\n * @typedef {Object} MountResult\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {Object<string, any>} data\n *           The component's reactive state and context data\n * @property {function(): void} unmount\n *           Function to clean up and unmount the component\n */\n\n/**\n * @class ðŸ§© Eleva\n * @classdesc A modern, signal-based component runtime framework that provides lifecycle hooks,\n * scoped styles, and plugin support. Eleva manages component registration, plugin integration,\n * event handling, and DOM rendering with a focus on performance and developer experience.\n *\n * @example\n * const app = new Eleva(\"myApp\");\n * app.component(\"myComponent\", {\n *   template: (ctx) => `<div>Hello ${ctx.props.name}</div>`,\n *   setup: (ctx) => ({ count: new Signal(0) })\n * });\n * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n */\nexport class Eleva {\n  /**\n   * Creates a new Eleva instance with the specified name and configuration.\n   *\n   * @public\n   * @param {string} name - The unique identifier name for this Eleva instance.\n   * @param {Object<string, any>} [config={}] - Optional configuration object for the instance.\n   *        May include framework-wide settings and default behaviors.\n   */\n  constructor(name, config = {}) {\n    /** @public {string} The unique identifier name for this Eleva instance */\n    this.name = name;\n    /** @public {Object<string, any>} Optional configuration object for the Eleva instance */\n    this.config = config;\n    /** @public {Emitter} Instance of the event emitter for handling component events */\n    this.emitter = new Emitter();\n    /** @public {typeof Signal} Static reference to the Signal class for creating reactive state */\n    this.signal = Signal;\n    /** @public {Renderer} Instance of the renderer for handling DOM updates and patching */\n    this.renderer = new Renderer();\n\n    /** @private {Map<string, ComponentDefinition>} Registry of all component definitions by name */\n    this._components = new Map();\n    /** @private {Map<string, ElevaPlugin>} Collection of installed plugin instances by name */\n    this._plugins = new Map();\n    /** @private {string[]} Array of lifecycle hook names supported by components */\n    this._lifecycleHooks = [\n      \"onBeforeMount\",\n      \"onMount\",\n      \"onBeforeUpdate\",\n      \"onUpdate\",\n      \"onUnmount\",\n    ];\n    /** @private {boolean} Flag indicating if the root component is currently mounted */\n    this._isMounted = false;\n  }\n\n  /**\n   * Integrates a plugin with the Eleva framework.\n   * The plugin's install function will be called with the Eleva instance and provided options.\n   * After installation, the plugin will be available for use by components.\n   *\n   * @public\n   * @param {ElevaPlugin} plugin - The plugin object which must have an `install` function.\n   * @param {Object<string, any>} [options={}] - Optional configuration options for the plugin.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @example\n   * app.use(myPlugin, { option1: \"value1\" });\n   */\n  use(plugin, options = {}) {\n    plugin.install(this, options);\n    this._plugins.set(plugin.name, plugin);\n\n    return this;\n  }\n\n  /**\n   * Registers a new component with the Eleva instance.\n   * The component will be available for mounting using its registered name.\n   *\n   * @public\n   * @param {string} name - The unique name of the component to register.\n   * @param {ComponentDefinition} definition - The component definition including setup, template, style, and children.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If the component name is already registered.\n   * @example\n   * app.component(\"myButton\", {\n   *   template: (ctx) => `<button>${ctx.props.text}</button>`,\n   *   style: () => \"button { color: blue; }\"\n   * });\n   */\n  component(name, definition) {\n    /** @type {Map<string, ComponentDefinition>} */\n    this._components.set(name, definition);\n    return this;\n  }\n\n  /**\n   * Mounts a registered component to a DOM element.\n   * This will initialize the component, set up its reactive state, and render it to the DOM.\n   *\n   * @public\n   * @param {HTMLElement} container - The DOM element where the component will be mounted.\n   * @param {string|ComponentDefinition} compName - The name of the registered component or a direct component definition.\n   * @param {Object<string, any>} [props={}] - Optional properties to pass to the component.\n   * @returns {Promise<MountResult>}\n   *          A Promise that resolves to an object containing:\n   *          - container: The mounted component's container element\n   *          - data: The component's reactive state and context\n   *          - unmount: Function to clean up and unmount the component\n   * @throws {Error} If the container is not found, or component is not registered.\n   * @example\n   * const instance = await app.mount(document.getElementById(\"app\"), \"myComponent\", { text: \"Click me\" });\n   * // Later...\n   * instance.unmount();\n   */\n  async mount(container, compName, props = {}) {\n    if (!container) throw new Error(`Container not found: ${container}`);\n\n    /** @type {ComponentDefinition} */\n    const definition =\n      typeof compName === \"string\" ? this._components.get(compName) : compName;\n    if (!definition) throw new Error(`Component \"${compName}\" not registered.`);\n\n    if (typeof definition.template !== \"function\")\n      throw new Error(\"Component template must be a function\");\n\n    /**\n     * Destructure the component definition to access core functionality.\n     * - setup: Optional function for component initialization and state management\n     * - template: Required function that returns the component's HTML structure\n     * - style: Optional function for component-scoped CSS styles\n     * - children: Optional object defining nested child components\n     */\n    const { setup, template, style, children } = definition;\n\n    /**\n     * Creates the initial context object for the component instance.\n     * This context provides core functionality and will be merged with setup data.\n     * @type {Object<string, any>}\n     * @property {Object<string, any>} props - Component properties passed during mounting\n     * @property {Emitter} emitter - Event emitter instance for component event handling\n     * @property {function(any): Signal} signal - Factory function to create reactive Signal instances\n     * @property {Object<string, function(): void>} ...lifecycleHooks - Prepared lifecycle hook functions\n     */\n    const context = {\n      props,\n      emitter: this.emitter,\n      /** @type {(v: any) => Signal} */\n      signal: (v) => new this.signal(v),\n      ...this._prepareLifecycleHooks(),\n    };\n\n    /**\n     * Processes the mounting of the component.\n     * This function handles:\n     * 1. Merging setup data with the component context\n     * 2. Setting up reactive watchers\n     * 3. Rendering the component\n     * 4. Managing component lifecycle\n     *\n     * @param {Object<string, any>} data - Data returned from the component's setup function\n     * @returns {MountResult} An object containing:\n     *   - container: The mounted component's container element\n     *   - data: The component's reactive state and context\n     *   - unmount: Function to clean up and unmount the component\n     */\n    const processMount = async (data) => {\n      const mergedContext = { ...context, ...data };\n      /** @type {Array<() => void>} */\n      const watcherUnsubscribers = [];\n      /** @type {Array<MountResult>} */\n      const childInstances = [];\n      /** @type {Array<() => void>} */\n      const cleanupListeners = [];\n\n      // Execute before hooks\n      if (!this._isMounted) {\n        mergedContext.onBeforeMount && mergedContext.onBeforeMount();\n      } else {\n        mergedContext.onBeforeUpdate && mergedContext.onBeforeUpdate();\n      }\n\n      /**\n       * Renders the component by parsing the template, patching the DOM,\n       * processing events, injecting styles, and mounting child components.\n       */\n      const render = async () => {\n        const newHtml = TemplateEngine.parse(\n          template(mergedContext),\n          mergedContext\n        );\n        this.renderer.patchDOM(container, newHtml);\n        this._processEvents(container, mergedContext, cleanupListeners);\n        this._injectStyles(container, compName, style, mergedContext);\n        await this._mountComponents(container, children, childInstances);\n\n        if (!this._isMounted) {\n          mergedContext.onMount && mergedContext.onMount();\n          this._isMounted = true;\n        } else {\n          mergedContext.onUpdate && mergedContext.onUpdate();\n        }\n      };\n\n      /**\n       * Sets up reactive watchers for all Signal instances in the component's data.\n       * When a Signal's value changes, the component will re-render to reflect the updates.\n       * Stores unsubscribe functions to clean up watchers when component unmounts.\n       */\n      for (const val of Object.values(data)) {\n        if (val instanceof Signal) watcherUnsubscribers.push(val.watch(render));\n      }\n\n      await render();\n\n      return {\n        container,\n        data: mergedContext,\n        /**\n         * Unmounts the component, cleaning up watchers and listeners, child components, and clearing the container.\n         *\n         * @returns {void}\n         */\n        unmount: () => {\n          for (const fn of watcherUnsubscribers) fn();\n          for (const fn of cleanupListeners) fn();\n          for (const child of childInstances) child.unmount();\n          mergedContext.onUnmount && mergedContext.onUnmount();\n          container.innerHTML = \"\";\n        },\n      };\n    };\n\n    // Handle asynchronous setup.\n    const setupResult = typeof setup === \"function\" ? await setup(context) : {};\n    return await processMount(setupResult);\n  }\n\n  /**\n   * Prepares default no-operation lifecycle hook functions for a component.\n   * These hooks will be called at various stages of the component's lifecycle.\n   *\n   * @private\n   * @returns {Object<string, function(): void>} An object mapping lifecycle hook names to empty functions.\n   *         The returned object will be merged with the component's context.\n   */\n  _prepareLifecycleHooks() {\n    /** @type {Object<string, () => void>} */\n    const hooks = {};\n    for (const hook of this._lifecycleHooks) {\n      hooks[hook] = () => {};\n    }\n    return hooks;\n  }\n\n  /**\n   * Processes DOM elements for event binding based on attributes starting with \"@\".\n   * This method handles the event delegation system and ensures proper cleanup of event listeners.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element in which to search for event attributes.\n   * @param {Object<string, any>} context - The current component context containing event handler definitions.\n   * @param {Array<Function>} cleanupListeners - Array to collect cleanup functions for each event listener.\n   * @returns {void}\n   */\n  _processEvents(container, context, cleanupListeners) {\n    const elements = container.querySelectorAll(\"*\");\n    for (const el of elements) {\n      const attrs = el.attributes;\n      for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name.startsWith(\"@\")) {\n          const event = attr.name.slice(1);\n          const handler = TemplateEngine.evaluate(attr.value, context);\n          if (typeof handler === \"function\") {\n            el.addEventListener(event, handler);\n            el.removeAttribute(attr.name);\n            cleanupListeners.push(() => el.removeEventListener(event, handler));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Injects scoped styles into the component's container.\n   * The styles are automatically prefixed to prevent style leakage to other components.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element where styles should be injected.\n   * @param {string} compName - The component name used to identify the style element.\n   * @param {function(Object<string, any>): string} [styleFn] - Optional function that returns CSS styles as a string.\n   * @param {Object<string, any>} context - The current component context for style interpolation.\n   * @returns {void}\n   */\n  _injectStyles(container, compName, styleFn, context) {\n    if (!styleFn) return;\n\n    let styleEl = container.querySelector(\n      `style[data-eleva-style=\"${compName}\"]`\n    );\n    if (!styleEl) {\n      styleEl = document.createElement(\"style\");\n      styleEl.setAttribute(\"data-eleva-style\", compName);\n      container.appendChild(styleEl);\n    }\n    styleEl.textContent = TemplateEngine.parse(styleFn(context), context);\n  }\n\n  /**\n   * Extracts props from an element's attributes that start with 'eleva-prop-'.\n   * This method is used to collect component properties from DOM elements.\n   *\n   * @private\n   * @param {HTMLElement} element - The DOM element to extract props from\n   * @returns {Object<string, any>} An object containing the extracted props\n   * @example\n   * // For an element with attributes:\n   * // <div eleva-prop-name=\"John\" eleva-prop-age=\"25\">\n   * // Returns: { name: \"John\", age: \"25\" }\n   */\n  _extractProps(element) {\n    const props = {};\n    for (const { name, value } of element.attributes) {\n      if (name.startsWith(\"eleva-prop-\")) {\n        props[name.replace(\"eleva-prop-\", \"\")] = value;\n      }\n    }\n    return props;\n  }\n\n  /**\n   * Mounts a single component instance to a container element.\n   * This method handles the actual mounting of a component with its props.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount the component to\n   * @param {string|ComponentDefinition} component - The component to mount, either as a name or definition\n   * @param {Object<string, any>} props - The props to pass to the component\n   * @returns {Promise<MountResult>} A promise that resolves to the mounted component instance\n   * @throws {Error} If the container is not a valid HTMLElement\n   */\n  async _mountComponentInstance(container, component, props) {\n    if (!(container instanceof HTMLElement)) return null;\n    return await this.mount(container, component, props);\n  }\n\n  /**\n   * Mounts components found by a selector in the container.\n   * This method handles mounting multiple instances of the same component type.\n   *\n   * @private\n   * @param {HTMLElement} container - The container to search for components\n   * @param {string} selector - The CSS selector to find components\n   * @param {string|ComponentDefinition} component - The component to mount\n   * @param {Array<MountResult>} instances - Array to store the mounted component instances\n   * @returns {Promise<void>}\n   */\n  async _mountComponentsBySelector(container, selector, component, instances) {\n    for (const el of container.querySelectorAll(selector)) {\n      const props = this._extractProps(el);\n      const instance = await this._mountComponentInstance(el, component, props);\n      if (instance) instances.push(instance);\n    }\n  }\n\n  /**\n   * Mounts all components within the parent component's container.\n   * This method implements a dual mounting system that handles both:\n   * 1. Explicitly defined children components (passed through the children parameter)\n   * 2. Template-referenced components (found in the template using component names)\n   *\n   * The mounting process follows these steps:\n   * 1. Cleans up any existing component instances\n   * 2. Mounts explicitly defined children components\n   * 3. Mounts template-referenced components\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount components in\n   * @param {Object<string, ComponentDefinition>} children - Map of selectors to component definitions for explicit children\n   * @param {Array<MountResult>} childInstances - Array to store all mounted component instances\n   * @returns {Promise<void>}\n   *\n   * @example\n   * // Explicit children mounting:\n   * const children = {\n   *   '.user-profile': UserProfileComponent,\n   *   '.settings-panel': SettingsComponent\n   * };\n   *\n   * // Template-referenced components:\n   * // <div>\n   * //   <user-profile eleva-prop-name=\"John\"></user-profile>\n   * //   <settings-panel eleva-prop-theme=\"dark\"></settings-panel>\n   * // </div>\n   */\n  async _mountComponents(container, children, childInstances) {\n    // Clean up existing instances\n    for (const child of childInstances) child.unmount();\n    childInstances.length = 0;\n\n    // Mount explicitly defined children components\n    if (children) {\n      for (const [selector, component] of Object.entries(children)) {\n        if (!selector) continue;\n        await this._mountComponentsBySelector(\n          container,\n          selector,\n          component,\n          childInstances\n        );\n      }\n    }\n\n    // Mount components referenced in the template\n    for (const [compName] of this._components) {\n      await this._mountComponentsBySelector(\n        container,\n        compName,\n        compName,\n        childInstances\n      );\n    }\n  }\n}\n"],"names":["TemplateEngine","static","parse","template","data","replace","this","expressionPattern","_","expression","evaluate","Function","Signal","constructor","value","_value","_watchers","Set","_pending","newVal","_notify","watch","fn","add","delete","queueMicrotask","forEach","Emitter","_events","Map","on","event","handler","has","set","get","off","handlers","size","emit","args","Renderer","patchDOM","container","newHtml","HTMLElement","Error","temp","document","createElement","innerHTML","_diff","oldParent","newParent","isEqualNode","oldChildren","childNodes","newChildren","maxLength","Math","max","length","i","oldNode","newNode","appendChild","cloneNode","removeChild","nodeType","nodeName","Node","ELEMENT_NODE","oldKey","getAttribute","newKey","replaceChild","_updateAttributes","TEXT_NODE","nodeValue","oldEl","newEl","oldAttrs","attributes","newAttrs","name","hasAttribute","removeAttribute","attr","startsWith","setAttribute","slice","l","toUpperCase","dataset","prop","descriptor","Object","getOwnPropertyDescriptor","getPrototypeOf","isBoolean","call","config","emitter","signal","renderer","_components","_plugins","_lifecycleHooks","_isMounted","use","plugin","options","install","component","definition","mount","compName","props","setup","style","children","context","v","_prepareLifecycleHooks","setupResult","async","mergedContext","watcherUnsubscribers","childInstances","cleanupListeners","onBeforeUpdate","onBeforeMount","render","_processEvents","_injectStyles","_mountComponents","onUpdate","onMount","val","values","push","unmount","child","onUnmount","processMount","hooks","hook","elements","querySelectorAll","el","attrs","addEventListener","removeEventListener","styleFn","styleEl","querySelector","textContent","_extractProps","element","_mountComponentInstance","_mountComponentsBySelector","selector","instances","instance","entries"],"mappings":"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"}
/*! Eleva Router Plugin v1.0.0-rc.10 | MIT License | https://elevajs.com */
var t,e;t=this,e=function(t){"use strict";const e={handle(t,e,r={}){const n=new Error(`[ElevaRouter] ${e}: ${t.message}`);throw n.originalError=t,n.context=e,n.details=r,n},warn(t,e={}){},log(t,e,r={}){}};class r{constructor(t,r={}){this.eleva=t,this.options={mode:"hash",queryParam:"view",viewSelector:"root",...r},this.routes=this._processRoutes(r.routes||[]),this.emitter=this.eleva.emitter,this.isStarted=!1,this._isNavigating=!1,this._navigationId=0,this.eventListeners=[],this.currentRoute=new this.eleva.signal(null),this.previousRoute=new this.eleva.signal(null),this.currentParams=new this.eleva.signal({}),this.currentQuery=new this.eleva.signal({}),this.currentLayout=new this.eleva.signal(null),this.currentView=new this.eleva.signal(null),this.isReady=new this.eleva.signal(!1),this.plugins=new Map,this._beforeEachGuards=[],r.onBeforeEach&&this._beforeEachGuards.push(r.onBeforeEach),this.errorHandler=e,this._scrollPositions=new Map,this._validateOptions()}_validateOptions(){["hash","query","history"].includes(this.options.mode)||this.errorHandler.handle(new Error(`Invalid routing mode: ${this.options.mode}. Must be "hash", "query", or "history".`),"Configuration validation failed")}_processRoutes(t){const e=[];for(const r of t)try{e.push({...r,segments:this._parsePathIntoSegments(r.path)})}catch(t){this.errorHandler.warn(`Invalid path in route definition "${r.path||"undefined"}": ${t.message}`,{route:r,error:t})}return e}_parsePathIntoSegments(t){t&&"string"==typeof t||this.errorHandler.handle(new Error("Route path must be a non-empty string"),"Path parsing failed",{path:t});const e=t.replace(/\/+/g,"/").replace(/\/$/,"")||"/";return"/"===e?[]:e.split("/").filter(Boolean).map(e=>{if(e.startsWith(":")){const r=e.substring(1);return r||this.errorHandler.handle(new Error(`Invalid parameter segment: ${e}`),"Path parsing failed",{segment:e,path:t}),{type:"param",name:r}}return{type:"static",value:e}})}_findViewElement(t){const e=this.options.viewSelector;return t.querySelector(`#${e}`)||t.querySelector(`.${e}`)||t.querySelector(`[data-${e}]`)||t.querySelector(e)||t}async start(){if(this.isStarted)return this.errorHandler.warn("Router is already started"),this;if("undefined"==typeof window)return this.errorHandler.warn("Router start skipped: `window` object not available (SSR environment)"),this;if("undefined"!=typeof document&&!document.querySelector(this.options.mount))return this.errorHandler.warn(`Mount element "${this.options.mount}" was not found in the DOM. The router will not start.`,{mountSelector:this.options.mount}),this;const t=()=>this._handleRouteChange();return"hash"===this.options.mode?(window.addEventListener("hashchange",t),this.eventListeners.push(()=>window.removeEventListener("hashchange",t))):(window.addEventListener("popstate",t),this.eventListeners.push(()=>window.removeEventListener("popstate",t))),this.isStarted=!0,await this._handleRouteChange(!1),this.isReady.value=!0,await this.emitter.emit("router:ready",this),this}async destroy(){if(this.isStarted){for(const t of this.plugins.values())if("function"==typeof t.destroy)try{await t.destroy(this)}catch(e){this.errorHandler.log(`Plugin ${t.name} destroy failed`,e)}this.eventListeners.forEach(t=>t()),this.eventListeners=[],this.currentLayout.value&&await this.currentLayout.value.unmount(),this.isStarted=!1,this.isReady.value=!1}}async stop(){return this.destroy()}async navigate(t,e={}){try{const r="string"==typeof t?{path:t,params:e}:t;let n=this._buildPath(r.path,r.params||{});const o=r.query||{};if(Object.keys(o).length>0){const t=new URLSearchParams(o).toString();t&&(n+=`?${t}`)}if(this._isSameRoute(n,r.params,o))return!0;const i=await this._proceedWithNavigation(n);if(i){const t=++this._navigationId;this._isNavigating=!0;const e=r.state||{},o=r.replace||!1,i=o?"replaceState":"pushState";if("hash"===this.options.mode)if(o){const t=`${window.location.pathname}${window.location.search}#${n}`;window.history.replaceState(e,"",t)}else window.location.hash=n;else{const t="query"===this.options.mode?this._buildQueryUrl(n):n;history[i](e,"",t)}queueMicrotask(()=>{this._navigationId===t&&(this._isNavigating=!1)})}return i}catch(t){return this.errorHandler.log("Navigation failed",t),await this.emitter.emit("router:onError",t),!1}}_buildQueryUrl(t){const e=new URLSearchParams(window.location.search);return e.set(this.options.queryParam,t.split("?")[0]),`${window.location.pathname}?${e.toString()}`}_isSameRoute(t,e,r){const n=this.currentRoute.value;if(!n)return!1;const[o,i]=t.split("?"),a=r||this._parseQuery(i||"");return n.path===o&&JSON.stringify(n.params)===JSON.stringify(e||{})&&JSON.stringify(n.query)===JSON.stringify(a)}_buildPath(t,e){let r=t;for(const[t,n]of Object.entries(e)){const e=encodeURIComponent(String(n));r=r.replace(new RegExp(`:${t}\\b`,"g"),e)}return r}async _handleRouteChange(t=!0){if(!this._isNavigating)try{const e=this.currentRoute.value,r=this._getCurrentLocation();!await this._proceedWithNavigation(r.fullUrl,t)&&e&&this.navigate({path:e.path,query:e.query,replace:!0})}catch(t){this.errorHandler.log("Route change handling failed",t,{currentUrl:"undefined"!=typeof window?window.location.href:""}),await this.emitter.emit("router:onError",t)}}async _proceedWithNavigation(t,e=!1){const r=this.currentRoute.value,[n,o]=(t||"/").split("?"),i={path:n.startsWith("/")?n:`/${n}`,query:this._parseQuery(o),fullUrl:t};let a=this._matchRoute(i.path);if(!a){const t=this.routes.find(t=>"*"===t.path);if(!t)return await this.emitter.emit("router:onError",new Error(`Route not found: ${i.path}`),i,r),!1;a={route:t,params:{pathMatch:decodeURIComponent(i.path.substring(1))}}}const s={...i,params:a.params,meta:a.route.meta||{},name:a.route.name,matched:a.route};try{if(!await this._runGuards(s,r,a.route))return!1;r&&"undefined"!=typeof window&&this._scrollPositions.set(r.path,{x:window.scrollX||window.pageXOffset||0,y:window.scrollY||window.pageYOffset||0});const t={to:s,from:r,route:a.route,layoutComponent:null,pageComponent:null,cancelled:!1,redirectTo:null};if(await this.emitter.emit("router:beforeResolve",t),t.cancelled)return!1;if(t.redirectTo)return this.navigate(t.redirectTo),!1;const{layoutComponent:n,pageComponent:o}=await this._resolveComponents(a.route);if(t.layoutComponent=n,t.pageComponent=o,await this.emitter.emit("router:afterResolve",t),r){const t=async t=>{if(t)try{await t.unmount()}catch(e){this.errorHandler.warn("Error during component unmount",{error:e,instance:t})}};(a.route.layout||this.options.globalLayout)!==(r.matched.layout||this.options.globalLayout)?(await t(this.currentLayout.value),this.currentLayout.value=null):(await t(this.currentView.value),this.currentView.value=null),r.matched.afterLeave&&await r.matched.afterLeave(s,r),await this.emitter.emit("router:afterLeave",s,r)}this.previousRoute.value=r,this.currentRoute.value=s,this.currentParams.value=s.params||{},this.currentQuery.value=s.query||{};const i={to:s,from:r,layoutComponent:n,pageComponent:o};await this.emitter.emit("router:beforeRender",i),await this._render(n,o,s),await this.emitter.emit("router:afterRender",i);const u={to:s,from:r,savedPosition:e&&this._scrollPositions.get(s.path)||null};return await this.emitter.emit("router:scroll",u),a.route.afterEnter&&await a.route.afterEnter(s,r),await this.emitter.emit("router:afterEnter",s,r),await this.emitter.emit("router:afterEach",s,r),!0}catch(t){return this.errorHandler.log("Error during navigation",t,{to:s,from:r}),await this.emitter.emit("router:onError",t,s,r),!1}}async _runGuards(t,e,r){const n={to:t,from:e,cancelled:!1,redirectTo:null};if(await this.emitter.emit("router:beforeEach",n),n.cancelled)return!1;if(n.redirectTo)return this.navigate(n.redirectTo),!1;const o=[...this._beforeEachGuards,...e&&e.matched.beforeLeave?[e.matched.beforeLeave]:[],...r.beforeEnter?[r.beforeEnter]:[]];for(const r of o){const n=await r(t,e);if(!1===n)return!1;if("string"==typeof n||"object"==typeof n)return this.navigate(n),!1}return!0}_resolveStringComponent(t){const e=this.eleva._components.get(t);return e||this.errorHandler.handle(new Error(`Component "${t}" not registered.`),"Component resolution failed",{componentName:t,availableComponents:Array.from(this.eleva._components.keys())}),e}async _resolveFunctionComponent(t){try{const e=t.toString(),r=e.includes("import(")||e.startsWith("() =>"),n=await t();return r&&n.default||n}catch(e){this.errorHandler.handle(new Error(`Failed to load async component: ${e.message}`),"Component resolution failed",{function:t.toString(),error:e})}}_validateComponentDefinition(t){return t&&"object"==typeof t||this.errorHandler.handle(new Error("Invalid component definition: "+typeof t),"Component validation failed",{definition:t}),"function"!=typeof t.template&&"string"!=typeof t.template&&this.errorHandler.handle(new Error("Component missing template property"),"Component validation failed",{definition:t}),t}async _resolveComponent(t){return null==t?null:"string"==typeof t?this._resolveStringComponent(t):"function"==typeof t?await this._resolveFunctionComponent(t):t&&"object"==typeof t?this._validateComponentDefinition(t):void this.errorHandler.handle(new Error("Invalid component definition: "+typeof t),"Component resolution failed",{definition:t})}async _resolveComponents(t){const e=t.layout||this.options.globalLayout;try{const[r,n]=await Promise.all([this._resolveComponent(e),this._resolveComponent(t.component)]);return n||this.errorHandler.handle(new Error(`Page component is null or undefined for route: ${t.path}`),"Component resolution failed",{route:t.path}),{layoutComponent:r,pageComponent:n}}catch(e){throw this.errorHandler.log(`Error resolving components for route ${t.path}`,e,{route:t.path}),e}}async _render(t,e){const r=document.querySelector(this.options.mount);if(r||this.errorHandler.handle(new Error(`Mount element "${this.options.mount}" not found.`),{mountSelector:this.options.mount}),t){const n=await this.eleva.mount(r,this._wrapComponentWithChildren(t));this.currentLayout.value=n;const o=this._findViewElement(n.container),i=await this.eleva.mount(o,this._wrapComponentWithChildren(e));this.currentView.value=i}else{const t=await this.eleva.mount(r,this._wrapComponentWithChildren(e));this.currentView.value=t,this.currentLayout.value=null}}_createRouteGetter(t,e){return()=>this.currentRoute.value?.[t]??e}_wrapComponent(t){const e=t.setup,r=this;return{...t,setup:async t=>(t.router={navigate:r.navigate.bind(r),current:r.currentRoute,previous:r.previousRoute,get params(){return r._createRouteGetter("params",{})()},get query(){return r._createRouteGetter("query",{})()},get path(){return r._createRouteGetter("path","/")()},get fullUrl(){return r._createRouteGetter("fullUrl",window.location.href)()},get meta(){return r._createRouteGetter("meta",{})()}},e?await e(t):{})}}_wrapComponentWithChildren(t){if("string"==typeof t)return t;if(!t||"object"!=typeof t)return t;const e=this._wrapComponent(t);if(e.children&&"object"==typeof e.children){const t={};for(const[r,n]of Object.entries(e.children))t[r]=this._wrapComponentWithChildren(n);e.children=t}return e}_getCurrentLocation(){if("undefined"==typeof window)return{path:"/",query:{},fullUrl:""};let t,e,r;switch(this.options.mode){case"hash":r=window.location.hash.slice(1)||"/",[t,e]=r.split("?");break;case"query":t=new URLSearchParams(window.location.search).get(this.options.queryParam)||"/",e=window.location.search.slice(1),r=t;break;default:t=window.location.pathname||"/",e=window.location.search.slice(1),r=`${t}${e?"?"+e:""}`}return{path:t.startsWith("/")?t:`/${t}`,query:this._parseQuery(e),fullUrl:r}}_parseQuery(t){const e={};return t&&new URLSearchParams(t).forEach((t,r)=>{e[r]=t}),e}_matchRoute(t){const e=t.split("/").filter(Boolean);for(const t of this.routes){if("/"===t.path){if(0===e.length)return{route:t,params:{}};continue}if(t.segments.length!==e.length)continue;const r={};let n=!0;for(let o=0;o<t.segments.length;o++){const i=t.segments[o],a=e[o];if("param"===i.type)r[i.name]=decodeURIComponent(a);else if(i.value!==a){n=!1;break}}if(n)return{route:t,params:r}}return null}addRoute(t,e=null){if(!t||!t.path)return this.errorHandler.warn("Invalid route definition: missing path",{route:t}),()=>{};if(this.hasRoute(t.path))return this.errorHandler.warn(`Route "${t.path}" already exists`,{route:t}),()=>{};const r={...t,segments:this._parsePathIntoSegments(t.path)},n=this.routes.findIndex(t=>"*"===t.path);return-1!==n?this.routes.splice(n,0,r):this.routes.push(r),this.emitter.emit("router:routeAdded",r),()=>this.removeRoute(t.path)}removeRoute(t){const e=this.routes.findIndex(e=>e.path===t);if(-1===e)return!1;const[r]=this.routes.splice(e,1);return this.emitter.emit("router:routeRemoved",r),!0}hasRoute(t){return this.routes.some(e=>e.path===t)}getRoutes(){return[...this.routes]}getRoute(t){return this.routes.find(e=>e.path===t)}onBeforeEach(t){return this._beforeEachGuards.push(t),()=>{const e=this._beforeEachGuards.indexOf(t);e>-1&&this._beforeEachGuards.splice(e,1)}}onAfterEnter(t){return this.emitter.on("router:afterEnter",t)}onAfterLeave(t){return this.emitter.on("router:afterLeave",t)}onAfterEach(t){return this.emitter.on("router:afterEach",t)}onError(t){return this.emitter.on("router:onError",t)}use(t,e={}){"function"!=typeof t.install&&this.errorHandler.handle(new Error("Plugin must have an install method"),"Plugin registration failed",{plugin:t}),this.plugins.has(t.name)?this.errorHandler.warn(`Plugin "${t.name}" is already registered`,{existingPlugin:this.plugins.get(t.name)}):(this.plugins.set(t.name,t),t.install(this,e))}getPlugins(){return Array.from(this.plugins.values())}getPlugin(t){return this.plugins.get(t)}removePlugin(t){const e=this.plugins.get(t);if(!e)return!1;if("function"==typeof e.destroy)try{e.destroy(this)}catch(e){this.errorHandler.log(`Plugin ${t} destroy failed`,e)}return this.plugins.delete(t)}setErrorHandler(t){t&&"function"==typeof t.handle&&"function"==typeof t.warn&&"function"==typeof t.log&&(this.errorHandler=t)}}t.RouterPlugin={name:"router",version:"1.0.0-rc.10",description:"Client-side routing for Eleva applications",install(t,e={}){if(!e.mount)throw new Error("[RouterPlugin] 'mount' option is required");if(!e.routes||!Array.isArray(e.routes))throw new Error("[RouterPlugin] 'routes' option must be an array");const n=(e,r)=>{if(!e)return null;if("object"==typeof e&&null!==e&&!e.name){const n=`Eleva${r}Component_${Math.random().toString(36).slice(2,11)}`;try{return t.component(n,e),n}catch(t){throw new Error(`[RouterPlugin] Failed to register ${r} component: ${t.message}`)}}return e};e.globalLayout&&(e.globalLayout=n(e.globalLayout,"GlobalLayout")),(e.routes||[]).forEach(t=>{t.component=n(t.component,"Route"),t.layout&&(t.layout=n(t.layout,"RouteLayout"))});const o=new r(t,e);return t.router=o,!1!==e.autoStart&&queueMicrotask(()=>o.start()),t.plugins||(t.plugins=new Map),t.plugins.set(this.name,{name:this.name,version:this.version,description:this.description,options:e}),t.navigate=o.navigate.bind(o),t.getCurrentRoute=()=>o.currentRoute.value,t.getRouteParams=()=>o.currentParams.value,t.getRouteQuery=()=>o.currentQuery.value,o},async uninstall(t){t.router&&(await t.router.destroy(),delete t.router),t.plugins&&t.plugins.delete(this.name),delete t.navigate,delete t.getCurrentRoute,delete t.getRouteParams,delete t.getRouteQuery}}},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).ElevaRouterPlugin={});
//# sourceMappingURL=router.umd.min.js.map

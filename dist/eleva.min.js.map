{"version":3,"file":"eleva.min.js","sources":["../src/modules/TemplateEngine.js","../src/modules/Signal.js","../src/modules/Emitter.js","../src/modules/Renderer.js","../src/core/Eleva.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A secure template engine that handles interpolation and dynamic attribute parsing.\n * Provides a safe way to evaluate expressions in templates while preventing XSS attacks.\n * All methods are static and can be called directly on the class.\n *\n * @example\n * const template = \"Hello, {{name}}!\";\n * const data = { name: \"World\" };\n * const result = TemplateEngine.parse(template, data); // Returns: \"Hello, World!\"\n */\nexport class TemplateEngine {\n  /**\n   * @private {RegExp} Regular expression for matching template expressions in the format {{ expression }}\n   */\n  static expressionPattern = /\\{\\{\\s*(.*?)\\s*\\}\\}/g;\n\n  /**\n   * Parses a template string, replacing expressions with their evaluated values.\n   * Expressions are evaluated in the provided data context.\n   *\n   * @public\n   * @static\n   * @param {string} template - The template string to parse.\n   * @param {Object} data - The data context for evaluating expressions.\n   * @returns {string} The parsed template with expressions replaced by their values.\n   * @example\n   * const result = TemplateEngine.parse(\"{{user.name}} is {{user.age}} years old\", {\n   *   user: { name: \"John\", age: 30 }\n   * }); // Returns: \"John is 30 years old\"\n   */\n  static parse(template, data) {\n    if (typeof template !== \"string\") return template;\n    return template.replace(this.expressionPattern, (_, expression) =>\n      this.evaluate(expression, data)\n    );\n  }\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   *\n   * @public\n   * @static\n   * @param {string} expression - The expression to evaluate.\n   * @param {Object} data - The data context for evaluation.\n   * @returns {*} The result of the evaluation, or an empty string if evaluation fails.\n   * @example\n   * const result = TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } }); // Returns: \"John\"\n   * const age = TemplateEngine.evaluate(\"user.age\", { user: { age: 30 } }); // Returns: 30\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    try {\n      return new Function(\"data\", `with(data) { return ${expression}; }`)(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\n/**\n * @class âš¡ Signal\n * @classdesc A reactive data holder that enables fine-grained reactivity in the Eleva framework.\n * Signals notify registered watchers when their value changes, enabling efficient DOM updates\n * through targeted patching rather than full re-renders.\n *\n * @example\n * const count = new Signal(0);\n * count.watch((value) => console.log(`Count changed to: ${value}`));\n * count.value = 1; // Logs: \"Count changed to: 1\"\n */\nexport class Signal {\n  /**\n   * Creates a new Signal instance with the specified initial value.\n   *\n   * @public\n   * @param {*} value - The initial value of the signal.\n   */\n  constructor(value) {\n    /** @private {T} Internal storage for the signal's current value, where T is the type of the initial value */\n    this._value = value;\n    /** @private {Set<function(T): void>} Collection of callback functions to be notified when value changes, where T is the value type */\n    this._watchers = new Set();\n    /** @private {boolean} Flag to prevent multiple synchronous watcher notifications and batch updates into microtasks */\n    this._pending = false;\n  }\n\n  /**\n   * Gets the current value of the signal.\n   *\n   * @public\n   * @returns {T} The current value, where T is the type of the initial value.\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Sets a new value for the signal and notifies all registered watchers if the value has changed.\n   * The notification is batched using microtasks to prevent multiple synchronous updates.\n   *\n   * @public\n   * @param {T} newVal - The new value to set, where T is the type of the initial value.\n   * @returns {void}\n   */\n  set value(newVal) {\n    if (this._value === newVal) return;\n\n    this._value = newVal;\n    this._notify();\n  }\n\n  /**\n   * Registers a watcher function that will be called whenever the signal's value changes.\n   * The watcher will receive the new value as its argument.\n   *\n   * @public\n   * @param {function(T): void} fn - The callback function to invoke on value change, where T is the value type.\n   * @returns {function(): boolean} A function to unsubscribe the watcher.\n   * @example\n   * const unsubscribe = signal.watch((value) => console.log(value));\n   * // Later...\n   * unsubscribe(); // Stops watching for changes\n   */\n  watch(fn) {\n    this._watchers.add(fn);\n    return () => this._watchers.delete(fn);\n  }\n\n  /**\n   * Notifies all registered watchers of a value change using microtask scheduling.\n   * Uses a pending flag to batch multiple synchronous updates into a single notification.\n   * All watcher callbacks receive the current value when executed.\n   *\n   * @private\n   * @returns {void}\n   */\n  _notify() {\n    if (this._pending) return;\n\n    this._pending = true;\n    queueMicrotask(() => {\n      this._watchers.forEach((fn) => fn(this._value));\n      this._pending = false;\n    });\n  }\n}\n","\"use strict\";\n\n/**\n * @class ðŸ“¡ Emitter\n * @classdesc A robust event emitter that enables inter-component communication through a publish-subscribe pattern.\n * Components can emit events and listen for events from other components, facilitating loose coupling\n * and reactive updates across the application.\n *\n * @example\n * const emitter = new Emitter();\n * emitter.on('user:login', (user) => console.log(`User logged in: ${user.name}`));\n * emitter.emit('user:login', { name: 'John' }); // Logs: \"User logged in: John\"\n */\nexport class Emitter {\n  /**\n   * Creates a new Emitter instance.\n   *\n   * @public\n   */\n  constructor() {\n    /** @private {Map<string, Set<function(any): void>>} Map of event names to their registered handler functions */\n    this._events = new Map();\n  }\n\n  /**\n   * Registers an event handler for the specified event name.\n   * The handler will be called with the event data when the event is emitted.\n   *\n   * @public\n   * @param {string} event - The name of the event to listen for.\n   * @param {function(any): void} handler - The callback function to invoke when the event occurs.\n   * @returns {function(): boolean} A function to unsubscribe the event handler.\n   * @example\n   * const unsubscribe = emitter.on('user:login', (user) => console.log(user));\n   * // Later...\n   * unsubscribe(); // Stops listening for the event\n   */\n  on(event, handler) {\n    if (!this._events.has(event)) this._events.set(event, new Set());\n\n    this._events.get(event).add(handler);\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Removes an event handler for the specified event name.\n   * If no handler is provided, all handlers for the event are removed.\n   *\n   * @public\n   * @param {string} event - The name of the event.\n   * @param {function(any): void} [handler] - The specific handler function to remove.\n   * @returns {void}\n   */\n  off(event, handler) {\n    if (!this._events.has(event)) return;\n    if (handler) {\n      const handlers = this._events.get(event);\n      handlers.delete(handler);\n      // Remove the event if there are no handlers left\n      if (handlers.size === 0) this._events.delete(event);\n    } else {\n      this._events.delete(event);\n    }\n  }\n\n  /**\n   * Emits an event with the specified data to all registered handlers.\n   * Handlers are called synchronously in the order they were registered.\n   *\n   * @public\n   * @param {string} event - The name of the event to emit.\n   * @param {...any} args - Optional arguments to pass to the event handlers.\n   * @returns {void}\n   */\n  emit(event, ...args) {\n    if (!this._events.has(event)) return;\n    this._events.get(event).forEach((handler) => handler(...args));\n  }\n}\n","\"use strict\";\n\n/**\n * @class ðŸŽ¨ Renderer\n * @classdesc A DOM renderer that handles efficient DOM updates through patching and diffing.\n * Provides methods for updating the DOM by comparing new and old structures and applying\n * only the necessary changes, minimizing layout thrashing and improving performance.\n *\n * @example\n * const renderer = new Renderer();\n * const container = document.getElementById(\"app\");\n * const newHtml = \"<div>Updated content</div>\";\n * renderer.patchDOM(container, newHtml);\n */\nexport class Renderer {\n  /**\n   * Patches the DOM of a container element with new HTML content.\n   * This method efficiently updates the DOM by comparing the new content with the existing\n   * content and applying only the necessary changes.\n   *\n   * @public\n   * @param {HTMLElement} container - The container element to patch.\n   * @param {string} newHtml - The new HTML content to apply.\n   * @returns {void}\n   * @throws {Error} If container is not an HTMLElement or newHtml is not a string.\n   */\n  patchDOM(container, newHtml) {\n    if (!(container instanceof HTMLElement)) {\n      throw new Error(\"Container must be an HTMLElement\");\n    }\n    if (typeof newHtml !== \"string\") {\n      throw new Error(\"newHtml must be a string\");\n    }\n\n    const temp = document.createElement(\"div\");\n    temp.innerHTML = newHtml;\n    this.diff(container, temp);\n    temp.innerHTML = \"\";\n  }\n\n  /**\n   * Diffs two DOM trees (old and new) and applies updates to the old DOM.\n   * This method recursively compares nodes and their attributes, applying only\n   * the necessary changes to minimize DOM operations.\n   *\n   * @private\n   * @param {HTMLElement} oldParent - The original DOM element.\n   * @param {HTMLElement} newParent - The new DOM element.\n   * @returns {void}\n   * @throws {Error} If either parent is not an HTMLElement.\n   */\n  diff(oldParent, newParent) {\n    if (\n      !(oldParent instanceof HTMLElement) ||\n      !(newParent instanceof HTMLElement)\n    ) {\n      throw new Error(\"Both parents must be HTMLElements\");\n    }\n\n    if (oldParent.isEqualNode(newParent)) return;\n\n    const oldC = oldParent.childNodes;\n    const newC = newParent.childNodes;\n    const len = Math.max(oldC.length, newC.length);\n    const operations = [];\n\n    for (let i = 0; i < len; i++) {\n      const oldNode = oldC[i];\n      const newNode = newC[i];\n\n      if (!oldNode && newNode) {\n        operations.push(() => oldParent.appendChild(newNode.cloneNode(true)));\n        continue;\n      }\n      if (oldNode && !newNode) {\n        operations.push(() => oldParent.removeChild(oldNode));\n        continue;\n      }\n\n      const isSameType =\n        oldNode.nodeType === newNode.nodeType &&\n        oldNode.nodeName === newNode.nodeName;\n\n      if (!isSameType) {\n        operations.push(() =>\n          oldParent.replaceChild(newNode.cloneNode(true), oldNode)\n        );\n        continue;\n      }\n\n      if (oldNode.nodeType === Node.ELEMENT_NODE) {\n        const oldKey = oldNode.getAttribute(\"key\");\n        const newKey = newNode.getAttribute(\"key\");\n\n        if (oldKey !== newKey && (oldKey || newKey)) {\n          operations.push(() =>\n            oldParent.replaceChild(newNode.cloneNode(true), oldNode)\n          );\n          continue;\n        }\n\n        this.updateAttributes(oldNode, newNode);\n        this.diff(oldNode, newNode);\n      } else if (\n        oldNode.nodeType === Node.TEXT_NODE &&\n        oldNode.nodeValue !== newNode.nodeValue\n      ) {\n        oldNode.nodeValue = newNode.nodeValue;\n      }\n    }\n\n    if (operations.length) {\n      operations.forEach((op) => op());\n    }\n  }\n\n  /**\n   * Updates the attributes of an element to match those of a new element.\n   * Handles special cases for ARIA attributes, data attributes, and boolean properties.\n   *\n   * @private\n   * @param {HTMLElement} oldEl - The element to update.\n   * @param {HTMLElement} newEl - The element providing the updated attributes.\n   * @returns {void}\n   * @throws {Error} If either element is not an HTMLElement.\n   */\n  updateAttributes(oldEl, newEl) {\n    if (!(oldEl instanceof HTMLElement) || !(newEl instanceof HTMLElement)) {\n      throw new Error(\"Both elements must be HTMLElements\");\n    }\n\n    const oldAttrs = oldEl.attributes;\n    const newAttrs = newEl.attributes;\n    const operations = [];\n\n    // Remove old attributes\n    for (const { name } of oldAttrs) {\n      if (!name.startsWith(\"@\") && !newEl.hasAttribute(name)) {\n        operations.push(() => oldEl.removeAttribute(name));\n      }\n    }\n\n    // Update/add new attributes\n    for (const attr of newAttrs) {\n      const { name, value } = attr;\n      if (name.startsWith(\"@\")) continue;\n\n      if (oldEl.getAttribute(name) === value) continue;\n\n      operations.push(() => {\n        oldEl.setAttribute(name, value);\n\n        if (name.startsWith(\"aria-\")) {\n          const prop =\n            \"aria\" +\n            name.slice(5).replace(/-([a-z])/g, (_, l) => l.toUpperCase());\n          oldEl[prop] = value;\n        } else if (name.startsWith(\"data-\")) {\n          oldEl.dataset[name.slice(5)] = value;\n        } else {\n          const prop = name.replace(/-([a-z])/g, (_, l) => l.toUpperCase());\n          if (prop in oldEl) {\n            const descriptor = Object.getOwnPropertyDescriptor(\n              Object.getPrototypeOf(oldEl),\n              prop\n            );\n            const isBoolean =\n              typeof oldEl[prop] === \"boolean\" ||\n              (descriptor?.get &&\n                typeof descriptor.get.call(oldEl) === \"boolean\");\n\n            if (isBoolean) {\n              oldEl[prop] =\n                value !== \"false\" &&\n                (value === \"\" || value === prop || value === \"true\");\n            } else {\n              oldEl[prop] = value;\n            }\n          }\n        }\n      });\n    }\n\n    if (operations.length) {\n      operations.forEach((op) => op());\n    }\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\nimport { Signal } from \"../modules/Signal.js\";\nimport { Emitter } from \"../modules/Emitter.js\";\nimport { Renderer } from \"../modules/Renderer.js\";\n\n/**\n * @typedef {Object} ComponentDefinition\n * @property {function(Object<string, any>): (Object<string, any>|Promise<Object<string, any>>)} [setup]\n *           Optional setup function that initializes the component's state and returns reactive data\n * @property {function(Object<string, any>): string} template\n *           Required function that defines the component's HTML structure\n * @property {function(Object<string, any>): string} [style]\n *           Optional function that provides component-scoped CSS styles\n * @property {Object<string, ComponentDefinition>} [children]\n *           Optional object defining nested child components\n */\n\n/**\n * @typedef {Object} ElevaPlugin\n * @property {function(Eleva, Object<string, any>): void} install\n *           Function that installs the plugin into the Eleva instance\n * @property {string} name\n *           Unique identifier name for the plugin\n */\n\n/**\n * @typedef {Object} MountResult\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {Object<string, any>} data\n *           The component's reactive state and context data\n * @property {function(): void} unmount\n *           Function to clean up and unmount the component\n */\n\n/**\n * @class ðŸ§© Eleva\n * @classdesc A modern, signal-based component runtime framework that provides lifecycle hooks,\n * scoped styles, and plugin support. Eleva manages component registration, plugin integration,\n * event handling, and DOM rendering with a focus on performance and developer experience.\n *\n * @example\n * const app = new Eleva(\"myApp\");\n * app.component(\"myComponent\", {\n *   template: (ctx) => `<div>Hello ${ctx.props.name}</div>`,\n *   setup: (ctx) => ({ count: new Signal(0) })\n * });\n * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n */\nexport class Eleva {\n  /**\n   * Creates a new Eleva instance with the specified name and configuration.\n   *\n   * @public\n   * @param {string} name - The unique identifier name for this Eleva instance.\n   * @param {Object<string, any>} [config={}] - Optional configuration object for the instance.\n   *        May include framework-wide settings and default behaviors.\n   */\n  constructor(name, config = {}) {\n    /** @public {string} The unique identifier name for this Eleva instance */\n    this.name = name;\n    /** @public {Object<string, any>} Optional configuration object for the Eleva instance */\n    this.config = config;\n    /** @public {Emitter} Instance of the event emitter for handling component events */\n    this.emitter = new Emitter();\n    /** @public {typeof Signal} Static reference to the Signal class for creating reactive state */\n    this.signal = Signal;\n    /** @public {Renderer} Instance of the renderer for handling DOM updates and patching */\n    this.renderer = new Renderer();\n\n    /** @private {Map<string, ComponentDefinition>} Registry of all component definitions by name */\n    this._components = new Map();\n    /** @private {Map<string, ElevaPlugin>} Collection of installed plugin instances by name */\n    this._plugins = new Map();\n    /** @private {string[]} Array of lifecycle hook names supported by components */\n    this._lifecycleHooks = [\n      \"onBeforeMount\",\n      \"onMount\",\n      \"onBeforeUpdate\",\n      \"onUpdate\",\n      \"onUnmount\",\n    ];\n    /** @private {boolean} Flag indicating if the root component is currently mounted */\n    this._isMounted = false;\n  }\n\n  /**\n   * Integrates a plugin with the Eleva framework.\n   * The plugin's install function will be called with the Eleva instance and provided options.\n   * After installation, the plugin will be available for use by components.\n   *\n   * @public\n   * @param {ElevaPlugin} plugin - The plugin object which must have an `install` function.\n   * @param {Object<string, any>} [options={}] - Optional configuration options for the plugin.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @example\n   * app.use(myPlugin, { option1: \"value1\" });\n   */\n  use(plugin, options = {}) {\n    plugin.install(this, options);\n    this._plugins.set(plugin.name, plugin);\n\n    return this;\n  }\n\n  /**\n   * Registers a new component with the Eleva instance.\n   * The component will be available for mounting using its registered name.\n   *\n   * @public\n   * @param {string} name - The unique name of the component to register.\n   * @param {ComponentDefinition} definition - The component definition including setup, template, style, and children.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If the component name is already registered.\n   * @example\n   * app.component(\"myButton\", {\n   *   template: (ctx) => `<button>${ctx.props.text}</button>`,\n   *   style: () => \"button { color: blue; }\"\n   * });\n   */\n  component(name, definition) {\n    /** @type {Map<string, ComponentDefinition>} */\n    this._components.set(name, definition);\n    return this;\n  }\n\n  /**\n   * Mounts a registered component to a DOM element.\n   * This will initialize the component, set up its reactive state, and render it to the DOM.\n   *\n   * @public\n   * @param {HTMLElement} container - The DOM element where the component will be mounted.\n   * @param {string|ComponentDefinition} compName - The name of the registered component or a direct component definition.\n   * @param {Object<string, any>} [props={}] - Optional properties to pass to the component.\n   * @returns {Promise<MountResult>}\n   *          A Promise that resolves to an object containing:\n   *          - container: The mounted component's container element\n   *          - data: The component's reactive state and context\n   *          - unmount: Function to clean up and unmount the component\n   * @throws {Error} If the container is not found, or component is not registered.\n   * @example\n   * const instance = await app.mount(document.getElementById(\"app\"), \"myComponent\", { text: \"Click me\" });\n   * // Later...\n   * instance.unmount();\n   */\n  async mount(container, compName, props = {}) {\n    if (!container) throw new Error(`Container not found: ${container}`);\n\n    /** @type {ComponentDefinition} */\n    const definition =\n      typeof compName === \"string\" ? this._components.get(compName) : compName;\n    if (!definition) throw new Error(`Component \"${compName}\" not registered.`);\n\n    if (typeof definition.template !== \"function\")\n      throw new Error(\"Component template must be a function\");\n\n    /**\n     * Destructure the component definition to access core functionality.\n     * - setup: Optional function for component initialization and state management\n     * - template: Required function that returns the component's HTML structure\n     * - style: Optional function for component-scoped CSS styles\n     * - children: Optional object defining nested child components\n     */\n    const { setup, template, style, children } = definition;\n\n    /**\n     * Creates the initial context object for the component instance.\n     * This context provides core functionality and will be merged with setup data.\n     * @type {Object<string, any>}\n     * @property {Object<string, any>} props - Component properties passed during mounting\n     * @property {Emitter} emitter - Event emitter instance for component event handling\n     * @property {function(any): Signal} signal - Factory function to create reactive Signal instances\n     * @property {Object<string, function(): void>} ...lifecycleHooks - Prepared lifecycle hook functions\n     */\n    const context = {\n      props,\n      emitter: this.emitter,\n      /** @type {(v: any) => Signal} */\n      signal: (v) => new this.signal(v),\n      ...this._prepareLifecycleHooks(),\n    };\n\n    /**\n     * Processes the mounting of the component.\n     * This function handles:\n     * 1. Merging setup data with the component context\n     * 2. Setting up reactive watchers\n     * 3. Rendering the component\n     * 4. Managing component lifecycle\n     *\n     * @param {Object<string, any>} data - Data returned from the component's setup function\n     * @returns {MountResult} An object containing:\n     *   - container: The mounted component's container element\n     *   - data: The component's reactive state and context\n     *   - unmount: Function to clean up and unmount the component\n     */\n    const processMount = async (data) => {\n      const mergedContext = { ...context, ...data };\n      /** @type {Array<() => void>} */\n      const watcherUnsubscribers = [];\n      /** @type {Array<MountResult>} */\n      const childInstances = [];\n      /** @type {Array<() => void>} */\n      const cleanupListeners = [];\n\n      // Execute before hooks\n      if (!this._isMounted) {\n        mergedContext.onBeforeMount && mergedContext.onBeforeMount();\n      } else {\n        mergedContext.onBeforeUpdate && mergedContext.onBeforeUpdate();\n      }\n\n      /**\n       * Renders the component by parsing the template, patching the DOM,\n       * processing events, injecting styles, and mounting child components.\n       */\n      const render = async () => {\n        const newHtml = TemplateEngine.parse(\n          template(mergedContext),\n          mergedContext\n        );\n        this.renderer.patchDOM(container, newHtml);\n        this._processEvents(container, mergedContext, cleanupListeners);\n        this._injectStyles(container, compName, style, mergedContext);\n        await this._mountComponents(container, children, childInstances);\n\n        if (!this._isMounted) {\n          mergedContext.onMount && mergedContext.onMount();\n          this._isMounted = true;\n        } else {\n          mergedContext.onUpdate && mergedContext.onUpdate();\n        }\n      };\n\n      /**\n       * Sets up reactive watchers for all Signal instances in the component's data.\n       * When a Signal's value changes, the component will re-render to reflect the updates.\n       * Stores unsubscribe functions to clean up watchers when component unmounts.\n       */\n      for (const val of Object.values(data)) {\n        if (val instanceof Signal) watcherUnsubscribers.push(val.watch(render));\n      }\n\n      await render();\n\n      return {\n        container,\n        data: mergedContext,\n        /**\n         * Unmounts the component, cleaning up watchers and listeners, child components, and clearing the container.\n         *\n         * @returns {void}\n         */\n        unmount: () => {\n          for (const fn of watcherUnsubscribers) fn();\n          for (const fn of cleanupListeners) fn();\n          for (const child of childInstances) child.unmount();\n          mergedContext.onUnmount && mergedContext.onUnmount();\n          container.innerHTML = \"\";\n        },\n      };\n    };\n\n    // Handle asynchronous setup.\n    const setupResult = typeof setup === \"function\" ? await setup(context) : {};\n    return await processMount(setupResult);\n  }\n\n  /**\n   * Prepares default no-operation lifecycle hook functions for a component.\n   * These hooks will be called at various stages of the component's lifecycle.\n   *\n   * @private\n   * @returns {Object<string, function(): void>} An object mapping lifecycle hook names to empty functions.\n   *         The returned object will be merged with the component's context.\n   */\n  _prepareLifecycleHooks() {\n    /** @type {Object<string, () => void>} */\n    const hooks = {};\n    for (const hook of this._lifecycleHooks) {\n      hooks[hook] = () => {};\n    }\n    return hooks;\n  }\n\n  /**\n   * Processes DOM elements for event binding based on attributes starting with \"@\".\n   * This method handles the event delegation system and ensures proper cleanup of event listeners.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element in which to search for event attributes.\n   * @param {Object<string, any>} context - The current component context containing event handler definitions.\n   * @param {Array<Function>} cleanupListeners - Array to collect cleanup functions for each event listener.\n   * @returns {void}\n   */\n  _processEvents(container, context, cleanupListeners) {\n    const elements = container.querySelectorAll(\"*\");\n    for (const el of elements) {\n      const attrs = el.attributes;\n      for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (attr.name.startsWith(\"@\")) {\n          const event = attr.name.slice(1);\n          const handler = TemplateEngine.evaluate(attr.value, context);\n          if (typeof handler === \"function\") {\n            el.addEventListener(event, handler);\n            el.removeAttribute(attr.name);\n            cleanupListeners.push(() => el.removeEventListener(event, handler));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Injects scoped styles into the component's container.\n   * The styles are automatically prefixed to prevent style leakage to other components.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element where styles should be injected.\n   * @param {string} compName - The component name used to identify the style element.\n   * @param {function(Object<string, any>): string} [styleFn] - Optional function that returns CSS styles as a string.\n   * @param {Object<string, any>} context - The current component context for style interpolation.\n   * @returns {void}\n   */\n  _injectStyles(container, compName, styleFn, context) {\n    if (!styleFn) return;\n\n    let styleEl = container.querySelector(\n      `style[data-eleva-style=\"${compName}\"]`\n    );\n    if (!styleEl) {\n      styleEl = document.createElement(\"style\");\n      styleEl.setAttribute(\"data-eleva-style\", compName);\n      container.appendChild(styleEl);\n    }\n    styleEl.textContent = TemplateEngine.parse(styleFn(context), context);\n  }\n\n  /**\n   * Extracts props from an element's attributes that start with 'eleva-prop-'.\n   * This method is used to collect component properties from DOM elements.\n   *\n   * @private\n   * @param {HTMLElement} element - The DOM element to extract props from\n   * @returns {Object<string, any>} An object containing the extracted props\n   * @example\n   * // For an element with attributes:\n   * // <div eleva-prop-name=\"John\" eleva-prop-age=\"25\">\n   * // Returns: { name: \"John\", age: \"25\" }\n   */\n  _extractProps(element) {\n    const props = {};\n    for (const { name, value } of [...element.attributes]) {\n      if (name.startsWith(\"eleva-prop-\")) {\n        props[name.replace(\"eleva-prop-\", \"\")] = value;\n      }\n    }\n    return props;\n  }\n\n  /**\n   * Mounts a single component instance to a container element.\n   * This method handles the actual mounting of a component with its props.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount the component to\n   * @param {string|ComponentDefinition} component - The component to mount, either as a name or definition\n   * @param {Object<string, any>} props - The props to pass to the component\n   * @returns {Promise<MountResult>} A promise that resolves to the mounted component instance\n   * @throws {Error} If the container is not a valid HTMLElement\n   */\n  async _mountComponentInstance(container, component, props) {\n    if (!(container instanceof HTMLElement)) return null;\n    return await this.mount(container, component, props);\n  }\n\n  /**\n   * Mounts components found by a selector in the container.\n   * This method handles mounting multiple instances of the same component type.\n   *\n   * @private\n   * @param {HTMLElement} container - The container to search for components\n   * @param {string} selector - The CSS selector to find components\n   * @param {string|ComponentDefinition} component - The component to mount\n   * @param {Array<MountResult>} instances - Array to store the mounted component instances\n   * @returns {Promise<void>}\n   */\n  async _mountComponentsBySelector(container, selector, component, instances) {\n    for (const el of container.querySelectorAll(selector)) {\n      const props = this._extractProps(el);\n      const instance = await this._mountComponentInstance(el, component, props);\n      if (instance) instances.push(instance);\n    }\n  }\n\n  /**\n   * Mounts all components within the parent component's container.\n   * This method implements a dual mounting system that handles both:\n   * 1. Explicitly defined children components (passed through the children parameter)\n   * 2. Template-referenced components (found in the template using component names)\n   *\n   * The mounting process follows these steps:\n   * 1. Cleans up any existing component instances\n   * 2. Mounts explicitly defined children components\n   * 3. Mounts template-referenced components\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount components in\n   * @param {Object<string, ComponentDefinition>} children - Map of selectors to component definitions for explicit children\n   * @param {Array<MountResult>} childInstances - Array to store all mounted component instances\n   * @returns {Promise<void>}\n   *\n   * @example\n   * // Explicit children mounting:\n   * const children = {\n   *   '.user-profile': UserProfileComponent,\n   *   '.settings-panel': SettingsComponent\n   * };\n   *\n   * // Template-referenced components:\n   * // <div>\n   * //   <user-profile eleva-prop-name=\"John\"></user-profile>\n   * //   <settings-panel eleva-prop-theme=\"dark\"></settings-panel>\n   * // </div>\n   */\n  async _mountComponents(container, children, childInstances) {\n    // Clean up existing instances\n    for (const child of childInstances) child.unmount();\n    childInstances.length = 0;\n\n    // Mount explicitly defined children components\n    if (children) {\n      for (const [selector, component] of Object.entries(children)) {\n        if (!selector) continue;\n        await this._mountComponentsBySelector(\n          container,\n          selector,\n          component,\n          childInstances\n        );\n      }\n    }\n\n    // Mount components referenced in the template\n    for (const [compName] of this._components) {\n      await this._mountComponentsBySelector(\n        container,\n        compName,\n        compName,\n        childInstances\n      );\n    }\n  }\n}\n"],"names":["TemplateEngine","static","parse","template","data","replace","this","expressionPattern","_","expression","evaluate","Function","Signal","constructor","value","_value","_watchers","Set","_pending","newVal","_notify","watch","fn","add","delete","queueMicrotask","forEach","Emitter","_events","Map","on","event","handler","has","set","get","off","handlers","size","emit","args","Renderer","patchDOM","container","newHtml","HTMLElement","Error","temp","document","createElement","innerHTML","diff","oldParent","newParent","isEqualNode","oldC","childNodes","newC","len","Math","max","length","operations","i","oldNode","newNode","push","appendChild","cloneNode","removeChild","nodeType","nodeName","Node","ELEMENT_NODE","oldKey","getAttribute","newKey","replaceChild","updateAttributes","TEXT_NODE","nodeValue","op","oldEl","newEl","oldAttrs","attributes","newAttrs","name","startsWith","hasAttribute","removeAttribute","attr","setAttribute","prop","slice","l","toUpperCase","dataset","descriptor","Object","getOwnPropertyDescriptor","getPrototypeOf","isBoolean","call","config","emitter","signal","renderer","_components","_plugins","_lifecycleHooks","_isMounted","use","plugin","options","install","component","definition","mount","compName","props","setup","style","children","context","v","_prepareLifecycleHooks","setupResult","async","mergedContext","watcherUnsubscribers","childInstances","cleanupListeners","onBeforeUpdate","onBeforeMount","render","_processEvents","_injectStyles","_mountComponents","onUpdate","onMount","val","values","unmount","child","onUnmount","processMount","hooks","hook","elements","querySelectorAll","el","attrs","addEventListener","removeEventListener","styleFn","styleEl","querySelector","textContent","_extractProps","element","_mountComponentInstance","_mountComponentsBySelector","selector","instances","instance","entries"],"mappings":"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"}
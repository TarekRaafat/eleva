{"version":3,"file":"router.umd.min.js","sources":["../../src/plugins/Router.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {import('eleva').Eleva} Eleva\n * @typedef {import('eleva').Signal} Signal\n * @typedef {import('eleva').ComponentDefinition} ComponentDefinition\n */\n\n/**\n * Simple error handler for the core router.\n * Can be overridden by error handling plugins.\n * Provides consistent error formatting and logging for router operations.\n * @private\n */\nconst CoreErrorHandler = {\n    /**\n     * Handles router errors with basic formatting.\n     * @param {Error} error - The error to handle.\n     * @param {string} context - The context where the error occurred.\n     * @param {Object} details - Additional error details.\n     * @throws {Error} The formatted error.\n     */\n    handle(error, context, details = {}) {\n        const message = `[ElevaRouter] ${context}: ${error.message}`;\n        const formattedError = new Error(message);\n\n        // Preserve original error details\n        formattedError.originalError = error;\n        formattedError.context = context;\n        formattedError.details = details;\n\n        console.error(message, { error, context, details });\n        throw formattedError;\n    },\n\n    /**\n     * Logs a warning without throwing an error.\n     * @param {string} message - The warning message.\n     * @param {Object} details - Additional warning details.\n     */\n    warn(message, details = {}) {\n        console.warn(`[ElevaRouter] ${message}`, details);\n    },\n\n    /**\n     * Logs an error without throwing.\n     * @param {string} message - The error message.\n     * @param {Error} error - The original error.\n     * @param {Object} details - Additional error details.\n     */\n    log(message, error, details = {}) {\n        console.error(`[ElevaRouter] ${message}`, { error, details });\n    }\n};\n\n/**\n * @typedef {Object} RouteLocation\n * @property {string} path - The path of the route (e.g., '/users/123').\n * @property {Object<string, string>} query - An object representing the query parameters.\n * @property {string} fullUrl - The complete URL including hash, path, and query string.\n * @property {Object<string, string>} params - An object containing dynamic route parameters.\n * @property {Object<string, any>} meta - The meta object associated with the matched route.\n * @property {string} [name] - The optional name of the matched route.\n * @property {RouteDefinition} matched - The raw route definition object that was matched.\n */\n\n/**\n * @typedef {(to: RouteLocation, from: RouteLocation | null) => boolean | string | {path: string} | void | Promise<boolean | string | {path: string} | void>} NavigationGuard\n * A function that acts as a guard for navigation. It runs *before* the navigation is confirmed.\n * It can return:\n * - `true` or `undefined`: to allow navigation.\n * - `false`: to abort the navigation.\n * - a `string` (path) or a `location object`: to redirect to a new route.\n */\n\n/**\n * @typedef {(...args: any[]) => void | Promise<void>} NavigationHook\n * A function that acts as a lifecycle hook, typically for side effects. It does not affect navigation flow.\n */\n\n/**\n * @typedef {Object} RouterPlugin\n * @property {string} name - The plugin name.\n * @property {string} [version] - The plugin version.\n * @property {Function} install - The install function that receives the router instance.\n * @property {Function} [destroy] - Optional cleanup function called when the router is destroyed.\n */\n\n/**\n * @typedef {Object} RouteDefinition\n * @property {string} path - The URL path pattern (e.g., '/', '/about', '/users/:id', '*').\n * @property {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} component - The component to render. Can be a registered name, a definition object, or an async import function.\n * @property {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} [layout] - An optional layout component to wrap the route's component.\n * @property {string} [name] - An optional name for the route.\n * @property {Object<string, any>} [meta] - Optional metadata for the route (e.g., for titles, auth flags).\n * @property {NavigationGuard} [beforeEnter] - A route-specific guard executed before entering the route.\n * @property {NavigationHook} [afterEnter] - A hook executed *after* the route has been entered and the new component is mounted.\n * @property {NavigationGuard} [beforeLeave] - A guard executed *before* leaving the current route.\n * @property {NavigationHook} [afterLeave] - A hook executed *after* leaving the current route and its component has been unmounted.\n */\n\n/**\n * @class Router\n * @classdesc A powerful, reactive, and flexible Router Plugin for Eleva.js.\n * This class manages all routing logic, including state, navigation, and rendering.\n * @private\n */\nclass Router {\n    /**\n     * Creates an instance of the Router.\n     * @param {Eleva} eleva - The Eleva framework instance.\n     * @param {RouterOptions} options - The configuration options for the router.\n     */\n    constructor(eleva, options = {}) {\n        /** @type {Eleva} The Eleva framework instance. */\n        this.eleva = eleva;\n\n        /** @type {RouterOptions} The merged router options. */\n        this.options = {\n            mode: \"hash\",\n            queryParam: \"view\",\n            viewSelector: \"root\",\n            ...options,\n        };\n\n        /** @private @type {RouteDefinition[]} The processed list of route definitions. */\n        this.routes = this._processRoutes(options.routes || []);\n\n        /** @private @type {import('eleva').Emitter} The shared Eleva event emitter for global hooks. */\n        this.emitter = this.eleva.emitter;\n\n        /** @private @type {boolean} A flag indicating if the router has been started. */\n        this.isStarted = false;\n\n        /** @private @type {boolean} A flag to prevent navigation loops from history events. */\n        this._isNavigating = false;\n\n        /** @private @type {Array<() => void>} A collection of cleanup functions for event listeners. */\n        this.eventListeners = [];\n\n        /** @type {Signal<RouteLocation | null>} A reactive signal holding the current route's information. */\n        this.currentRoute = new this.eleva.signal(null);\n\n        /** @type {Signal<RouteLocation | null>} A reactive signal holding the previous route's information. */\n        this.previousRoute = new this.eleva.signal(null);\n\n        /** @type {Signal<Object<string, string>>} A reactive signal holding the current route's parameters. */\n        this.currentParams = new this.eleva.signal({});\n\n        /** @type {Signal<Object<string, string>>} A reactive signal holding the current route's query parameters. */\n        this.currentQuery = new this.eleva.signal({});\n\n        /** @type {Signal<import('eleva').MountResult | null>} A reactive signal for the currently mounted layout instance. */\n        this.currentLayout = new this.eleva.signal(null);\n\n        /** @type {Signal<import('eleva').MountResult | null>} A reactive signal for the currently mounted view (page) instance. */\n        this.currentView = new this.eleva.signal(null);\n\n        /** @private @type {Map<string, RouterPlugin>} Map of registered plugins by name. */\n        this.plugins = new Map();\n\n        /** @type {Object} The error handler instance. Can be overridden by plugins. */\n        this.errorHandler = CoreErrorHandler;\n\n        this._validateOptions();\n    }\n\n    /**\n     * Validates the provided router options.\n     * @private\n     * @throws {Error} If the routing mode is invalid.\n     */\n    _validateOptions() {\n        if (![\"hash\", \"query\", \"history\"].includes(this.options.mode)) {\n            this.errorHandler.handle(\n                new Error(`Invalid routing mode: ${this.options.mode}. Must be \"hash\", \"query\", or \"history\".`),\n                \"Configuration validation failed\"\n            );\n        }\n    }\n\n    /**\n     * Pre-processes route definitions to parse their path segments for efficient matching.\n     * @private\n     * @param {RouteDefinition[]} routes - The raw route definitions.\n     * @returns {RouteDefinition[]} The processed routes.\n     */\n    _processRoutes(routes) {\n        const processedRoutes = [];\n        for (const route of routes) {\n            try {\n                processedRoutes.push({\n                    ...route,\n                    segments: this._parsePathIntoSegments(route.path),\n                });\n            } catch (error) {\n                this.errorHandler.warn(\n                    `Invalid path in route definition \"${route.path || \"undefined\"}\": ${error.message}`,\n                    { route, error }\n                );\n            }\n        }\n        return processedRoutes;\n    }\n\n    /**\n     * Parses a route path string into an array of static and parameter segments.\n     * @private\n     * @param {string} path - The path pattern to parse.\n     * @returns {Array<{type: 'static' | 'param', value?: string, name?: string}>} An array of segment objects.\n     * @throws {Error} If the route path is not a valid string.\n     */\n    _parsePathIntoSegments(path) {\n        if (!path || typeof path !== \"string\") {\n            this.errorHandler.handle(\n                new Error(\"Route path must be a non-empty string\"),\n                \"Path parsing failed\",\n                { path }\n            );\n        }\n\n        const normalizedPath = path.replace(/\\/+/g, \"/\").replace(/\\/$/, \"\") || \"/\";\n\n        if (normalizedPath === \"/\") {\n            return [];\n        }\n\n        return normalizedPath\n            .split(\"/\")\n            .filter(Boolean)\n            .map((segment) => {\n                if (segment.startsWith(\":\")) {\n                    const paramName = segment.substring(1);\n                    if (!paramName) {\n                        this.errorHandler.handle(\n                            new Error(`Invalid parameter segment: ${segment}`),\n                            \"Path parsing failed\",\n                            { segment, path }\n                        );\n                    }\n                    return { type: \"param\", name: paramName };\n                }\n                return { type: \"static\", value: segment };\n            });\n    }\n\n    /**\n     * Finds the view element within a container using multiple selector strategies.\n     * @private\n     * @param {HTMLElement} container - The parent element to search within.\n     * @returns {HTMLElement} The found view element or the container itself as a fallback.\n     */\n    _findViewElement(container) {\n        const selector = this.options.viewSelector;\n        return (\n            container.querySelector(`#${selector}`) ||\n            container.querySelector(`.${selector}`) ||\n            container.querySelector(`[data-${selector}]`) ||\n            container.querySelector(selector) ||\n            container\n        );\n    }\n\n    /**\n     * Starts the router, initializes event listeners, and performs the initial navigation.\n     * @returns {Promise<void>}\n     */\n    async start() {\n        if (this.isStarted) {\n            this.errorHandler.warn(\"Router is already started\");\n            return;\n        }\n        if (typeof window === \"undefined\") {\n            this.errorHandler.warn(\n                \"Router start skipped: `window` object not available (SSR environment)\"\n            );\n            return;\n        }\n        if (\n            typeof document !== \"undefined\" &&\n            !document.querySelector(this.options.mount)\n        ) {\n            this.errorHandler.warn(\n                `Mount element \"${this.options.mount}\" was not found in the DOM. The router will not start.`,\n                { mountSelector: this.options.mount }\n            );\n            return;\n        }\n        const handler = () => this._handleRouteChange();\n        if (this.options.mode === \"hash\") {\n            window.addEventListener(\"hashchange\", handler);\n            this.eventListeners.push(() =>\n                window.removeEventListener(\"hashchange\", handler)\n            );\n        } else {\n            window.addEventListener(\"popstate\", handler);\n            this.eventListeners.push(() =>\n                window.removeEventListener(\"popstate\", handler)\n            );\n        }\n        this.isStarted = true;\n        await this._handleRouteChange();\n    }\n\n    /**\n     * Stops the router and cleans up all event listeners and mounted components.\n     * @returns {Promise<void>}\n     */\n    async destroy() {\n        if (!this.isStarted) return;\n\n        // Clean up plugins\n        for (const plugin of this.plugins.values()) {\n            if (typeof plugin.destroy === 'function') {\n                try {\n                    await plugin.destroy(this);\n                } catch (error) {\n                    this.errorHandler.log(`Plugin ${plugin.name} destroy failed`, error);\n                }\n            }\n        }\n\n        this.eventListeners.forEach((cleanup) => cleanup());\n        this.eventListeners = [];\n        if (this.currentLayout.value) {\n            await this.currentLayout.value.unmount();\n        }\n        this.isStarted = false;\n    }\n\n    /**\n     * Programmatically navigates to a new route.\n     * @param {string | {path: string, query?: object, params?: object, replace?: boolean, state?: object}} location - The target location as a string or object.\n     * @param {object} [params] - Optional route parameters (for string-based location).\n     * @returns {Promise<void>}\n     */\n    async navigate(location, params = {}) {\n        try {\n            const target =\n                typeof location === \"string\" ? { path: location, params } : location;\n            let path = this._buildPath(target.path, target.params || {});\n            const query = target.query || {};\n\n            if (Object.keys(query).length > 0) {\n                const queryString = new URLSearchParams(query).toString();\n                if (queryString) path += `?${queryString}`;\n            }\n\n            if (this._isSameRoute(path, target.params, query)) {\n                return;\n            }\n\n            const navigationSuccessful = await this._proceedWithNavigation(path);\n\n            if (navigationSuccessful) {\n                this._isNavigating = true;\n                const state = target.state || {};\n                const replace = target.replace || false;\n                const historyMethod = replace ? \"replaceState\" : \"pushState\";\n\n                if (this.options.mode === \"hash\") {\n                    if (replace) {\n                        const newUrl = `${window.location.pathname}${window.location.search}#${path}`;\n                        window.history.replaceState(state, \"\", newUrl);\n                    } else {\n                        window.location.hash = path;\n                    }\n                } else {\n                    const url =\n                        this.options.mode === \"query\" ? this._buildQueryUrl(path) : path;\n                    history[historyMethod](state, \"\", url);\n                }\n                queueMicrotask(() => {\n                    this._isNavigating = false;\n                });\n            }\n        } catch (error) {\n            this.errorHandler.log(\"Navigation failed\", error);\n            await this.emitter.emit(\"router:onError\", error);\n        }\n    }\n\n    /**\n     * Builds a URL for query mode.\n     * @private\n     * @param {string} path - The path to set as the query parameter.\n     * @returns {string} The full URL with the updated query string.\n     */\n    _buildQueryUrl(path) {\n        const urlParams = new URLSearchParams(window.location.search);\n        urlParams.set(this.options.queryParam, path.split(\"?\")[0]);\n        return `${window.location.pathname}?${urlParams.toString()}`;\n    }\n\n    /**\n     * Checks if the target route is identical to the current route.\n     * @private\n     * @param {string} path - The target path with query string.\n     * @param {object} params - The target params.\n     * @param {object} query - The target query.\n     * @returns {boolean} - True if the routes are the same.\n     */\n    _isSameRoute(path, params, query) {\n        const current = this.currentRoute.value;\n        if (!current) return false;\n        const [targetPath, queryString] = path.split(\"?\");\n        const targetQuery = query || this._parseQuery(queryString || \"\");\n        return (\n            current.path === targetPath &&\n            JSON.stringify(current.params) === JSON.stringify(params || {}) &&\n            JSON.stringify(current.query) === JSON.stringify(targetQuery)\n        );\n    }\n\n    /**\n     * Injects dynamic parameters into a path string.\n     * @private\n     */\n    _buildPath(path, params) {\n        let result = path;\n        for (const [key, value] of Object.entries(params)) {\n            // Fix: Handle special characters and ensure proper encoding\n            const encodedValue = encodeURIComponent(String(value));\n            result = result.replace(new RegExp(`:${key}\\\\b`, \"g\"), encodedValue);\n        }\n        return result;\n    }\n\n    /**\n     * The handler for browser-initiated route changes (e.g., back/forward buttons).\n     * @private\n     */\n    async _handleRouteChange() {\n        if (this._isNavigating) return;\n        const from = this.currentRoute.value;\n        const toLocation = this._getCurrentLocation();\n\n        const navigationSuccessful = await this._proceedWithNavigation(\n            toLocation.fullUrl\n        );\n\n        // If navigation was blocked by a guard, revert the URL change\n        if (!navigationSuccessful && from) {\n            this.navigate({ path: from.path, query: from.query, replace: true });\n        }\n    }\n\n    /**\n     * Manages the core navigation lifecycle. Runs guards before committing changes.\n     * @private\n     * @param {string} fullPath - The full path (e.g., '/users/123?foo=bar') to navigate to.\n     * @returns {Promise<boolean>} - `true` if navigation succeeded, `false` if aborted.\n     */\n    async _proceedWithNavigation(fullPath) {\n        const from = this.currentRoute.value;\n        const [path, queryString] = (fullPath || \"/\").split(\"?\");\n        const toLocation = {\n            path: path.startsWith(\"/\") ? path : `/${path}`,\n            query: this._parseQuery(queryString),\n            fullUrl: fullPath,\n        };\n\n        let toMatch = this._matchRoute(toLocation.path);\n\n        if (!toMatch) {\n            const notFoundRoute = this.routes.find((route) => route.path === \"*\");\n            if (notFoundRoute) {\n                toMatch = {\n                    route: notFoundRoute,\n                    params: { pathMatch: toLocation.path.substring(1) },\n                };\n            } else {\n                await this.emitter.emit(\n                    \"router:onError\",\n                    new Error(`Route not found: ${toLocation.path}`),\n                    toLocation,\n                    from\n                );\n                return false;\n            }\n        }\n\n        const to = {\n            ...toLocation,\n            params: toMatch.params,\n            meta: toMatch.route.meta || {},\n            name: toMatch.route.name,\n            matched: toMatch.route,\n        };\n\n        try {\n            // 1. Run all *pre-navigation* guards.\n            const canNavigate = await this._runGuards(to, from, toMatch.route);\n            if (!canNavigate) return false;\n\n            // 2. Resolve async components *before* touching the DOM.\n            const { layoutComponent, pageComponent } = await this._resolveComponents(\n                toMatch.route\n            );\n\n            // 3. Unmount the previous view/layout.\n            if (from) {\n                const toLayout = toMatch.route.layout || this.options.globalLayout;\n                const fromLayout = from.matched.layout || this.options.globalLayout;\n\n                const tryUnmount = async (instance) => {\n                    if (!instance) return;\n\n                    try {\n                        await instance.unmount();\n                    } catch (error) {\n                        this.errorHandler.warn(\"Error during component unmount\", { error, instance });\n                    }\n                };\n\n                if (toLayout !== fromLayout) {\n                    await tryUnmount(this.currentLayout.value);\n                    this.currentLayout.value = null;\n                } else {\n                    await tryUnmount(this.currentView.value);\n                    this.currentView.value = null;\n                }\n\n                // 4. Call `afterLeave` hook *after* the old component has been unmounted.\n                if (from.matched.afterLeave) {\n                    await from.matched.afterLeave(to, from);\n                    await this.emitter.emit(\"router:afterLeave\", to, from);\n                }\n            }\n\n            // 5. Update reactive state.\n            this.previousRoute.value = from;\n            this.currentRoute.value = to;\n            this.currentParams.value = to.params || {};\n            this.currentQuery.value = to.query || {};\n\n            // 6. Render the new components.\n            await this._render(layoutComponent, pageComponent, to);\n\n            // 7. Run post-navigation hooks.\n            if (toMatch.route.afterEnter) {\n                await toMatch.route.afterEnter(to, from);\n                await this.emitter.emit(\"router:afterEnter\", to, from);\n            }\n            await this.emitter.emit(\"router:afterEach\", to, from);\n\n            return true;\n        } catch (error) {\n            this.errorHandler.log(\"Error during navigation\", error, { to, from });\n            await this.emitter.emit(\"router:onError\", error, to, from);\n            return false;\n        }\n    }\n\n    /**\n     * Executes all applicable navigation guards for a transition in order.\n     * @private\n     * @returns {Promise<boolean>} - `false` if navigation should be aborted.\n     */\n    async _runGuards(to, from, route) {\n        const guards = [\n            ...(this.options.onBeforeEach ? [this.options.onBeforeEach] : []),\n            ...(from && from.matched.beforeLeave ? [from.matched.beforeLeave] : []),\n            ...(route.beforeEnter ? [route.beforeEnter] : []),\n        ];\n        for (const guard of guards) {\n            const result = await guard(to, from);\n            if (result === false) return false;\n            if (typeof result === \"string\" || typeof result === \"object\") {\n                this.navigate(result);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Resolves a string component definition to a component object.\n     * @private\n     * @param {string} def - The component name to resolve.\n     * @returns {ComponentDefinition} The resolved component.\n     * @throws {Error} If the component is not registered.\n     */\n    _resolveStringComponent(def) {\n        const componentDef = this.eleva._components.get(def);\n        if (!componentDef) {\n            this.errorHandler.handle(\n                new Error(`Component \"${def}\" not registered.`),\n                \"Component resolution failed\",\n                { componentName: def, availableComponents: Array.from(this.eleva._components.keys()) }\n            );\n        }\n        return componentDef;\n    }\n\n    /**\n     * Resolves a function component definition to a component object.\n     * @private\n     * @param {Function} def - The function to resolve.\n     * @returns {Promise<ComponentDefinition>} The resolved component.\n     * @throws {Error} If the function fails to load the component.\n     */\n    async _resolveFunctionComponent(def) {\n        try {\n            const funcStr = def.toString();\n            const isAsyncImport = funcStr.includes(\"import(\") || funcStr.startsWith(\"() =>\");\n\n            const result = await def();\n            return isAsyncImport ? (result.default || result) : result;\n        } catch (error) {\n            this.errorHandler.handle(\n                new Error(`Failed to load async component: ${error.message}`),\n                \"Component resolution failed\",\n                { function: def.toString(), error }\n            );\n        }\n    }\n\n    /**\n     * Validates a component definition object.\n     * @private\n     * @param {any} def - The component definition to validate.\n     * @returns {ComponentDefinition} The validated component.\n     * @throws {Error} If the component definition is invalid.\n     */\n    _validateComponentDefinition(def) {\n        if (!def || typeof def !== \"object\") {\n            this.errorHandler.handle(\n                new Error(`Invalid component definition: ${typeof def}`),\n                \"Component validation failed\",\n                { definition: def }\n            );\n        }\n\n        if (typeof def.template !== \"function\" && typeof def.template !== \"string\") {\n            this.errorHandler.handle(\n                new Error(\"Component missing template property\"),\n                \"Component validation failed\",\n                { definition: def }\n            );\n        }\n\n        return def;\n    }\n\n    /**\n     * Resolves a component definition to a component object.\n     * @private\n     * @param {any} def - The component definition to resolve.\n     * @returns {Promise<ComponentDefinition | null>} The resolved component or null.\n     */\n    async _resolveComponent(def) {\n        if (def === null || def === undefined) {\n            return null;\n        }\n\n        if (typeof def === \"string\") {\n            return this._resolveStringComponent(def);\n        }\n\n        if (typeof def === \"function\") {\n            return await this._resolveFunctionComponent(def);\n        }\n\n        if (def && typeof def === \"object\") {\n            return this._validateComponentDefinition(def);\n        }\n\n        this.errorHandler.handle(\n            new Error(`Invalid component definition: ${typeof def}`),\n            \"Component resolution failed\",\n            { definition: def }\n        );\n    }\n\n    /**\n     * Asynchronously resolves the layout and page components for a route.\n     * @private\n     * @param {RouteDefinition} route - The route to resolve components for.\n     * @returns {Promise<{layoutComponent: ComponentDefinition | null, pageComponent: ComponentDefinition}>}\n     */\n    async _resolveComponents(route) {\n        const effectiveLayout = route.layout || this.options.globalLayout;\n\n        try {\n            const [layoutComponent, pageComponent] = await Promise.all([\n                this._resolveComponent(effectiveLayout),\n                this._resolveComponent(route.component),\n            ]);\n\n            if (!pageComponent) {\n                this.errorHandler.handle(\n                    new Error(`Page component is null or undefined for route: ${route.path}`),\n                    \"Component resolution failed\",\n                    { route: route.path }\n                );\n            }\n\n            return { layoutComponent, pageComponent };\n        } catch (error) {\n            this.errorHandler.log(\n                `Error resolving components for route ${route.path}`,\n                error,\n                { route: route.path }\n            );\n            throw error;\n        }\n    }\n\n    /**\n     * Renders the components for the current route into the DOM.\n     * @private\n     * @param {ComponentDefinition | null} layoutComponent - The pre-loaded layout component.\n     * @param {ComponentDefinition} pageComponent - The pre-loaded page component.\n     */\n    async _render(layoutComponent, pageComponent) {\n        const mountEl = document.querySelector(this.options.mount);\n        if (!mountEl) {\n            this.errorHandler.handle(\n                new Error(`Mount element \"${this.options.mount}\" not found.`),\n                { mountSelector: this.options.mount }\n            );\n        }\n\n        if (layoutComponent) {\n            const layoutInstance = await this.eleva.mount(\n                mountEl,\n                this._wrapComponentWithChildren(layoutComponent)\n            );\n            this.currentLayout.value = layoutInstance;\n            const viewEl = this._findViewElement(layoutInstance.container);\n            const viewInstance = await this.eleva.mount(\n                viewEl,\n                this._wrapComponentWithChildren(pageComponent)\n            );\n            this.currentView.value = viewInstance;\n        } else {\n            const viewInstance = await this.eleva.mount(\n                mountEl,\n                this._wrapComponentWithChildren(pageComponent)\n            );\n            this.currentView.value = viewInstance;\n            this.currentLayout.value = null;\n        }\n    }\n\n    /**\n     * Creates a getter function for router context properties.\n     * @private\n     * @param {string} property - The property name to access.\n     * @param {any} defaultValue - The default value if property is undefined.\n     * @returns {Function} A getter function.\n     */\n    _createRouteGetter(property, defaultValue) {\n        return () => this.currentRoute.value?.[property] ?? defaultValue;\n    }\n\n    /**\n     * Wraps a component definition to inject router-specific context into its setup function.\n     * @private\n     * @param {ComponentDefinition} component - The component to wrap.\n     * @returns {ComponentDefinition} The wrapped component definition.\n     */\n    _wrapComponent(component) {\n        const originalSetup = component.setup;\n        const self = this;\n\n        return {\n            ...component,\n            async setup(ctx) {\n                ctx.router = {\n                    navigate: self.navigate.bind(self),\n                    current: self.currentRoute,\n                    previous: self.previousRoute,\n\n                    // Route property getters\n                    get params() { return self._createRouteGetter('params', {})(); },\n                    get query() { return self._createRouteGetter('query', {})(); },\n                    get path() { return self._createRouteGetter('path', '/')(); },\n                    get fullUrl() { return self._createRouteGetter('fullUrl', window.location.href)(); },\n                    get meta() { return self._createRouteGetter('meta', {})(); }\n                };\n\n                return originalSetup ? await originalSetup(ctx) : {};\n            },\n        };\n    }\n\n    /**\n     * Recursively wraps all child components to ensure they have access to router context.\n     * @private\n     * @param {ComponentDefinition} component - The component to wrap.\n     * @returns {ComponentDefinition} The wrapped component definition.\n     */\n    _wrapComponentWithChildren(component) {\n        const wrappedComponent = this._wrapComponent(component);\n\n        // If the component has children, wrap them too\n        if (\n            wrappedComponent.children &&\n            typeof wrappedComponent.children === \"object\"\n        ) {\n            const wrappedChildren = {};\n            for (const [selector, childComponent] of Object.entries(\n                wrappedComponent.children\n            )) {\n                wrappedChildren[selector] =\n                    this._wrapComponentWithChildren(childComponent);\n            }\n            wrappedComponent.children = wrappedChildren;\n        }\n\n        return wrappedComponent;\n    }\n\n    /**\n     * Gets the current location information from the browser's window object.\n     * @private\n     * @returns {Omit<RouteLocation, 'params' | 'meta' | 'name' | 'matched'>}\n     */\n    _getCurrentLocation() {\n        if (typeof window === \"undefined\")\n            return { path: \"/\", query: {}, fullUrl: \"\" };\n        let path, queryString, fullUrl;\n        switch (this.options.mode) {\n            case \"hash\":\n                fullUrl = window.location.hash.slice(1) || \"/\";\n                [path, queryString] = fullUrl.split(\"?\");\n                break;\n            case \"query\":\n                const urlParams = new URLSearchParams(window.location.search);\n                path = urlParams.get(this.options.queryParam) || \"/\";\n                queryString = window.location.search.slice(1);\n                fullUrl = path;\n                break;\n            default: // 'history' mode\n                path = window.location.pathname || \"/\";\n                queryString = window.location.search.slice(1);\n                fullUrl = `${path}${queryString ? \"?\" + queryString : \"\"}`;\n        }\n        return {\n            path: path.startsWith(\"/\") ? path : `/${path}`,\n            query: this._parseQuery(queryString),\n            fullUrl,\n        };\n    }\n\n    /**\n     * Parses a query string into a key-value object.\n     * @private\n     */\n    _parseQuery(queryString) {\n        const query = {};\n        if (queryString) {\n            new URLSearchParams(queryString).forEach((value, key) => {\n                query[key] = value;\n            });\n        }\n        return query;\n    }\n\n    /**\n     * Matches a given path against the registered routes.\n     * @private\n     * @param {string} path - The path to match.\n     * @returns {{route: RouteDefinition, params: Object<string, string>} | null} The matched route and its params, or null.\n     */\n    _matchRoute(path) {\n        const pathSegments = path.split(\"/\").filter(Boolean);\n\n        for (const route of this.routes) {\n            // Handle the root path as a special case.\n            if (route.path === \"/\") {\n                if (pathSegments.length === 0) return { route, params: {} };\n                continue;\n            }\n\n            if (route.segments.length !== pathSegments.length) continue;\n\n            const params = {};\n            let isMatch = true;\n            for (let i = 0; i < route.segments.length; i++) {\n                const routeSegment = route.segments[i];\n                const pathSegment = pathSegments[i];\n                if (routeSegment.type === \"param\") {\n                    params[routeSegment.name] = decodeURIComponent(pathSegment);\n                } else if (routeSegment.value !== pathSegment) {\n                    isMatch = false;\n                    break;\n                }\n            }\n            if (isMatch) return { route, params };\n        }\n        return null;\n    }\n\n    /** Registers a global pre-navigation guard. */\n    onBeforeEach(guard) {\n        this.options.onBeforeEach = guard;\n    }\n    /** Registers a global hook that runs after a new route component has been mounted *if* the route has an `afterEnter` hook. */\n    onAfterEnter(hook) {\n        this.emitter.on(\"router:afterEnter\", hook);\n    }\n    /** Registers a global hook that runs after a route component has been unmounted *if* the route has an `afterLeave` hook. */\n    onAfterLeave(hook) {\n        this.emitter.on(\"router:afterLeave\", hook);\n    }\n    /** Registers a global hook that runs after a navigation has been confirmed and all hooks have completed. */\n    onAfterEach(hook) {\n        this.emitter.on(\"router:afterEach\", hook);\n    }\n    /** Registers a global error handler for navigation. */\n    onError(handler) {\n        this.emitter.on(\"router:onError\", handler);\n    }\n\n    /**\n     * Registers a plugin with the router.\n     * @param {RouterPlugin} plugin - The plugin to register.\n     */\n    use(plugin, options = {}) {\n        if (typeof plugin.install !== 'function') {\n            this.errorHandler.handle(\n                new Error('Plugin must have an install method'),\n                'Plugin registration failed',\n                { plugin }\n            );\n        }\n\n        // Check if plugin is already registered\n        if (this.plugins.has(plugin.name)) {\n            this.errorHandler.warn(\n                `Plugin \"${plugin.name}\" is already registered`,\n                { existingPlugin: this.plugins.get(plugin.name) }\n            );\n            return;\n        }\n\n        this.plugins.set(plugin.name, plugin);\n        plugin.install(this, options);\n    }\n\n    /**\n     * Gets all registered plugins.\n     * @returns {RouterPlugin[]} Array of registered plugins.\n     */\n    getPlugins() {\n        return Array.from(this.plugins.values());\n    }\n\n    /**\n     * Gets a plugin by name.\n     * @param {string} name - The plugin name.\n     * @returns {RouterPlugin | undefined} The plugin or undefined.\n     */\n    getPlugin(name) {\n        return this.plugins.get(name);\n    }\n\n    /**\n     * Removes a plugin from the router.\n     * @param {string} name - The plugin name.\n     * @returns {boolean} True if the plugin was removed.\n     */\n    removePlugin(name) {\n        const plugin = this.plugins.get(name);\n        if (!plugin) return false;\n\n        // Call destroy if available\n        if (typeof plugin.destroy === 'function') {\n            try {\n                plugin.destroy(this);\n            } catch (error) {\n                this.errorHandler.log(`Plugin ${name} destroy failed`, error);\n            }\n        }\n\n        return this.plugins.delete(name);\n    }\n\n    /**\n     * Sets a custom error handler. Used by error handling plugins.\n     * @param {Object} errorHandler - The error handler object with handle, warn, and log methods.\n     */\n    setErrorHandler(errorHandler) {\n        if (errorHandler &&\n            typeof errorHandler.handle === 'function' &&\n            typeof errorHandler.warn === 'function' &&\n            typeof errorHandler.log === 'function') {\n            this.errorHandler = errorHandler;\n        } else {\n            console.warn('[ElevaRouter] Invalid error handler provided. Must have handle, warn, and log methods.');\n        }\n    }\n}\n\n/**\n * @typedef {Object} RouterOptions\n * @property {string} mount - A CSS selector for the main element where the app is mounted.\n * @property {RouteDefinition[]} routes - An array of route definitions.\n * @property {'hash' | 'query' | 'history'} [mode='hash'] - The routing mode.\n * @property {string} [queryParam='page'] - The query parameter to use in 'query' mode.\n * @property {string} [viewSelector='view'] - The selector for the view element within a layout.\n * @property {boolean} [autoStart=true] - Whether to start the router automatically.\n * @property {NavigationGuard} [onBeforeEach] - A global guard executed before every navigation.\n * @property {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} [globalLayout] - A global layout for all routes. Can be overridden by a route's specific layout.\n */\n\n/**\n * @class ðŸš€ RouterPlugin\n * @classdesc A powerful, reactive, and flexible Router Plugin for Eleva.js applications.\n * This plugin provides comprehensive client-side routing functionality including:\n * - Multiple routing modes (hash, history, query)\n * - Navigation guards and lifecycle hooks\n * - Reactive state management\n * - Component resolution and lazy loading\n * - Layout and page component separation\n * - Plugin system for extensibility\n * - Advanced error handling\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * \n * const HomePage = { template: () => `<h1>Home</h1>` };\n * const AboutPage = { template: () => `<h1>About Us</h1>` };\n * const UserPage = { \n *   template: (ctx) => `<h1>User: ${ctx.router.params.id}</h1>` \n * };\n * \n * app.use(RouterPlugin, {\n *   mount: '#app',\n *   mode: 'hash',\n *   routes: [\n *     { path: '/', component: HomePage },\n *     { path: '/about', component: AboutPage },\n *     { path: '/users/:id', component: UserPage }\n *   ]\n * });\n */\nexport const RouterPlugin = {\n    /**\n     * Unique identifier for the plugin\n     * @type {string}\n     */\n    name: \"router\",\n\n    /**\n     * Plugin version\n     * @type {string}\n     */\n    version: \"1.0.0-rc.1\",\n\n    /**\n     * Plugin description\n     * @type {string}\n     */\n    description: \"Client-side routing for Eleva applications\",\n\n    /**\n     * Installs the RouterPlugin into an Eleva instance.\n     * \n     * @param {Eleva} eleva - The Eleva instance\n     * @param {RouterOptions} options - Router configuration options\n     * @param {string} options.mount - A CSS selector for the main element where the app is mounted\n     * @param {RouteDefinition[]} options.routes - An array of route definitions\n     * @param {'hash' | 'query' | 'history'} [options.mode='hash'] - The routing mode\n     * @param {string} [options.queryParam='page'] - The query parameter to use in 'query' mode\n     * @param {string} [options.viewSelector='view'] - The selector for the view element within a layout\n     * @param {boolean} [options.autoStart=true] - Whether to start the router automatically\n     * @param {NavigationGuard} [options.onBeforeEach] - A global guard executed before every navigation\n     * @param {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} [options.globalLayout] - A global layout for all routes\n     * \n     * @example\n     * // main.js\n     * import Eleva from './eleva.js';\n     * import { RouterPlugin } from './plugins/RouterPlugin.js';\n     *\n     * const app = new Eleva('myApp');\n     *\n     * const HomePage = { template: () => `<h1>Home</h1>` };\n     * const AboutPage = { template: () => `<h1>About Us</h1>` };\n     *\n     * app.use(RouterPlugin, {\n     *  mount: '#app',\n     *  routes: [\n     *    { path: '/', component: HomePage },\n     *    { path: '/about', component: AboutPage }\n     *  ]\n     * });\n     */\n    install(eleva, options = {}) {\n        if (!options.mount) {\n            throw new Error(\"[RouterPlugin] 'mount' option is required\");\n        }\n\n        if (!options.routes || !Array.isArray(options.routes)) {\n            throw new Error(\"[RouterPlugin] 'routes' option must be an array\");\n        }\n\n        /**\n         * Registers a component definition with the Eleva instance.\n         * This method handles both inline component objects and pre-registered component names.\n         * \n         * @param {any} def - The component definition to register\n         * @param {string} type - The type of component for naming (e.g., \"Route\", \"Layout\")\n         * @returns {string | null} The registered component name or null if no definition provided\n         */\n        const register = (def, type) => {\n            if (!def) return null;\n\n            if (typeof def === \"object\" && def !== null && !def.name) {\n                const name = `Eleva${type}Component_${Math.random()\n                    .toString(36)\n                    .slice(2, 11)}`;\n\n                try {\n                    eleva.component(name, def);\n                    return name;\n                } catch (error) {\n                    throw new Error(`[RouterPlugin] Failed to register ${type} component: ${error.message}`);\n                }\n            }\n            return def;\n        };\n\n        if (options.globalLayout) {\n            options.globalLayout = register(options.globalLayout, \"GlobalLayout\");\n        }\n\n        (options.routes || []).forEach((route) => {\n            route.component = register(route.component, \"Route\");\n            if (route.layout) {\n                route.layout = register(route.layout, \"RouteLayout\");\n            }\n        });\n\n        const router = new Router(eleva, options);\n        eleva.router = router;\n\n        if (options.autoStart !== false) {\n            queueMicrotask(() => router.start());\n        }\n\n        // Add plugin metadata to the Eleva instance\n        if (!eleva.plugins) {\n            eleva.plugins = new Map();\n        }\n        eleva.plugins.set(this.name, {\n            name: this.name,\n            version: this.version,\n            description: this.description,\n            options\n        });\n\n        // Add utility methods for manual router access\n        eleva.navigate = router.navigate.bind(router);\n        eleva.getCurrentRoute = () => router.currentRoute.value;\n        eleva.getRouteParams = () => router.currentParams.value;\n        eleva.getRouteQuery = () => router.currentQuery.value;\n\n        return router;\n    },\n\n    /**\n     * Uninstalls the plugin from the Eleva instance\n     * \n     * @param {Eleva} eleva - The Eleva instance\n     */\n    async uninstall(eleva) {\n        if (eleva.router) {\n            await eleva.router.destroy();\n            delete eleva.router;\n        }\n\n        // Remove plugin metadata\n        if (eleva.plugins) {\n            eleva.plugins.delete(this.name);\n        }\n\n        // Remove utility methods\n        delete eleva.navigate;\n        delete eleva.getCurrentRoute;\n        delete eleva.getRouteParams;\n        delete eleva.getRouteQuery;\n    }\n};\n"],"names":["CoreErrorHandler","handle","error","context","details","formattedError","Error","message","originalError","warn","log","Router","constructor","eleva","options","this","mode","queryParam","viewSelector","routes","_processRoutes","emitter","isStarted","_isNavigating","eventListeners","currentRoute","signal","previousRoute","currentParams","currentQuery","currentLayout","currentView","plugins","Map","errorHandler","_validateOptions","includes","processedRoutes","route","push","segments","_parsePathIntoSegments","path","normalizedPath","replace","split","filter","Boolean","map","segment","startsWith","paramName","substring","type","name","value","_findViewElement","container","selector","querySelector","start","window","document","mount","mountSelector","handler","_handleRouteChange","addEventListener","removeEventListener","destroy","plugin","values","forEach","cleanup","unmount","navigate","location","params","target","_buildPath","query","Object","keys","length","queryString","URLSearchParams","toString","_isSameRoute","_proceedWithNavigation","state","historyMethod","newUrl","pathname","search","history","replaceState","hash","url","_buildQueryUrl","queueMicrotask","emit","urlParams","set","current","targetPath","targetQuery","_parseQuery","JSON","stringify","result","key","entries","encodedValue","encodeURIComponent","String","RegExp","from","toLocation","_getCurrentLocation","fullUrl","fullPath","toMatch","_matchRoute","notFoundRoute","find","pathMatch","to","meta","matched","_runGuards","layoutComponent","pageComponent","_resolveComponents","tryUnmount","async","instance","layout","globalLayout","afterLeave","_render","afterEnter","guards","onBeforeEach","beforeLeave","beforeEnter","guard","_resolveStringComponent","def","componentDef","_components","get","componentName","availableComponents","Array","_resolveFunctionComponent","funcStr","isAsyncImport","default","function","_validateComponentDefinition","definition","template","_resolveComponent","effectiveLayout","Promise","all","component","mountEl","layoutInstance","_wrapComponentWithChildren","viewEl","viewInstance","_createRouteGetter","property","defaultValue","_wrapComponent","originalSetup","setup","self","ctx","router","bind","previous","href","wrappedComponent","children","wrappedChildren","childComponent","slice","pathSegments","isMatch","i","routeSegment","pathSegment","decodeURIComponent","onAfterEnter","hook","on","onAfterLeave","onAfterEach","onError","use","install","has","existingPlugin","getPlugins","getPlugin","removePlugin","delete","setErrorHandler","version","description","isArray","register","Math","random","autoStart","getCurrentRoute","getRouteParams","getRouteQuery","uninstall"],"mappings":"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"}
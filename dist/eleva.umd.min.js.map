{"version":3,"file":"eleva.umd.min.js","sources":["../src/modules/TemplateEngine.js","../src/modules/Signal.js","../src/modules/Emitter.js","../src/modules/Renderer.js","../src/core/Eleva.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A secure template engine that handles interpolation and dynamic attribute parsing.\n * Provides a safe way to evaluate expressions in templates while preventing XSS attacks.\n * All methods are static and can be called directly on the class.\n *\n * @example\n * const template = \"Hello, {{name}}!\";\n * const data = { name: \"World\" };\n * const result = TemplateEngine.parse(template, data); // Returns: \"Hello, World!\"\n */\nexport class TemplateEngine {\n  /**\n   * @private {RegExp} Regular expression for matching template expressions in the format {{ expression }}\n   */\n  static expressionPattern = /\\{\\{\\s*(.*?)\\s*\\}\\}/g;\n\n  /**\n   * Parses a template string, replacing expressions with their evaluated values.\n   * Expressions are evaluated in the provided data context.\n   *\n   * @public\n   * @static\n   * @param {string} template - The template string to parse.\n   * @param {Object} data - The data context for evaluating expressions.\n   * @returns {string} The parsed template with expressions replaced by their values.\n   * @example\n   * const result = TemplateEngine.parse(\"{{user.name}} is {{user.age}} years old\", {\n   *   user: { name: \"John\", age: 30 }\n   * }); // Returns: \"John is 30 years old\"\n   */\n  static parse(template, data) {\n    if (typeof template !== \"string\") return template;\n    return template.replace(this.expressionPattern, (_, expression) =>\n      this.evaluate(expression, data)\n    );\n  }\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   *\n   * @public\n   * @static\n   * @param {string} expression - The expression to evaluate.\n   * @param {Object} data - The data context for evaluation.\n   * @returns {*} The result of the evaluation, or an empty string if evaluation fails.\n   * @example\n   * const result = TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } }); // Returns: \"John\"\n   * const age = TemplateEngine.evaluate(\"user.age\", { user: { age: 30 } }); // Returns: 30\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    try {\n      return new Function(\"data\", `with(data) { return ${expression}; }`)(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\n/**\n * @class âš¡ Signal\n * @classdesc A reactive data holder that enables fine-grained reactivity in the Eleva framework.\n * Signals notify registered watchers when their value changes, enabling efficient DOM updates\n * through targeted patching rather than full re-renders.\n *\n * @example\n * const count = new Signal(0);\n * count.watch((value) => console.log(`Count changed to: ${value}`));\n * count.value = 1; // Logs: \"Count changed to: 1\"\n * @template T\n */\nexport class Signal {\n  /**\n   * Creates a new Signal instance with the specified initial value.\n   *\n   * @public\n   * @param {*} value - The initial value of the signal.\n   */\n  constructor(value) {\n    /** @private {T} Internal storage for the signal's current value, where T is the type of the initial value */\n    this._value = value;\n    /** @private {Set<function(T): void>} Collection of callback functions to be notified when value changes, where T is the value type */\n    this._watchers = new Set();\n    /** @private {boolean} Flag to prevent multiple synchronous watcher notifications and batch updates into microtasks */\n    this._pending = false;\n  }\n\n  /**\n   * Gets the current value of the signal.\n   *\n   * @public\n   * @returns {T} The current value, where T is the type of the initial value.\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Sets a new value for the signal and notifies all registered watchers if the value has changed.\n   * The notification is batched using microtasks to prevent multiple synchronous updates.\n   *\n   * @public\n   * @param {T} newVal - The new value to set, where T is the type of the initial value.\n   * @returns {void}\n   */\n  set value(newVal) {\n    if (this._value === newVal) return;\n\n    this._value = newVal;\n    this._notify();\n  }\n\n  /**\n   * Registers a watcher function that will be called whenever the signal's value changes.\n   * The watcher will receive the new value as its argument.\n   *\n   * @public\n   * @param {function(T): void} fn - The callback function to invoke on value change, where T is the value type.\n   * @returns {function(): boolean} A function to unsubscribe the watcher.\n   * @example\n   * const unsubscribe = signal.watch((value) => console.log(value));\n   * // Later...\n   * unsubscribe(); // Stops watching for changes\n   */\n  watch(fn) {\n    this._watchers.add(fn);\n    return () => this._watchers.delete(fn);\n  }\n\n  /**\n   * Notifies all registered watchers of a value change using microtask scheduling.\n   * Uses a pending flag to batch multiple synchronous updates into a single notification.\n   * All watcher callbacks receive the current value when executed.\n   *\n   * @private\n   * @returns {void}\n   */\n  _notify() {\n    if (this._pending) return;\n\n    this._pending = true;\n    queueMicrotask(() => {\n      this._watchers.forEach((fn) => fn(this._value));\n      this._pending = false;\n    });\n  }\n}\n","\"use strict\";\n\n/**\n * @class ðŸ“¡ Emitter\n * @classdesc A robust event emitter that enables inter-component communication through a publish-subscribe pattern.\n * Components can emit events and listen for events from other components, facilitating loose coupling\n * and reactive updates across the application.\n *\n * @example\n * const emitter = new Emitter();\n * emitter.on('user:login', (user) => console.log(`User logged in: ${user.name}`));\n * emitter.emit('user:login', { name: 'John' }); // Logs: \"User logged in: John\"\n */\nexport class Emitter {\n  /**\n   * Creates a new Emitter instance.\n   *\n   * @public\n   */\n  constructor() {\n    /** @private {Map<string, Set<function(any): void>>} Map of event names to their registered handler functions */\n    this._events = new Map();\n  }\n\n  /**\n   * Registers an event handler for the specified event name.\n   * The handler will be called with the event data when the event is emitted.\n   *\n   * @public\n   * @param {string} event - The name of the event to listen for.\n   * @param {function(any): void} handler - The callback function to invoke when the event occurs.\n   * @returns {function(): void} A function to unsubscribe the event handler.\n   * @example\n   * const unsubscribe = emitter.on('user:login', (user) => console.log(user));\n   * // Later...\n   * unsubscribe(); // Stops listening for the event\n   */\n  on(event, handler) {\n    if (!this._events.has(event)) this._events.set(event, new Set());\n\n    this._events.get(event).add(handler);\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Removes an event handler for the specified event name.\n   * If no handler is provided, all handlers for the event are removed.\n   *\n   * @public\n   * @param {string} event - The name of the event.\n   * @param {function(any): void} [handler] - The specific handler function to remove.\n   * @returns {void}\n   */\n  off(event, handler) {\n    if (!this._events.has(event)) return;\n    if (handler) {\n      const handlers = this._events.get(event);\n      handlers.delete(handler);\n      // Remove the event if there are no handlers left\n      if (handlers.size === 0) this._events.delete(event);\n    } else {\n      this._events.delete(event);\n    }\n  }\n\n  /**\n   * Emits an event with the specified data to all registered handlers.\n   * Handlers are called synchronously in the order they were registered.\n   *\n   * @public\n   * @param {string} event - The name of the event to emit.\n   * @param {...any} args - Optional arguments to pass to the event handlers.\n   * @returns {void}\n   */\n  emit(event, ...args) {\n    if (!this._events.has(event)) return;\n    this._events.get(event).forEach((handler) => handler(...args));\n  }\n}\n","\"use strict\";\n\n/**\n * @class ðŸŽ¨ Renderer\n * @classdesc A DOM renderer that handles efficient DOM updates through patching and diffing.\n * Provides methods for updating the DOM by comparing new and old structures and applying\n * only the necessary changes, minimizing layout thrashing and improving performance.\n *\n * @example\n * const renderer = new Renderer();\n * const container = document.getElementById(\"app\");\n * const newHtml = \"<div>Updated content</div>\";\n * renderer.patchDOM(container, newHtml);\n */\nexport class Renderer {\n  /**\n   * Creates a new Renderer instance with a reusable temporary container for parsing HTML.\n   * @public\n   */\n  constructor() {\n    /** @private {HTMLElement} Reusable temporary container for parsing new HTML */\n    this._tempContainer = document.createElement(\"div\");\n  }\n\n  /**\n   * Patches the DOM of a container element with new HTML content.\n   * Efficiently updates the DOM by parsing new HTML into a reusable container\n   * and applying only the necessary changes.\n   *\n   * @public\n   * @param {HTMLElement} container - The container element to patch.\n   * @param {string} newHtml - The new HTML content to apply.\n   * @returns {void}\n   * @throws {Error} If container is not an HTMLElement, newHtml is not a string, or patching fails.\n   */\n  patchDOM(container, newHtml) {\n    if (!(container instanceof HTMLElement)) {\n      throw new Error(\"Container must be an HTMLElement\");\n    }\n    if (typeof newHtml !== \"string\") {\n      throw new Error(\"newHtml must be a string\");\n    }\n\n    try {\n      // Directly set new HTML, replacing any existing content\n      this._tempContainer.innerHTML = newHtml;\n\n      this._diff(container, this._tempContainer);\n    } catch {\n      throw new Error(\"Failed to patch DOM\");\n    }\n  }\n\n  /**\n   * Diffs two DOM trees (old and new) and applies updates to the old DOM.\n   * This method recursively compares nodes and their attributes, applying only\n   * the necessary changes to minimize DOM operations.\n   *\n   * @private\n   * @param {HTMLElement} oldParent - The original DOM element.\n   * @param {HTMLElement} newParent - The new DOM element.\n   * @returns {void}\n   */\n  _diff(oldParent, newParent) {\n    if (oldParent.isEqualNode(newParent)) return;\n\n    const oldChildren = oldParent.childNodes;\n    const newChildren = newParent.childNodes;\n    const maxLength = Math.max(oldChildren.length, newChildren.length);\n\n    for (let i = 0; i < maxLength; i++) {\n      const oldNode = oldChildren[i];\n      const newNode = newChildren[i];\n\n      if (oldNode?._eleva_instance) {\n        continue;\n      }\n\n      if (!oldNode && newNode) {\n        oldParent.appendChild(newNode.cloneNode(true));\n        continue;\n      }\n      if (oldNode && !newNode) {\n        if (\n          oldNode.nodeName === \"STYLE\" &&\n          oldNode.hasAttribute(\"data-e-style\")\n        ) {\n          continue;\n        }\n        oldParent.removeChild(oldNode);\n        continue;\n      }\n\n      const isSameType =\n        oldNode.nodeType === newNode.nodeType &&\n        oldNode.nodeName === newNode.nodeName;\n\n      if (!isSameType) {\n        oldParent.replaceChild(newNode.cloneNode(true), oldNode);\n        continue;\n      }\n\n      if (oldNode.nodeType === Node.ELEMENT_NODE) {\n        const oldKey = oldNode.getAttribute(\"key\");\n        const newKey = newNode.getAttribute(\"key\");\n\n        if (oldKey !== newKey && (oldKey || newKey)) {\n          oldParent.replaceChild(newNode.cloneNode(true), oldNode);\n          continue;\n        }\n\n        this._updateAttributes(oldNode, newNode);\n        this._diff(oldNode, newNode);\n      } else if (\n        oldNode.nodeType === Node.TEXT_NODE &&\n        oldNode.nodeValue !== newNode.nodeValue\n      ) {\n        oldNode.nodeValue = newNode.nodeValue;\n      }\n    }\n  }\n\n  /**\n   * Updates the attributes of an element to match those of a new element.\n   * Handles special cases for ARIA attributes, data attributes, and boolean properties.\n   *\n   * @private\n   * @param {HTMLElement} oldEl - The element to update.\n   * @param {HTMLElement} newEl - The element providing the updated attributes.\n   * @returns {void}\n   */\n  _updateAttributes(oldEl, newEl) {\n    const oldAttrs = oldEl.attributes;\n    const newAttrs = newEl.attributes;\n\n    // Update/add new attributes\n    for (const { name, value } of newAttrs) {\n      if (name.startsWith(\"@\")) continue;\n\n      if (oldEl.getAttribute(name) === value) continue;\n\n      oldEl.setAttribute(name, value);\n\n      if (name.startsWith(\"aria-\")) {\n        const prop =\n          \"aria\" +\n          name.slice(5).replace(/-([a-z])/g, (_, l) => l.toUpperCase());\n        oldEl[prop] = value;\n      } else if (name.startsWith(\"data-\")) {\n        oldEl.dataset[name.slice(5)] = value;\n      } else {\n        const prop = name.replace(/-([a-z])/g, (_, l) => l.toUpperCase());\n        if (prop in oldEl) {\n          const descriptor = Object.getOwnPropertyDescriptor(\n            Object.getPrototypeOf(oldEl),\n            prop\n          );\n          const isBoolean =\n            typeof oldEl[prop] === \"boolean\" ||\n            (descriptor?.get &&\n              typeof descriptor.get.call(oldEl) === \"boolean\");\n\n          if (isBoolean) {\n            oldEl[prop] =\n              value !== \"false\" &&\n              (value === \"\" || value === prop || value === \"true\");\n          } else {\n            oldEl[prop] = value;\n          }\n        }\n      }\n    }\n\n    // Remove old attributes\n    for (const { name } of oldAttrs) {\n      if (!newEl.hasAttribute(name)) {\n        oldEl.removeAttribute(name);\n      }\n    }\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\nimport { Signal } from \"../modules/Signal.js\";\nimport { Emitter } from \"../modules/Emitter.js\";\nimport { Renderer } from \"../modules/Renderer.js\";\n\n/**\n * @typedef {Object} ComponentDefinition\n * @property {function(Object<string, any>): (Object<string, any>|Promise<Object<string, any>>)} [setup]\n *           Optional setup function that initializes the component's state and returns reactive data\n * @property {(function(Object<string, any>): string|Promise<string>|string)} template\n *           Required function that defines the component's HTML structure\n * @property {(function(Object<string, any>): string)|string} [style]\n *           Optional function or string that provides component-scoped CSS styles\n * @property {Object<string, ComponentDefinition>} [children]\n *           Optional object defining nested child components\n */\n\n/**\n * @typedef {Object} ElevaPlugin\n * @property {function(Eleva, Object<string, any>): void} install\n *           Function that installs the plugin into the Eleva instance\n * @property {string} name\n *           Unique identifier name for the plugin\n */\n\n/**\n * @typedef {Object} MountResult\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {Object<string, any>} data\n *           The component's reactive state and context data\n * @property {function(): void} unmount\n *           Function to clean up and unmount the component\n */\n\n/**\n * @class ðŸ§© Eleva\n * @classdesc A modern, signal-based component runtime framework that provides lifecycle hooks,\n * scoped styles, and plugin support. Eleva manages component registration, plugin integration,\n * event handling, and DOM rendering with a focus on performance and developer experience.\n *\n * @example\n * const app = new Eleva(\"myApp\");\n * app.component(\"myComponent\", {\n *   template: (ctx) => `<div>Hello ${ctx.props.name}</div>`,\n *   setup: (ctx) => ({ count: new Signal(0) })\n * });\n * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n */\nexport class Eleva {\n  /**\n   * Creates a new Eleva instance with the specified name and configuration.\n   *\n   * @public\n   * @param {string} name - The unique identifier name for this Eleva instance.\n   * @param {Object<string, any>} [config={}] - Optional configuration object for the instance.\n   *        May include framework-wide settings and default behaviors.\n   */\n  constructor(name, config = {}) {\n    /** @public {string} The unique identifier name for this Eleva instance */\n    this.name = name;\n    /** @public {Object<string, any>} Optional configuration object for the Eleva instance */\n    this.config = config;\n    /** @public {Emitter} Instance of the event emitter for handling component events */\n    this.emitter = new Emitter();\n    /** @public {typeof Signal} Static reference to the Signal class for creating reactive state */\n    this.signal = Signal;\n    /** @public {Renderer} Instance of the renderer for handling DOM updates and patching */\n    this.renderer = new Renderer();\n\n    /** @private {Map<string, ComponentDefinition>} Registry of all component definitions by name */\n    this._components = new Map();\n    /** @private {Map<string, ElevaPlugin>} Collection of installed plugin instances by name */\n    this._plugins = new Map();\n    /** @private {string[]} Array of lifecycle hook names supported by components */\n    this._lifecycleHooks = [\n      \"onBeforeMount\",\n      \"onMount\",\n      \"onBeforeUpdate\",\n      \"onUpdate\",\n      \"onUnmount\",\n    ];\n    /** @private {boolean} Flag indicating if the root component is currently mounted */\n    this._isMounted = false;\n  }\n\n  /**\n   * Integrates a plugin with the Eleva framework.\n   * The plugin's install function will be called with the Eleva instance and provided options.\n   * After installation, the plugin will be available for use by components.\n   *\n   * @public\n   * @param {ElevaPlugin} plugin - The plugin object which must have an `install` function.\n   * @param {Object<string, any>} [options={}] - Optional configuration options for the plugin.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @example\n   * app.use(myPlugin, { option1: \"value1\" });\n   */\n  use(plugin, options = {}) {\n    plugin.install(this, options);\n    this._plugins.set(plugin.name, plugin);\n\n    return this;\n  }\n\n  /**\n   * Registers a new component with the Eleva instance.\n   * The component will be available for mounting using its registered name.\n   *\n   * @public\n   * @param {string} name - The unique name of the component to register.\n   * @param {ComponentDefinition} definition - The component definition including setup, template, style, and children.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If the component name is already registered.\n   * @example\n   * app.component(\"myButton\", {\n   *   template: (ctx) => `<button>${ctx.props.text}</button>`,\n   *   style: `button { color: blue; }`\n   * });\n   */\n  component(name, definition) {\n    /** @type {Map<string, ComponentDefinition>} */\n    this._components.set(name, definition);\n    return this;\n  }\n\n  /**\n   * Mounts a registered component to a DOM element.\n   * This will initialize the component, set up its reactive state, and render it to the DOM.\n   *\n   * @public\n   * @param {HTMLElement} container - The DOM element where the component will be mounted.\n   * @param {string|ComponentDefinition} compName - The name of the registered component or a direct component definition.\n   * @param {Object<string, any>} [props={}] - Optional properties to pass to the component.\n   * @returns {Promise<MountResult>}\n   *          A Promise that resolves to an object containing:\n   *          - container: The mounted component's container element\n   *          - data: The component's reactive state and context\n   *          - unmount: Function to clean up and unmount the component\n   * @throws {Error} If the container is not found, or component is not registered.\n   * @example\n   * const instance = await app.mount(document.getElementById(\"app\"), \"myComponent\", { text: \"Click me\" });\n   * // Later...\n   * instance.unmount();\n   */\n  async mount(container, compName, props = {}) {\n    if (!container) throw new Error(`Container not found: ${container}`);\n\n    if (container._eleva_instance) return container._eleva_instance;\n\n    /** @type {ComponentDefinition} */\n    const definition =\n      typeof compName === \"string\" ? this._components.get(compName) : compName;\n    if (!definition) throw new Error(`Component \"${compName}\" not registered.`);\n\n    /**\n     * Destructure the component definition to access core functionality.\n     * - setup: Optional function for component initialization and state management\n     * - template: Required function or string that returns the component's HTML structure\n     * - style: Optional function or string for component-scoped CSS styles\n     * - children: Optional object defining nested child components\n     */\n    const { setup, template, style, children } = definition;\n\n    /**\n     * Creates the initial context object for the component instance.\n     * This context provides core functionality and will be merged with setup data.\n     * @type {Object<string, any>}\n     * @property {Object<string, any>} props - Component properties passed during mounting\n     * @property {Emitter} emitter - Event emitter instance for component event handling\n     * @property {function(any): Signal} signal - Factory function to create reactive Signal instances\n     * @property {Object<string, function(): void>} ...lifecycleHooks - Prepared lifecycle hook functions\n     */\n    const context = {\n      props,\n      emitter: this.emitter,\n      /** @type {(v: any) => Signal<any>} */\n      signal: (v) => new this.signal(v),\n      ...this._prepareLifecycleHooks(),\n    };\n\n    /**\n     * Processes the mounting of the component.\n     * This function handles:\n     * 1. Merging setup data with the component context\n     * 2. Setting up reactive watchers\n     * 3. Rendering the component\n     * 4. Managing component lifecycle\n     *\n     * @param {Object<string, any>} data - Data returned from the component's setup function\n     * @returns {Promise<MountResult>} An object containing:\n     *   - container: The mounted component's container element\n     *   - data: The component's reactive state and context\n     *   - unmount: Function to clean up and unmount the component\n     */\n    const processMount = async (data) => {\n      /** @type {Object<string, any>} */\n      const mergedContext = { ...context, ...data };\n      /** @type {Array<() => void>} */\n      const watcherUnsubscribers = [];\n      /** @type {Array<MountResult>} */\n      const childInstances = [];\n      /** @type {Array<() => void>} */\n      const cleanupListeners = [];\n\n      // Execute before hooks\n      if (!this._isMounted) {\n        mergedContext.onBeforeMount && mergedContext.onBeforeMount();\n      } else {\n        mergedContext.onBeforeUpdate && mergedContext.onBeforeUpdate();\n      }\n\n      /**\n       * Renders the component by:\n       * 1. Processing the template\n       * 2. Updating the DOM\n       * 3. Processing events, injecting styles, and mounting child components.\n       */\n      const render = async () => {\n        const templateResult =\n          typeof template === \"function\"\n            ? await template(mergedContext)\n            : template;\n        const newHtml = TemplateEngine.parse(templateResult, mergedContext);\n        this.renderer.patchDOM(container, newHtml);\n        this._processEvents(container, mergedContext, cleanupListeners);\n        if (style)\n          this._injectStyles(container, compName, style, mergedContext);\n        if (children)\n          await this._mountComponents(container, children, childInstances);\n\n        if (!this._isMounted) {\n          mergedContext.onMount && mergedContext.onMount();\n          this._isMounted = true;\n        } else {\n          mergedContext.onUpdate && mergedContext.onUpdate();\n        }\n      };\n\n      /**\n       * Sets up reactive watchers for all Signal instances in the component's data.\n       * When a Signal's value changes, the component will re-render to reflect the updates.\n       * Stores unsubscribe functions to clean up watchers when component unmounts.\n       */\n      for (const val of Object.values(data)) {\n        if (val instanceof Signal) watcherUnsubscribers.push(val.watch(render));\n      }\n\n      await render();\n\n      const instance = {\n        container,\n        data: mergedContext,\n        /**\n         * Unmounts the component, cleaning up watchers and listeners, child components, and clearing the container.\n         *\n         * @returns {void}\n         */\n        unmount: () => {\n          for (const fn of watcherUnsubscribers) fn();\n          for (const fn of cleanupListeners) fn();\n          for (const child of childInstances) child.unmount();\n          mergedContext.onUnmount && mergedContext.onUnmount();\n          container.innerHTML = \"\";\n          delete container._eleva_instance;\n        },\n      };\n\n      container._eleva_instance = instance;\n      return instance;\n    };\n\n    // Handle asynchronous setup.\n    const setupResult = typeof setup === \"function\" ? await setup(context) : {};\n    return await processMount(setupResult);\n  }\n\n  /**\n   * Prepares default no-operation lifecycle hook functions for a component.\n   * These hooks will be called at various stages of the component's lifecycle.\n   *\n   * @private\n   * @returns {Object<string, function(): void>} An object mapping lifecycle hook names to empty functions.\n   *         The returned object will be merged with the component's context.\n   */\n  _prepareLifecycleHooks() {\n    /** @type {Object<string, () => void>} */\n    const hooks = {};\n    for (const hook of this._lifecycleHooks) {\n      hooks[hook] = () => {};\n    }\n    return hooks;\n  }\n\n  /**\n   * Processes DOM elements for event binding based on attributes starting with \"@\".\n   * This method handles the event delegation system and ensures proper cleanup of event listeners.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element in which to search for event attributes.\n   * @param {Object<string, any>} context - The current component context containing event handler definitions.\n   * @param {Array<Function>} cleanupListeners - Array to collect cleanup functions for each event listener.\n   * @returns {void}\n   */\n  _processEvents(container, context, cleanupListeners) {\n    const elements = container.querySelectorAll(\"*\");\n    for (const el of elements) {\n      const attrs = el.attributes;\n      for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n\n        if (!attr.name.startsWith(\"@\")) continue;\n\n        const event = attr.name.slice(1);\n        const handlerName = attr.value;\n        const handler =\n          context[handlerName] || TemplateEngine.evaluate(handlerName, context);\n        if (typeof handler === \"function\") {\n          el.addEventListener(event, handler);\n          el.removeAttribute(attr.name);\n          cleanupListeners.push(() => el.removeEventListener(event, handler));\n        }\n      }\n    }\n  }\n\n  /**\n   * Injects scoped styles into the component's container.\n   * The styles are automatically prefixed to prevent style leakage to other components.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element where styles should be injected.\n   * @param {string} compName - The component name used to identify the style element.\n   * @param {(function(Object<string, any>): string)|string} styleDef - The component's style definition (function or string).\n   * @param {Object<string, any>} context - The current component context for style interpolation.\n   * @returns {void}\n   */\n  _injectStyles(container, compName, styleDef, context) {\n    const newStyle =\n      typeof styleDef === \"function\"\n        ? TemplateEngine.parse(styleDef(context), context)\n        : styleDef;\n    let styleEl = container.querySelector(`style[data-e-style=\"${compName}\"]`);\n\n    if (styleEl && styleEl.textContent === newStyle) return;\n    if (!styleEl) {\n      styleEl = document.createElement(\"style\");\n      styleEl.setAttribute(\"data-e-style\", compName);\n      container.appendChild(styleEl);\n    }\n\n    styleEl.textContent = newStyle;\n  }\n\n  /**\n   * Extracts props from an element's attributes that start with the specified prefix.\n   * This method is used to collect component properties from DOM elements.\n   *\n   * @private\n   * @param {HTMLElement} element - The DOM element to extract props from\n   * @param {string} prefix - The prefix to look for in attributes\n   * @returns {Object<string, any>} An object containing the extracted props\n   * @example\n   * // For an element with attributes:\n   * // <div :name=\"John\" :age=\"25\">\n   * // Returns: { name: \"John\", age: \"25\" }\n   */\n  _extractProps(element, prefix) {\n    /** @type {Record<string, string>} */\n    const props = {};\n    for (const { name, value } of element.attributes) {\n      if (name.startsWith(prefix)) {\n        props[name.replace(prefix, \"\")] = value;\n      }\n    }\n    return props;\n  }\n\n  /**\n   * Mounts all components within the parent component's container.\n   * This method handles mounting of explicitly defined children components.\n   *\n   * The mounting process follows these steps:\n   * 1. Cleans up any existing component instances\n   * 2. Mounts explicitly defined children components\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount components in\n   * @param {Object<string, ComponentDefinition>} children - Map of selectors to component definitions for explicit children\n   * @param {Array<MountResult>} childInstances - Array to store all mounted component instances\n   * @returns {Promise<void>}\n   *\n   * @example\n   * // Explicit children mounting:\n   * const children = {\n   *   'UserProfile': UserProfileComponent,\n   *   '#settings-panel': \"settings-panel\"\n   * };\n   */\n  async _mountComponents(container, children, childInstances) {\n    for (const [selector, component] of Object.entries(children)) {\n      if (!selector) continue;\n      for (const el of container.querySelectorAll(selector)) {\n        if (!(el instanceof HTMLElement)) continue;\n        const props = this._extractProps(el, \":\");\n        const instance = await this.mount(el, component, props);\n        if (instance && !childInstances.includes(instance)) {\n          childInstances.push(instance);\n        }\n      }\n    }\n  }\n}\n"],"names":["TemplateEngine","static","parse","template","data","replace","this","expressionPattern","_","expression","evaluate","Function","Signal","constructor","value","_value","_watchers","Set","_pending","newVal","_notify","watch","fn","add","delete","queueMicrotask","forEach","Emitter","_events","Map","on","event","handler","has","set","get","off","handlers","size","emit","args","Renderer","_tempContainer","document","createElement","patchDOM","container","newHtml","HTMLElement","Error","innerHTML","_diff","oldParent","newParent","isEqualNode","oldChildren","childNodes","newChildren","maxLength","Math","max","length","i","oldNode","newNode","_eleva_instance","appendChild","cloneNode","nodeName","hasAttribute","removeChild","nodeType","Node","ELEMENT_NODE","oldKey","getAttribute","newKey","replaceChild","_updateAttributes","TEXT_NODE","nodeValue","oldEl","newEl","oldAttrs","attributes","newAttrs","name","startsWith","setAttribute","slice","l","toUpperCase","dataset","prop","descriptor","Object","getOwnPropertyDescriptor","getPrototypeOf","isBoolean","call","removeAttribute","config","emitter","signal","renderer","_components","_plugins","_lifecycleHooks","_isMounted","use","plugin","options","install","component","definition","mount","compName","props","setup","style","children","context","v","_prepareLifecycleHooks","setupResult","async","mergedContext","watcherUnsubscribers","childInstances","cleanupListeners","onBeforeUpdate","onBeforeMount","render","templateResult","_processEvents","_injectStyles","_mountComponents","onUpdate","onMount","val","values","push","instance","unmount","child","onUnmount","processMount","hooks","hook","elements","querySelectorAll","el","attrs","attr","handlerName","addEventListener","removeEventListener","styleDef","newStyle","styleEl","querySelector","textContent","_extractProps","element","prefix","selector","entries","includes"],"mappings":"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"}
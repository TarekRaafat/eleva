{"version":3,"file":"store.cjs","sources":["../../src/plugins/Store.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @module eleva/plugins/store\n * @fileoverview Reactive state management plugin with namespaced modules,\n * persistence, and subscription system.\n */\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\n// -----------------------------------------------------------------------------\n// External Type Imports\n// -----------------------------------------------------------------------------\n\n/**\n * Type imports from the Eleva core library.\n * @typedef {import('eleva').Eleva} Eleva\n * @typedef {import('eleva').ComponentDefinition} ComponentDefinition\n * @typedef {import('eleva').ComponentContext} ComponentContext\n * @typedef {import('eleva').SetupResult} SetupResult\n * @typedef {import('eleva').ComponentProps} ComponentProps\n * @typedef {import('eleva').ChildrenMap} ChildrenMap\n * @typedef {import('eleva').MountResult} MountResult\n */\n\n/**\n * Generic type import.\n * @template T\n * @typedef {import('eleva').Signal<T>} Signal\n */\n\n// -----------------------------------------------------------------------------\n// Store Type Definitions\n// -----------------------------------------------------------------------------\n\n/**\n * Mutation record emitted to subscribers.\n * @typedef {Object} StoreMutation\n * @property {string} type\n *           The action name that was dispatched.\n * @property {unknown} payload\n *           The payload passed to the action.\n * @property {number} timestamp\n *           Unix timestamp of when the mutation occurred.\n * @description Record passed to subscribers when state changes via dispatch.\n * @example\n * store.subscribe((mutation, state) => {\n *   console.log(`Action: ${mutation.type}`);\n *   console.log(`Payload: ${mutation.payload}`);\n *   console.log(`Time: ${new Date(mutation.timestamp)}`);\n * });\n */\n\n/**\n * Store configuration options.\n * @typedef {Object} StoreOptions\n * @property {Record<string, unknown>} [state]\n *           Initial state object.\n * @property {Record<string, ActionFunction>} [actions]\n *           Action functions for state mutations.\n * @property {Record<string, StoreModule>} [namespaces]\n *           Namespaced modules for organizing store.\n * @property {StorePersistenceOptions} [persistence]\n *           Persistence configuration.\n * @property {boolean} [devTools]\n *           Enable development tools integration.\n * @property {StoreErrorHandler} [onError]\n *           Error handler function.\n * @description Configuration options passed to StorePlugin.install().\n * @example\n * app.use(StorePlugin, {\n *   state: { count: 0, user: null },\n *   actions: {\n *     increment: (state) => state.count.value++,\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: { enabled: true, key: 'my-app' }\n * });\n */\n\n/**\n * Namespaced store module definition.\n * @typedef {Object} StoreModule\n * @property {Record<string, unknown>} state\n *           Module state.\n * @property {Record<string, ActionFunction>} [actions]\n *           Module actions.\n * @description Defines a namespaced module for organizing related state and actions.\n * @example\n * // Define a module\n * const authModule = {\n *   state: { user: null, token: null },\n *   actions: {\n *     login: (state, { user, token }) => {\n *       state.auth.user.value = user;\n *       state.auth.token.value = token;\n *     }\n *   }\n * };\n *\n * // Register dynamically\n * store.registerModule('auth', authModule);\n */\n\n/**\n * Store persistence configuration.\n * @typedef {Object} StorePersistenceOptions\n * @property {boolean} [enabled]\n *           Enable state persistence.\n * @property {string} [key]\n *           Storage key (default: \"eleva-store\").\n * @property {'localStorage' | 'sessionStorage'} [storage]\n *           Storage type.\n * @property {string[]} [include]\n *           Dot-path prefixes to persist (e.g., \"auth.user\").\n * @property {string[]} [exclude]\n *           Dot-path prefixes to exclude.\n * @description Configuration for persisting store state to localStorage or sessionStorage.\n * @example\n * // Persist only specific state paths\n * persistence: {\n *   enabled: true,\n *   key: 'my-app-store',\n *   storage: 'localStorage',\n *   include: ['user', 'settings.theme']\n * }\n *\n * @example\n * // Exclude sensitive data\n * persistence: {\n *   enabled: true,\n *   exclude: ['auth.token', 'temp']\n * }\n */\n\n/**\n * Store error handler callback.\n * @typedef {(error: Error, context: string) => void} StoreErrorHandler\n * @description Custom error handler for store operations.\n * @example\n * app.use(StorePlugin, {\n *   onError: (error, context) => {\n *     console.error(`Store error in ${context}:`, error);\n *     // Send to error tracking service\n *     errorTracker.capture(error, { context });\n *   }\n * });\n */\n\n/**\n * Reactive state tree containing signals and nested namespaces.\n * @typedef {Record<string, Signal<unknown> | Record<string, unknown>>} StoreState\n * @description Represents the store's reactive state structure with support for nested modules.\n */\n\n/**\n * Action function signature for store actions.\n * @typedef {(state: StoreState, payload?: unknown) => unknown} ActionFunction\n * @description Function that receives state and optional payload, returns action result.\n */\n\n/**\n * Dispatch function signature for triggering actions.\n * @typedef {(actionName: string, payload?: unknown) => Promise<unknown>} DispatchFunction\n * @description Dispatches an action by name with optional payload, returns action result.\n */\n\n/**\n * Subscribe callback signature for mutation listeners.\n * @typedef {(mutation: StoreMutation, state: StoreState) => void} SubscribeCallback\n * @description Called after each successful action dispatch with mutation details and current state.\n */\n\n/**\n * Store API exposed to components via ctx.store.\n * @typedef {Object} StoreApi\n * @property {StoreState} state\n *           Reactive state signals (supports nested modules).\n * @property {DispatchFunction} dispatch\n *           Dispatch an action by name with optional payload.\n * @property {(callback: SubscribeCallback) => () => void} subscribe\n *           Subscribe to state mutations. Returns unsubscribe function.\n * @property {() => Record<string, unknown>} getState\n *           Get a snapshot of current state values.\n * @property {(namespace: string, module: StoreModule) => void} registerModule\n *           Register a namespaced module dynamically.\n * @property {(namespace: string) => void} unregisterModule\n *           Unregister a namespaced module.\n * @property {(key: string, initialValue: unknown) => Signal<unknown>} createState\n *           Create a new state signal dynamically.\n * @property {(name: string, actionFn: ActionFunction) => void} createAction\n *           Register a new action dynamically.\n * @property {new <T>(value: T) => Signal<T>} signal\n *           Signal class constructor for manual state creation.\n * @description The store API injected into component setup as `ctx.store`.\n * @example\n * app.component('Counter', {\n *   setup({ store }) {\n *     // Access reactive state\n *     const count = store.state.count;\n *\n *     // Dispatch actions\n *     const increment = () => store.dispatch('increment');\n *\n *     // Subscribe to changes\n *     const unsub = store.subscribe((mutation) => {\n *       console.log('State changed:', mutation.type);\n *     });\n *\n *     return { count, increment, onUnmount: () => unsub() };\n *   },\n *   template: (ctx) => `<button @click=\"increment\">${ctx.count.value}</button>`\n * });\n * @see StoreMutation - Mutation record structure.\n * @see StoreModule - Module definition for namespaces.\n */\n\n/**\n * @class ðŸª StorePlugin\n * @classdesc A powerful reactive state management plugin for Eleva that enables sharing\n * reactive data across the entire application. The Store plugin provides a centralized,\n * reactive data store that can be accessed from any component's setup function.\n *\n * Core Features:\n * - Centralized reactive state management using Eleva's signal system\n * - Global state accessibility through component setup functions\n * - Namespace support for organizing store modules\n * - Built-in persistence with localStorage/sessionStorage support\n * - Action-based state mutations with validation\n * - Subscription system for reactive updates\n * - DevTools integration for debugging\n * - Plugin architecture for extensibility\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(StorePlugin, {\n *   state: {\n *     user: { name: \"John\", email: \"john@example.com\" },\n *     counter: 0,\n *     todos: []\n *   },\n *   actions: {\n *     increment: (state) => state.counter.value++,\n *     addTodo: (state, todo) => state.todos.value = [...state.todos.value, todo],\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: {\n *     enabled: true,\n *     key: \"myApp-store\",\n *     storage: \"localStorage\"\n *   }\n * });\n *\n * // Use store in components\n * app.component(\"Counter\", {\n *   setup({ store }) {\n *     return {\n *       count: store.state.counter,\n *       increment: () => store.dispatch(\"increment\"),\n *       user: store.state.user\n *     };\n *   },\n *   template: (ctx) => `\n *     <div>\n *       <p>Hello ${ctx.user.value.name}!</p>\n *       <p>Count: ${ctx.count.value}</p>\n *       <button @click=\"increment\">+</button>\n *     </div>\n *   `\n * });\n */\nexport const StorePlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"store\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.1.1\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description:\n    \"Reactive state management for sharing data across the entire Eleva application\",\n\n  /**\n   * Installs the plugin into the Eleva instance.\n   *\n   * @public\n   * @param {Eleva} eleva - The Eleva instance.\n   * @param {StoreOptions} options - Plugin configuration options.\n   * @param {Record<string, unknown>} [options.state={}] - Initial state object.\n   * @param {Record<string, ActionFunction>} [options.actions={}] - Action functions for state mutations.\n   * @param {Record<string, StoreModule>} [options.namespaces={}] - Namespaced modules for organizing store.\n   * @param {StorePersistenceOptions} [options.persistence] - Persistence configuration.\n   * @param {boolean} [options.persistence.enabled=false] - Enable state persistence.\n   * @param {string} [options.persistence.key=\"eleva-store\"] - Storage key.\n   * @param {'localStorage' | 'sessionStorage'} [options.persistence.storage=\"localStorage\"] - Storage type.\n   * @param {string[]} [options.persistence.include] - Dot-path prefixes to persist (e.g., \"auth.user\")\n   * @param {string[]} [options.persistence.exclude] - Dot-path prefixes to exclude (applies when include is empty).\n   * @param {boolean} [options.devTools=false] - Enable development tools integration.\n   * @param {(error: Error, context: string) => void} [options.onError=null] - Error handler function.\n   * @returns {void}\n   * @description\n   * Installs the store and injects `store` into component setup context by wrapping\n   * `eleva.mount` and `eleva._mountComponents`. Also exposes `eleva.store` and\n   * helper methods (`eleva.dispatch`, `eleva.getState`, `eleva.subscribe`, `eleva.createAction`).\n   * Uninstall restores the originals.\n   *\n   * @example\n   * // Basic installation\n   * app.use(StorePlugin, {\n   *   state: { count: 0, user: null },\n   *   actions: {\n   *     increment: (state) => state.count.value++,\n   *     setUser: (state, user) => state.user.value = user\n   *   }\n   * });\n   *\n   * // Advanced installation with persistence and namespaces\n   * app.use(StorePlugin, {\n   *   state: { theme: \"light\" },\n   *   namespaces: {\n   *     auth: {\n   *       state: { user: null, token: null },\n   *       actions: {\n   *         login: (state, { user, token }) => {\n   *           state.auth.user.value = user;\n   *           state.auth.token.value = token;\n   *         },\n   *         logout: (state) => {\n   *           state.auth.user.value = null;\n   *           state.auth.token.value = null;\n   *         }\n   *       }\n   *     }\n   *   },\n   *   persistence: {\n   *     enabled: true,\n   *     include: [\"theme\", \"auth.user\"]\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      state = {},\n      actions = {},\n      namespaces = {},\n      persistence = {},\n      devTools = false,\n      onError = null,\n    } = options;\n\n    /**\n     * @class Store\n     * @classdesc Store instance that manages all state and provides the API.\n     * @private\n     */\n    class Store {\n      /**\n       * Creates a new Store instance.\n       * Initializes state signals, actions, persistence, and devtools integration.\n       *\n       * @constructor\n       */\n      constructor() {\n        /** @type {Record<string, Signal | Record<string, unknown>>} */\n        this.state = {};\n        /** @type {Record<string, ActionFunction | Record<string, ActionFunction>>} */\n        this.actions = {};\n        /** @type {Set<SubscribeCallback>} */\n        this.subscribers = new Set();\n        /** @type {StoreMutation[]} */\n        this.mutations = [];\n        /** @type {{enabled: boolean, key: string, storage: string, include: string[]|null, exclude: string[]|null}} */\n        this.persistence = {\n          enabled: false,\n          key: \"eleva-store\",\n          storage: \"localStorage\",\n          include: null,\n          exclude: null,\n          ...persistence,\n        };\n        /** @type {boolean} */\n        this.devTools = devTools;\n        /** @type {((error: Error, context: string) => void)|null} */\n        this.onError = onError;\n\n        this._initializeState(state, actions);\n        this._initializeNamespaces(namespaces);\n        this._loadPersistedState();\n        this._setupDevTools();\n      }\n\n      /**\n       * Initializes the root state and actions.\n       * Creates reactive signals for each state property and copies actions.\n       *\n       * @private\n       * @param {Record<string, unknown>} initialState - The initial state key-value pairs.\n       * @param {Record<string, ActionFunction>} initialActions - The action functions to register.\n       * @returns {void}\n       */\n      _initializeState(initialState, initialActions) {\n        // Create reactive signals for each state property\n        Object.entries(initialState).forEach(([key, value]) => {\n          this.state[key] = new eleva.signal(value);\n        });\n\n        // Set up actions\n        this.actions = { ...initialActions };\n      }\n\n      /**\n       * Initializes namespaced modules.\n       * Creates namespace objects and populates them with state signals and actions.\n       *\n       * @private\n       * @param {Record<string, StoreModule>} namespaces - Map of namespace names to module definitions.\n       * @returns {void}\n       */\n      _initializeNamespaces(namespaces) {\n        Object.entries(namespaces).forEach(([namespace, module]) => {\n          const { state: moduleState = {}, actions: moduleActions = {} } =\n            module;\n\n          // Create namespace object if it doesn't exist\n          if (!this.state[namespace]) {\n            this.state[namespace] = {};\n          }\n          if (!this.actions[namespace]) {\n            this.actions[namespace] = {};\n          }\n\n          // Initialize namespaced state\n          Object.entries(moduleState).forEach(([key, value]) => {\n            this.state[namespace][key] = new eleva.signal(value);\n          });\n\n          // Set up namespaced actions\n          this.actions[namespace] = { ...moduleActions };\n        });\n      }\n\n      /**\n       * Loads persisted state from storage.\n       * Reads from localStorage/sessionStorage and applies values to state signals.\n       * Does nothing if persistence is disabled or running in SSR environment.\n       *\n       * @private\n       * @returns {void}\n       */\n      _loadPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const persistedData = storage.getItem(this.persistence.key);\n\n          if (persistedData) {\n            const data = JSON.parse(persistedData);\n            this._applyPersistedData(data);\n          }\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to load persisted state\");\n          } else {\n            console.warn(\n              \"[StorePlugin] Failed to load persisted state:\",\n              error\n            );\n          }\n        }\n      }\n\n      /**\n       * Applies persisted data to the current state.\n       * Recursively updates signal values for paths that should be persisted.\n       *\n       * @private\n       * @param {Record<string, unknown>} data - The persisted data object to apply.\n       * @param {Record<string, unknown>} [currentState=this.state] - The current state object to update.\n       * @param {string} [path=\"\"] - The current dot-notation path (for include/exclude filtering).\n       * @returns {void}\n       */\n      _applyPersistedData(data, currentState = this.state, path = \"\") {\n        Object.entries(data).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (\n              currentState[key] &&\n              typeof currentState[key] === \"object\" &&\n              \"value\" in currentState[key]\n            ) {\n              // This is a signal, update its value\n              currentState[key].value = value;\n            } else if (\n              typeof value === \"object\" &&\n              value !== null &&\n              currentState[key]\n            ) {\n              // This is a nested object, recurse\n              this._applyPersistedData(value, currentState[key], fullPath);\n            }\n          }\n        });\n      }\n\n      /**\n       * Determines if a state path should be persisted.\n       * Checks against include/exclude filters configured in persistence options.\n       *\n       * @private\n       * @param {string} path - The dot-notation path to check (e.g., \"auth.user\").\n       * @returns {boolean} True if the path should be persisted, false otherwise.\n       */\n      _shouldPersist(path) {\n        const { include, exclude } = this.persistence;\n\n        if (include && include.length > 0) {\n          return include.some((includePath) => path.startsWith(includePath));\n        }\n\n        if (exclude && exclude.length > 0) {\n          return !exclude.some((excludePath) => path.startsWith(excludePath));\n        }\n\n        return true;\n      }\n\n      /**\n       * Saves current state to storage.\n       * Extracts persistable data and writes to localStorage/sessionStorage.\n       * Does nothing if persistence is disabled or running in SSR environment.\n       *\n       * @private\n       * @returns {void}\n       */\n      _saveState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const dataToSave = this._extractPersistedData();\n          storage.setItem(this.persistence.key, JSON.stringify(dataToSave));\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to save state\");\n          } else {\n            console.warn(\"[StorePlugin] Failed to save state:\", error);\n          }\n        }\n      }\n\n      /**\n       * Extracts data that should be persisted.\n       * Recursively extracts signal values for paths that pass persistence filters.\n       *\n       * @private\n       * @param {Record<string, unknown>} [currentState=this.state] - The state object to extract from.\n       * @param {string} [path=\"\"] - The current dot-notation path (for include/exclude filtering).\n       * @returns {Record<string, unknown>} The extracted data object with raw values (not signals).\n       */\n      _extractPersistedData(currentState = this.state, path = \"\") {\n        const result = {};\n\n        Object.entries(currentState).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (value && typeof value === \"object\" && \"value\" in value) {\n              // This is a signal, extract its value\n              result[key] = value.value;\n            } else if (typeof value === \"object\" && value !== null) {\n              // This is a nested object, recurse\n              const nestedData = this._extractPersistedData(value, fullPath);\n              if (Object.keys(nestedData).length > 0) {\n                result[key] = nestedData;\n              }\n            }\n          }\n        });\n\n        return result;\n      }\n\n      /**\n       * Sets up development tools integration.\n       * Registers the store with Eleva DevTools if available and enabled.\n       * Does nothing if devTools is disabled, running in SSR, or DevTools not installed.\n       *\n       * @private\n       * @returns {void}\n       */\n      _setupDevTools() {\n        if (\n          !this.devTools ||\n          typeof window === \"undefined\" ||\n          !window.__ELEVA_DEVTOOLS__\n        ) {\n          return;\n        }\n\n        window.__ELEVA_DEVTOOLS__.registerStore(this);\n      }\n\n      /**\n       * Dispatches an action to mutate the state.\n       *\n       * Execution flow:\n       * 1. Retrieves the action function (supports namespaced actions like \"auth.login\")\n       * 2. Records mutation for devtools/history (keeps last 100 mutations)\n       * 3. Executes action with await (actions can be sync or async)\n       * 4. Saves state if persistence is enabled\n       * 5. Notifies all subscribers with (mutation, state)\n       * 6. Notifies devtools if enabled\n       *\n       * @note Always returns a Promise regardless of whether the action is sync or async.\n       * Subscriber callbacks that throw are caught and passed to onError handler.\n       *\n       * @async\n       * @param {string} actionName - The name of the action to dispatch (supports dot notation for namespaces).\n       * @param {unknown} payload - The payload to pass to the action.\n       * @returns {Promise<unknown>} The result of the action (undefined if action returns nothing).\n       * @throws {Error} If action is not found or action function throws.\n       * @see subscribe - Listen for mutations triggered by dispatch.\n       * @see getState - Get current state values.\n       */\n      async dispatch(actionName, payload) {\n        try {\n          const action = this._getAction(actionName);\n\n          if (!action) {\n            const error = new Error(`Action \"${actionName}\" not found`);\n            if (this.onError) {\n              this.onError(error, actionName);\n            }\n            throw error;\n          }\n\n          const mutation = {\n            type: actionName,\n            payload,\n            timestamp: Date.now(),\n          };\n\n          // Record mutation for devtools\n          this.mutations.push(mutation);\n          if (this.mutations.length > 100) {\n            this.mutations.shift(); // Keep only last 100 mutations\n          }\n\n          // Execute the action\n          const result = await action.call(null, this.state, payload);\n\n          // Save state if persistence is enabled\n          this._saveState();\n\n          // Notify subscribers\n          this.subscribers.forEach((callback) => {\n            try {\n              callback(mutation, this.state);\n            } catch (error) {\n              if (this.onError) {\n                this.onError(error, \"Subscriber callback failed\");\n              }\n            }\n          });\n\n          // Notify devtools\n          if (\n            this.devTools &&\n            typeof window !== \"undefined\" &&\n            window.__ELEVA_DEVTOOLS__\n          ) {\n            window.__ELEVA_DEVTOOLS__.notifyMutation(mutation, this.state);\n          }\n\n          return result;\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, `Action dispatch failed: ${actionName}`);\n          }\n          throw error;\n        }\n      }\n\n      /**\n       * Gets an action by name (supports namespaced actions).\n       * Traverses the actions object using dot-notation path segments.\n       *\n       * @private\n       * @param {string} actionName - The action name, supports dot notation for namespaces (e.g., \"auth.login\").\n       * @returns {ActionFunction | null} The action function if found and is a function, null otherwise.\n       */\n      _getAction(actionName) {\n        const parts = actionName.split(\".\");\n        let current = this.actions;\n\n        for (const part of parts) {\n          if (current[part] === undefined) {\n            return null;\n          }\n          current = current[part];\n        }\n\n        return typeof current === \"function\" ? current : null;\n      }\n\n      /**\n       * Subscribes to store mutations.\n       * Callback is invoked after every successful action dispatch.\n       *\n       * @param {SubscribeCallback} callback\n       *        Called after each mutation with:\n       *        - mutation.type: The action name that was dispatched\n       *        - mutation.payload: The payload passed to the action\n       *        - mutation.timestamp: When the mutation occurred (Date.now())\n       *        - state: The current state object (contains Signals)\n       * @returns {() => void} Unsubscribe function. Call to stop receiving notifications.\n       * @throws {Error} If callback is not a function.\n       * @see dispatch - Triggers mutations that notify subscribers.\n       */\n      subscribe(callback) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Subscribe callback must be a function\");\n        }\n\n        this.subscribers.add(callback);\n\n        // Return unsubscribe function\n        return () => {\n          this.subscribers.delete(callback);\n        };\n      }\n\n      /**\n       * Gets current state values (not signals).\n       *\n       * @note When persistence include/exclude filters are configured,\n       * this returns only the filtered subset of state.\n       * @returns {Record<string, unknown>} The current state values (filtered by persistence config if set).\n       * @see replaceState - Set state values.\n       * @see subscribe - Listen for state changes.\n       */\n      getState() {\n        return this._extractPersistedData();\n      }\n\n      /**\n       * Replaces state values (useful for testing or state hydration).\n       *\n       * @note When persistence include/exclude filters are configured,\n       * this only updates the filtered subset of state.\n       * @param {Record<string, unknown>} newState - The new state object.\n       * @returns {void}\n       * @see getState - Get current state values.\n       */\n      replaceState(newState) {\n        this._applyPersistedData(newState);\n        this._saveState();\n      }\n\n      /**\n       * Clears persisted state from storage.\n       * Does nothing if persistence is disabled or running in SSR.\n       * @returns {void}\n       */\n      clearPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          storage.removeItem(this.persistence.key);\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to clear persisted state\");\n          }\n        }\n      }\n\n      /**\n       * Registers a new namespaced module at runtime.\n       * Logs a warning if the namespace already exists.\n       * Module state is nested under `state[namespace]` and actions under `actions[namespace]`.\n       * @param {string} namespace - The namespace for the module.\n       * @param {StoreModule} module - The module definition.\n       * @param {Record<string, unknown>} module.state - The module's initial state.\n       * @param {Record<string, ActionFunction>} module.actions - The module's actions.\n       * @returns {void}\n       */\n      registerModule(namespace, module) {\n        if (this.state[namespace] || this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" already exists`);\n          return;\n        }\n\n        // Initialize the module\n        this.state[namespace] = {};\n        this.actions[namespace] = {};\n\n        const namespaces = { [namespace]: module };\n        this._initializeNamespaces(namespaces);\n\n        this._saveState();\n      }\n\n      /**\n       * Unregisters a namespaced module.\n       * Logs a warning if the namespace doesn't exist.\n       * Removes both state and actions under the namespace.\n       * @param {string} namespace - The namespace to unregister.\n       * @returns {void}\n       */\n      unregisterModule(namespace) {\n        if (!this.state[namespace] && !this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" does not exist`);\n          return;\n        }\n\n        delete this.state[namespace];\n        delete this.actions[namespace];\n        this._saveState();\n      }\n\n      /**\n       * Creates a new reactive state property at runtime.\n       *\n       * @param {string} key - The state key.\n       * @param {*} initialValue - The initial value.\n       * @returns {Signal} The created signal, or existing signal if key exists.\n       */\n      createState(key, initialValue) {\n        if (this.state[key]) {\n          return this.state[key]; // Return existing state\n        }\n\n        this.state[key] = new eleva.signal(initialValue);\n        this._saveState();\n        return this.state[key];\n      }\n\n      /**\n       * Creates a new action at runtime.\n       * Overwrites existing action if name already exists.\n       * Supports dot-notation for namespaced actions (e.g., \"auth.login\").\n       * @param {string} name - The action name (supports dot notation for namespaces).\n       * @param {ActionFunction} actionFn - The action function (receives state and payload).\n       * @returns {void}\n       * @throws {Error} If actionFn is not a function.\n       * @example\n       * // Root-level action\n       * store.createAction(\"increment\", (state) => state.count.value++);\n       *\n       * // Namespaced action\n       * store.createAction(\"auth.login\", async (state, credentials) => {\n       *   // ... login logic\n       * });\n       */\n      createAction(name, actionFn) {\n        if (typeof actionFn !== \"function\") {\n          throw new Error(\"Action must be a function\");\n        }\n\n        // Fast path: no dot means simple action (avoids array allocation)\n        if (name.indexOf(\".\") === -1) {\n          this.actions[name] = actionFn;\n          return;\n        }\n\n        // Namespaced action, traverse/create nested structure\n        const parts = name.split(\".\");\n        const lastIndex = parts.length - 1;\n        let current = this.actions;\n\n        for (let i = 0; i < lastIndex; i++) {\n          current = current[parts[i]] || (current[parts[i]] = {});\n        }\n        current[parts[lastIndex]] = actionFn;\n      }\n    }\n\n    // Create the store instance\n    const store = new Store();\n\n    // Store the original mount method to override it\n    const originalMount = eleva.mount;\n\n    /**\n     * Overridden mount method that injects store context into components.\n     * Wraps the original mount to add `ctx.store` to the component's setup context.\n     *\n     * @param {HTMLElement} container - The DOM element where the component will be mounted.\n     * @param {string | ComponentDefinition} compName - Component name or definition.\n     * @param {ComponentProps} [props={}] - Optional properties to pass to the component.\n     * @returns {Promise<MountResult>} The mount result.\n     */\n    eleva.mount = async (container, compName, props = {}) => {\n      // Get the component definition\n      const componentDef =\n        typeof compName === \"string\"\n          ? eleva._components.get(compName) || compName\n          : compName;\n\n      if (!componentDef) {\n        return await originalMount.call(eleva, container, compName, props);\n      }\n\n      // Create a wrapped component that injects store into setup\n      const wrappedComponent = {\n        ...componentDef,\n        async setup(ctx) {\n          /** @type {StoreApi} */\n          ctx.store = {\n            // Core store functionality\n            state: store.state,\n            dispatch: store.dispatch.bind(store),\n            subscribe: store.subscribe.bind(store),\n            getState: store.getState.bind(store),\n\n            // Module management\n            registerModule: store.registerModule.bind(store),\n            unregisterModule: store.unregisterModule.bind(store),\n\n            // Utilities for dynamic state/action creation\n            createState: store.createState.bind(store),\n            createAction: store.createAction.bind(store),\n\n            // Access to signal constructor for manual state creation\n            signal: eleva.signal,\n          };\n\n          // Call original setup if it exists\n          const originalSetup = componentDef.setup;\n          const result = originalSetup ? await originalSetup(ctx) : {};\n\n          return result;\n        },\n      };\n\n      // Call original mount with wrapped component\n      return await originalMount.call(\n        eleva,\n        container,\n        wrappedComponent,\n        props\n      );\n    };\n\n    // Override _mountComponents to ensure child components also get store context\n    const originalMountComponents = eleva._mountComponents;\n\n    /**\n     * Overridden _mountComponents method that injects store context into child components.\n     * Wraps each child component's setup function to add `ctx.store` before mounting.\n     *\n     * @param {HTMLElement} container - The parent container element.\n     * @param {ChildrenMap} children - Map of selectors to component definitions.\n     * @param {MountResult[]} childInstances - Array to store mounted instances.\n     * @param {ComponentContext & SetupResult} context - Parent component context.\n     * @returns {Promise<void>}\n     */\n    eleva._mountComponents = async (\n      container,\n      children,\n      childInstances,\n      context\n    ) => {\n      // Create wrapped children with store injection\n      const wrappedChildren = {};\n\n      for (const [selector, childComponent] of Object.entries(children)) {\n        const componentDef =\n          typeof childComponent === \"string\"\n            ? eleva._components.get(childComponent) || childComponent\n            : childComponent;\n\n        if (componentDef && typeof componentDef === \"object\") {\n          wrappedChildren[selector] = {\n            ...componentDef,\n            async setup(ctx) {\n              /** @type {StoreApi} */\n              ctx.store = {\n                // Core store functionality\n                state: store.state,\n                dispatch: store.dispatch.bind(store),\n                subscribe: store.subscribe.bind(store),\n                getState: store.getState.bind(store),\n\n                // Module management\n                registerModule: store.registerModule.bind(store),\n                unregisterModule: store.unregisterModule.bind(store),\n\n                // Utilities for dynamic state/action creation\n                createState: store.createState.bind(store),\n                createAction: store.createAction.bind(store),\n\n                // Access to signal constructor for manual state creation\n                signal: eleva.signal,\n              };\n\n              // Call original setup if it exists\n              const originalSetup = componentDef.setup;\n              const result = originalSetup ? await originalSetup(ctx) : {};\n\n              return result;\n            },\n          };\n        } else {\n          wrappedChildren[selector] = childComponent;\n        }\n      }\n\n      // Call original _mountComponents with wrapped children\n      return await originalMountComponents.call(\n        eleva,\n        container,\n        wrappedChildren,\n        childInstances,\n        context\n      );\n    };\n\n    // Expose store instance and utilities on the Eleva instance\n    /** @type {StoreApi} */\n    eleva.store = store;\n\n    /**\n     * Expose utility methods on the Eleva instance.\n     * These are top-level helpers (e.g., `eleva.dispatch`) in addition to `eleva.store`.\n     */\n    /** @type {(name: string, actionFn: ActionFunction) => void} */\n    eleva.createAction = (name, actionFn) => {\n      store.createAction(name, actionFn);\n    };\n\n    /** @type {DispatchFunction} */\n    eleva.dispatch = (actionName, payload) => {\n      return store.dispatch(actionName, payload);\n    };\n\n    /** @type {() => Record<string, unknown>} */\n    eleva.getState = () => {\n      return store.getState();\n    };\n\n    /** @type {(callback: SubscribeCallback) => () => void} */\n    eleva.subscribe = (callback) => {\n      return store.subscribe(callback);\n    };\n\n    // Store original methods for cleanup\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance.\n   *\n   * @public\n   * @param {Eleva} eleva - The Eleva instance.\n   * @returns {void}\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   * Also removes `eleva.store` and top-level helpers (`eleva.dispatch`,\n   * `eleva.getState`, `eleva.subscribe`, `eleva.createAction`).\n   *\n   * @example\n   * // Uninstall the plugin\n   * StorePlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove store instance and utility methods\n    if (eleva.store) {\n      delete eleva.store;\n    }\n    if (eleva.createAction) {\n      delete eleva.createAction;\n    }\n    if (eleva.dispatch) {\n      delete eleva.dispatch;\n    }\n    if (eleva.getState) {\n      delete eleva.getState;\n    }\n    if (eleva.subscribe) {\n      delete eleva.subscribe;\n    }\n  },\n};\n\n// Short name export for convenience\nexport { StorePlugin as Store };\n"],"names":["StorePlugin","name","version","description","install","eleva","options","state","actions","namespaces","persistence","devTools","onError","Store","_initializeState","initialState","initialActions","Object","entries","forEach","key","value","signal","_initializeNamespaces","namespace","module","moduleState","moduleActions","_loadPersistedState","enabled","window","storage","persistedData","getItem","data","JSON","parse","_applyPersistedData","error","console","warn","currentState","path","fullPath","_shouldPersist","include","exclude","length","some","includePath","startsWith","excludePath","_saveState","dataToSave","_extractPersistedData","setItem","stringify","result","nestedData","keys","_setupDevTools","__ELEVA_DEVTOOLS__","registerStore","dispatch","actionName","payload","action","_getAction","Error","mutation","type","timestamp","Date","now","mutations","push","shift","call","subscribers","callback","notifyMutation","parts","split","current","part","undefined","subscribe","add","delete","getState","replaceState","newState","clearPersistedState","removeItem","registerModule","unregisterModule","createState","initialValue","createAction","actionFn","indexOf","lastIndex","i","Set","store","originalMount","mount","container","compName","props","componentDef","_components","get","wrappedComponent","setup","ctx","bind","originalSetup","originalMountComponents","_mountComponents","children","childInstances","context","wrappedChildren","selector","childComponent","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
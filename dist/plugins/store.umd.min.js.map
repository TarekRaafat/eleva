{"version":3,"file":"store.umd.min.js","sources":["../../src/plugins/Store.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸª StorePlugin\n * @classdesc A powerful reactive state management plugin for Eleva that enables sharing\n * reactive data across the entire application. The Store plugin provides a centralized,\n * reactive data store that can be accessed from any component's setup function.\n *\n * Core Features:\n * - Centralized reactive state management using Eleva's signal system\n * - Global state accessibility through component setup functions\n * - Namespace support for organizing store modules\n * - Built-in persistence with localStorage/sessionStorage support\n * - Action-based state mutations with validation\n * - Subscription system for reactive updates\n * - DevTools integration for debugging\n * - Plugin architecture for extensibility\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(StorePlugin, {\n *   state: {\n *     user: { name: \"John\", email: \"john@example.com\" },\n *     counter: 0,\n *     todos: []\n *   },\n *   actions: {\n *     increment: (state) => state.counter.value++,\n *     addTodo: (state, todo) => state.todos.value.push(todo),\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: {\n *     enabled: true,\n *     key: \"myApp-store\",\n *     storage: \"localStorage\"\n *   }\n * });\n *\n * // Use store in components\n * app.component(\"Counter\", {\n *   setup({ store }) {\n *     return {\n *       count: store.state.counter,\n *       increment: () => store.dispatch(\"increment\"),\n *       user: store.state.user\n *     };\n *   },\n *   template: (ctx) => `\n *     <div>\n *       <p>Hello ${ctx.user.value.name}!</p>\n *       <p>Count: ${ctx.count.value}</p>\n *       <button onclick=\"ctx.increment()\">+</button>\n *     </div>\n *   `\n * });\n */\nexport const StorePlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"store\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.0.0\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description:\n    \"Reactive state management for sharing data across the entire Eleva application\",\n\n  /**\n   * Installs the plugin into the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   * @param {Object} options - Plugin configuration options\n   * @param {Object} [options.state={}] - Initial state object\n   * @param {Object} [options.actions={}] - Action functions for state mutations\n   * @param {Object} [options.namespaces={}] - Namespaced modules for organizing store\n   * @param {Object} [options.persistence] - Persistence configuration\n   * @param {boolean} [options.persistence.enabled=false] - Enable state persistence\n   * @param {string} [options.persistence.key=\"eleva-store\"] - Storage key\n   * @param {\"localStorage\" | \"sessionStorage\"} [options.persistence.storage=\"localStorage\"] - Storage type\n   * @param {Array<string>} [options.persistence.include] - State keys to persist (if not provided, all state is persisted)\n   * @param {Array<string>} [options.persistence.exclude] - State keys to exclude from persistence\n   * @param {boolean} [options.devTools=false] - Enable development tools integration\n   * @param {Function} [options.onError=null] - Error handler function\n   *\n   * @example\n   * // Basic installation\n   * app.use(StorePlugin, {\n   *   state: { count: 0, user: null },\n   *   actions: {\n   *     increment: (state) => state.count.value++,\n   *     setUser: (state, user) => state.user.value = user\n   *   }\n   * });\n   *\n   * // Advanced installation with persistence and namespaces\n   * app.use(StorePlugin, {\n   *   state: { theme: \"light\" },\n   *   namespaces: {\n   *     auth: {\n   *       state: { user: null, token: null },\n   *       actions: {\n   *         login: (state, { user, token }) => {\n   *           state.user.value = user;\n   *           state.token.value = token;\n   *         },\n   *         logout: (state) => {\n   *           state.user.value = null;\n   *           state.token.value = null;\n   *         }\n   *       }\n   *     }\n   *   },\n   *   persistence: {\n   *     enabled: true,\n   *     include: [\"theme\", \"auth.user\"]\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      state = {},\n      actions = {},\n      namespaces = {},\n      persistence = {},\n      devTools = false,\n      onError = null,\n    } = options;\n\n    /**\n     * Store instance that manages all state and provides the API\n     * @private\n     */\n    class Store {\n      constructor() {\n        this.state = {};\n        this.actions = {};\n        this.subscribers = new Set();\n        this.mutations = [];\n        this.persistence = {\n          enabled: false,\n          key: \"eleva-store\",\n          storage: \"localStorage\",\n          include: null,\n          exclude: null,\n          ...persistence,\n        };\n        this.devTools = devTools;\n        this.onError = onError;\n\n        this._initializeState(state, actions);\n        this._initializeNamespaces(namespaces);\n        this._loadPersistedState();\n        this._setupDevTools();\n      }\n\n      /**\n       * Initializes the root state and actions\n       * @private\n       */\n      _initializeState(initialState, initialActions) {\n        // Create reactive signals for each state property\n        Object.entries(initialState).forEach(([key, value]) => {\n          this.state[key] = new eleva.signal(value);\n        });\n\n        // Set up actions\n        this.actions = { ...initialActions };\n      }\n\n      /**\n       * Initializes namespaced modules\n       * @private\n       */\n      _initializeNamespaces(namespaces) {\n        Object.entries(namespaces).forEach(([namespace, module]) => {\n          const { state: moduleState = {}, actions: moduleActions = {} } =\n            module;\n\n          // Create namespace object if it doesn't exist\n          if (!this.state[namespace]) {\n            this.state[namespace] = {};\n          }\n          if (!this.actions[namespace]) {\n            this.actions[namespace] = {};\n          }\n\n          // Initialize namespaced state\n          Object.entries(moduleState).forEach(([key, value]) => {\n            this.state[namespace][key] = new eleva.signal(value);\n          });\n\n          // Set up namespaced actions\n          this.actions[namespace] = { ...moduleActions };\n        });\n      }\n\n      /**\n       * Loads persisted state from storage\n       * @private\n       */\n      _loadPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const persistedData = storage.getItem(this.persistence.key);\n\n          if (persistedData) {\n            const data = JSON.parse(persistedData);\n            this._applyPersistedData(data);\n          }\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to load persisted state\");\n          } else {\n            console.warn(\n              \"[StorePlugin] Failed to load persisted state:\",\n              error\n            );\n          }\n        }\n      }\n\n      /**\n       * Applies persisted data to the current state\n       * @private\n       */\n      _applyPersistedData(data, currentState = this.state, path = \"\") {\n        Object.entries(data).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (\n              currentState[key] &&\n              typeof currentState[key] === \"object\" &&\n              \"value\" in currentState[key]\n            ) {\n              // This is a signal, update its value\n              currentState[key].value = value;\n            } else if (\n              typeof value === \"object\" &&\n              value !== null &&\n              currentState[key]\n            ) {\n              // This is a nested object, recurse\n              this._applyPersistedData(value, currentState[key], fullPath);\n            }\n          }\n        });\n      }\n\n      /**\n       * Determines if a state path should be persisted\n       * @private\n       */\n      _shouldPersist(path) {\n        const { include, exclude } = this.persistence;\n\n        if (include && include.length > 0) {\n          return include.some((includePath) => path.startsWith(includePath));\n        }\n\n        if (exclude && exclude.length > 0) {\n          return !exclude.some((excludePath) => path.startsWith(excludePath));\n        }\n\n        return true;\n      }\n\n      /**\n       * Saves current state to storage\n       * @private\n       */\n      _saveState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const dataToSave = this._extractPersistedData();\n          storage.setItem(this.persistence.key, JSON.stringify(dataToSave));\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to save state\");\n          } else {\n            console.warn(\"[StorePlugin] Failed to save state:\", error);\n          }\n        }\n      }\n\n      /**\n       * Extracts data that should be persisted\n       * @private\n       */\n      _extractPersistedData(currentState = this.state, path = \"\") {\n        const result = {};\n\n        Object.entries(currentState).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (value && typeof value === \"object\" && \"value\" in value) {\n              // This is a signal, extract its value\n              result[key] = value.value;\n            } else if (typeof value === \"object\" && value !== null) {\n              // This is a nested object, recurse\n              const nestedData = this._extractPersistedData(value, fullPath);\n              if (Object.keys(nestedData).length > 0) {\n                result[key] = nestedData;\n              }\n            }\n          }\n        });\n\n        return result;\n      }\n\n      /**\n       * Sets up development tools integration\n       * @private\n       */\n      _setupDevTools() {\n        if (\n          !this.devTools ||\n          typeof window === \"undefined\" ||\n          !window.__ELEVA_DEVTOOLS__\n        ) {\n          return;\n        }\n\n        window.__ELEVA_DEVTOOLS__.registerStore(this);\n      }\n\n      /**\n       * Dispatches an action to mutate the state\n       * @param {string} actionName - The name of the action to dispatch (supports namespaced actions like \"auth.login\")\n       * @param {any} payload - The payload to pass to the action\n       * @returns {Promise<any>} The result of the action\n       */\n      async dispatch(actionName, payload) {\n        try {\n          const action = this._getAction(actionName);\n\n          if (!action) {\n            const error = new Error(`Action \"${actionName}\" not found`);\n            if (this.onError) {\n              this.onError(error, actionName);\n            }\n            throw error;\n          }\n\n          const mutation = {\n            type: actionName,\n            payload,\n            timestamp: Date.now(),\n          };\n\n          // Record mutation for devtools\n          this.mutations.push(mutation);\n          if (this.mutations.length > 100) {\n            this.mutations.shift(); // Keep only last 100 mutations\n          }\n\n          // Execute the action\n          const result = await action.call(null, this.state, payload);\n\n          // Save state if persistence is enabled\n          this._saveState();\n\n          // Notify subscribers\n          this.subscribers.forEach((callback) => {\n            try {\n              callback(mutation, this.state);\n            } catch (error) {\n              if (this.onError) {\n                this.onError(error, \"Subscriber callback failed\");\n              }\n            }\n          });\n\n          // Notify devtools\n          if (\n            this.devTools &&\n            typeof window !== \"undefined\" &&\n            window.__ELEVA_DEVTOOLS__\n          ) {\n            window.__ELEVA_DEVTOOLS__.notifyMutation(mutation, this.state);\n          }\n\n          return result;\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, `Action dispatch failed: ${actionName}`);\n          }\n          throw error;\n        }\n      }\n\n      /**\n       * Gets an action by name (supports namespaced actions)\n       * @private\n       */\n      _getAction(actionName) {\n        const parts = actionName.split(\".\");\n        let current = this.actions;\n\n        for (const part of parts) {\n          if (current[part] === undefined) {\n            return null;\n          }\n          current = current[part];\n        }\n\n        return typeof current === \"function\" ? current : null;\n      }\n\n      /**\n       * Subscribes to store mutations\n       * @param {Function} callback - Callback function to call on mutations\n       * @returns {Function} Unsubscribe function\n       */\n      subscribe(callback) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Subscribe callback must be a function\");\n        }\n\n        this.subscribers.add(callback);\n\n        // Return unsubscribe function\n        return () => {\n          this.subscribers.delete(callback);\n        };\n      }\n\n      /**\n       * Gets a deep copy of the current state values (not signals)\n       * @returns {Object} The current state values\n       */\n      getState() {\n        return this._extractPersistedData();\n      }\n\n      /**\n       * Replaces the entire state (useful for testing or state hydration)\n       * @param {Object} newState - The new state object\n       */\n      replaceState(newState) {\n        this._applyPersistedData(newState);\n        this._saveState();\n      }\n\n      /**\n       * Clears persisted state from storage\n       */\n      clearPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          storage.removeItem(this.persistence.key);\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to clear persisted state\");\n          }\n        }\n      }\n\n      /**\n       * Registers a new namespaced module at runtime\n       * @param {string} namespace - The namespace for the module\n       * @param {Object} module - The module definition\n       * @param {Object} module.state - The module's initial state\n       * @param {Object} module.actions - The module's actions\n       */\n      registerModule(namespace, module) {\n        if (this.state[namespace] || this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" already exists`);\n          return;\n        }\n\n        // Initialize the module\n        this.state[namespace] = {};\n        this.actions[namespace] = {};\n\n        const namespaces = { [namespace]: module };\n        this._initializeNamespaces(namespaces);\n\n        this._saveState();\n      }\n\n      /**\n       * Unregisters a namespaced module\n       * @param {string} namespace - The namespace to unregister\n       */\n      unregisterModule(namespace) {\n        if (!this.state[namespace] && !this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" does not exist`);\n          return;\n        }\n\n        delete this.state[namespace];\n        delete this.actions[namespace];\n        this._saveState();\n      }\n\n      /**\n       * Creates a new reactive state property at runtime\n       * @param {string} key - The state key\n       * @param {*} initialValue - The initial value\n       * @returns {Object} The created signal\n       */\n      createState(key, initialValue) {\n        if (this.state[key]) {\n          return this.state[key]; // Return existing state\n        }\n\n        this.state[key] = new eleva.signal(initialValue);\n        this._saveState();\n        return this.state[key];\n      }\n\n      /**\n       * Creates a new action at runtime\n       * @param {string} name - The action name\n       * @param {Function} actionFn - The action function\n       */\n      createAction(name, actionFn) {\n        if (typeof actionFn !== \"function\") {\n          throw new Error(\"Action must be a function\");\n        }\n\n        this.actions[name] = actionFn;\n      }\n    }\n\n    // Create the store instance\n    const store = new Store();\n\n    // Store the original mount method to override it\n    const originalMount = eleva.mount;\n\n    /**\n     * Override the mount method to inject store context into components\n     */\n    eleva.mount = async (container, compName, props = {}) => {\n      // Get the component definition\n      const componentDef =\n        typeof compName === \"string\"\n          ? eleva._components.get(compName) || compName\n          : compName;\n\n      if (!componentDef) {\n        return await originalMount.call(eleva, container, compName, props);\n      }\n\n      // Create a wrapped component that injects store into setup\n      const wrappedComponent = {\n        ...componentDef,\n        async setup(ctx) {\n          // Inject store into the context with enhanced API\n          ctx.store = {\n            // Core store functionality\n            state: store.state,\n            dispatch: store.dispatch.bind(store),\n            subscribe: store.subscribe.bind(store),\n            getState: store.getState.bind(store),\n\n            // Module management\n            registerModule: store.registerModule.bind(store),\n            unregisterModule: store.unregisterModule.bind(store),\n\n            // Utilities for dynamic state/action creation\n            createState: store.createState.bind(store),\n            createAction: store.createAction.bind(store),\n\n            // Access to signal constructor for manual state creation\n            signal: eleva.signal,\n          };\n\n          // Call original setup if it exists\n          const originalSetup = componentDef.setup;\n          const result = originalSetup ? await originalSetup(ctx) : {};\n\n          return result;\n        },\n      };\n\n      // Call original mount with wrapped component\n      return await originalMount.call(\n        eleva,\n        container,\n        wrappedComponent,\n        props\n      );\n    };\n\n    // Override _mountComponents to ensure child components also get store context\n    const originalMountComponents = eleva._mountComponents;\n    eleva._mountComponents = async (container, children, childInstances) => {\n      // Create wrapped children with store injection\n      const wrappedChildren = {};\n\n      for (const [selector, childComponent] of Object.entries(children)) {\n        const componentDef =\n          typeof childComponent === \"string\"\n            ? eleva._components.get(childComponent) || childComponent\n            : childComponent;\n\n        if (componentDef && typeof componentDef === \"object\") {\n          wrappedChildren[selector] = {\n            ...componentDef,\n            async setup(ctx) {\n              // Inject store into the context with enhanced API\n              ctx.store = {\n                // Core store functionality\n                state: store.state,\n                dispatch: store.dispatch.bind(store),\n                subscribe: store.subscribe.bind(store),\n                getState: store.getState.bind(store),\n\n                // Module management\n                registerModule: store.registerModule.bind(store),\n                unregisterModule: store.unregisterModule.bind(store),\n\n                // Utilities for dynamic state/action creation\n                createState: store.createState.bind(store),\n                createAction: store.createAction.bind(store),\n\n                // Access to signal constructor for manual state creation\n                signal: eleva.signal,\n              };\n\n              // Call original setup if it exists\n              const originalSetup = componentDef.setup;\n              const result = originalSetup ? await originalSetup(ctx) : {};\n\n              return result;\n            },\n          };\n        } else {\n          wrappedChildren[selector] = childComponent;\n        }\n      }\n\n      // Call original _mountComponents with wrapped children\n      return await originalMountComponents.call(\n        eleva,\n        container,\n        wrappedChildren,\n        childInstances\n      );\n    };\n\n    // Expose store instance and utilities on the Eleva instance\n    eleva.store = store;\n\n    /**\n     * Expose utility methods on the Eleva instance\n     * @namespace eleva.store\n     */\n    eleva.createAction = (name, actionFn) => {\n      store.actions[name] = actionFn;\n    };\n\n    eleva.dispatch = (actionName, payload) => {\n      return store.dispatch(actionName, payload);\n    };\n\n    eleva.getState = () => {\n      return store.getState();\n    };\n\n    eleva.subscribe = (callback) => {\n      return store.subscribe(callback);\n    };\n\n    // Store original methods for cleanup\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   *\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   *\n   * @example\n   * // Uninstall the plugin\n   * StorePlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove store instance and utility methods\n    if (eleva.store) {\n      delete eleva.store;\n    }\n    if (eleva.createAction) {\n      delete eleva.createAction;\n    }\n    if (eleva.dispatch) {\n      delete eleva.dispatch;\n    }\n    if (eleva.getState) {\n      delete eleva.getState;\n    }\n    if (eleva.subscribe) {\n      delete eleva.subscribe;\n    }\n  },\n};\n\n// Short name export for convenience\nexport { StorePlugin as Store };\n"],"names":["StorePlugin","name","version","description","install","eleva","options","state","actions","namespaces","persistence","devTools","onError","store","_initializeState","initialState","initialActions","Object","entries","forEach","key","value","signal","_initializeNamespaces","namespace","module","moduleState","moduleActions","_loadPersistedState","enabled","window","persistedData","storage","getItem","data","JSON","parse","_applyPersistedData","error","currentState","path","fullPath","_shouldPersist","include","exclude","length","some","includePath","startsWith","excludePath","_saveState","dataToSave","_extractPersistedData","setItem","stringify","result","nestedData","keys","_setupDevTools","__ELEVA_DEVTOOLS__","registerStore","dispatch","actionName","payload","action","_getAction","Error","mutation","type","timestamp","Date","now","mutations","push","shift","call","subscribers","callback","notifyMutation","parts","split","current","part","undefined","subscribe","add","delete","getState","replaceState","newState","clearPersistedState","removeItem","registerModule","unregisterModule","createState","initialValue","createAction","actionFn","Set","originalMount","mount","container","compName","props","componentDef","_components","get","wrappedComponent","setup","ctx","bind","originalSetup","originalMountComponents","_mountComponents","children","childInstances","wrappedChildren","selector","childComponent","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
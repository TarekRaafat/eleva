{"version":3,"file":"eleva.d.cts","sources":["../types/modules/Emitter.d.ts","../types/modules/Signal.d.ts","../types/modules/TemplateEngine.d.ts","../types/modules/Renderer.d.ts","../types/core/Eleva.d.ts","../types/index.d.ts"],"sourcesContent":["/**\n * @module eleva/emitter\n * @fileoverview Event emitter for publish-subscribe communication between components.\n */\n/**\n * Callback function invoked when an event is emitted.\n * @callback EventHandler\n * @param {...any} args\n *        Event arguments passed to the handler.\n * @returns {void | Promise<void>}\n */\n/**\n * Function to unsubscribe an event handler.\n * @callback EventUnsubscribe\n * @returns {void}\n */\n/**\n * Event name string identifier.\n * @typedef {string} EventName\n * @description\n * Recommended convention: 'namespace:action' (e.g., 'user:login').\n * This pattern prevents naming collisions and improves code readability.\n *\n * Common namespaces:\n * - `user:` - User-related events (login, logout, update)\n * - `component:` - Component lifecycle events (mount, unmount)\n * - `router:` - Navigation events (beforeEach, afterEach)\n * - `store:` - State management events (change, error)\n * @example\n * 'user:login'      // User logged in\n * 'cart:update'     // Shopping cart updated\n * 'component:mount' // Component was mounted\n */\n/**\n * Interface describing the public API of an Emitter.\n * @typedef {Object} EmitterLike\n * @property {(event: string, handler: EventHandler) => EventUnsubscribe} on\n *           Subscribe to an event.\n * @property {(event: string, handler?: EventHandler) => void} off\n *           Unsubscribe from an event.\n * @property {(event: string, ...args: unknown[]) => void} emit\n *           Emit an event with arguments.\n */\n/**\n * @class ðŸ“¡ Emitter\n * @classdesc A robust event emitter that enables inter-component communication through a publish-subscribe pattern.\n * Components can emit events and listen for events from other components, facilitating loose coupling\n * and reactive updates across the application.\n * Events are handled synchronously in the order they were registered, with proper cleanup\n * of unsubscribed handlers.\n *\n * Event names should follow the format 'namespace:action' for consistency and organization.\n *\n * @example\n * // Basic usage\n * const emitter = new Emitter();\n * emitter.on('user:login', (user) => console.log(`User logged in: ${user.name}`));\n * emitter.emit('user:login', { name: 'John' }); // Logs: \"User logged in: John\"\n *\n * @example\n * // With unsubscribe\n * const unsub = emitter.on('cart:update', (items) => {\n *   console.log(`Cart has ${items.length} items`);\n * });\n * emitter.emit('cart:update', [{ id: 1, name: 'Book' }]); // Logs: \"Cart has 1 items\"\n * unsub(); // Stop listening\n * emitter.emit('cart:update', []); // No log output\n *\n * @example\n * // Multiple arguments\n * emitter.on('order:placed', (orderId, amount, currency) => {\n *   console.log(`Order ${orderId}: ${amount} ${currency}`);\n * });\n * emitter.emit('order:placed', 'ORD-123', 99.99, 'USD');\n *\n * @example\n * // Common event patterns\n * // Lifecycle events\n * emitter.on('component:mount', (component) => {});\n * emitter.on('component:unmount', (component) => {});\n * // Note: These lifecycle names are conventions; Eleva core does not emit them by default.\n * // State events\n * emitter.on('state:change', (newState, oldState) => {});\n * // Navigation events\n * emitter.on('router:navigate', (to, from) => {});\n *\n * @implements {EmitterLike}\n */\nexport class Emitter implements EmitterLike {\n    /**\n     * Map of event names to their registered handler functions\n     * @private\n     * @type {Map<string, Set<EventHandler>>}\n     */\n    private _events;\n    /**\n     * Registers an event handler for the specified event name.\n     * The handler will be called with the event data when the event is emitted.\n     * Event names should follow the format 'namespace:action' for consistency.\n     *\n     * @public\n     * @param {string} event - The name of the event to listen for (e.g., 'user:login').\n     * @param {EventHandler} handler - The callback function to invoke when the event occurs.\n     *        Note: Handlers returning Promises are NOT awaited. For async operations,\n     *        handle promise resolution within your handler.\n     * @returns {EventUnsubscribe} A function to unsubscribe the event handler.\n     *\n     * @example\n     * // Basic subscription\n     * const unsubscribe = emitter.on('user:login', (user) => console.log(user));\n     *\n     * @example\n     * // Handler with typed parameter\n     * emitter.on('user:update', (user) => {\n     *   console.log(`User ${user.id}: ${user.name}`);\n     * });\n     *\n     * @example\n     * // Cleanup\n     * unsubscribe(); // Stops listening for the event\n     */\n    public on(event: string, handler: EventHandler): EventUnsubscribe;\n    /**\n     * Removes an event handler for the specified event name.\n     * Automatically cleans up empty event sets to prevent memory leaks.\n     *\n     * Behavior varies based on whether handler is provided:\n     * - With handler: Removes only that specific handler function (O(1) Set deletion)\n     * - Without handler: Removes ALL handlers for the event (O(1) Map deletion)\n     *\n     * @public\n     * @param {string} event - The name of the event to remove handlers from.\n     * @param {EventHandler} [handler] - The specific handler to remove. If omitted, all handlers are removed.\n     * @returns {void}\n     *\n     * @example\n     * // Remove a specific handler\n     * const loginHandler = (user) => console.log(user);\n     * emitter.on('user:login', loginHandler);\n     * emitter.off('user:login', loginHandler);\n     *\n     * @example\n     * // Remove all handlers for an event\n     * emitter.off('user:login');\n     */\n    public off(event: string, handler?: EventHandler): void;\n    /**\n     * Emits an event with the specified data to all registered handlers.\n     * Handlers are called synchronously in the order they were registered.\n     * If no handlers are registered for the event, the emission is silently ignored.\n     * Handlers that return promises are not awaited.\n     *\n     * Error propagation behavior:\n     * - If a handler throws synchronously, the error propagates immediately\n     * - Remaining handlers in the iteration are NOT called after an error\n     * - For error-resilient emission, wrap your emit call in try/catch\n     * - Async handler rejections are not caught (fire-and-forget)\n     *\n     * @public\n     * @param {string} event - The name of the event to emit.\n     * @param {...any} args - Optional arguments to pass to the event handlers.\n     * @returns {void}\n     * @throws {Error} If a handler throws synchronously, the error propagates to the caller.\n     *\n     * @example\n     * // Emit an event with data\n     * emitter.emit('user:login', { name: 'John', role: 'admin' });\n     *\n     * @example\n     * // Emit an event with multiple arguments\n     * emitter.emit('order:placed', 'ORD-123', 99.99, 'USD');\n     *\n     * @example\n     * // Emit without data\n     * emitter.emit('app:ready');\n     */\n    public emit(event: string, ...args: any[]): void;\n}\n/**\n * Callback function invoked when an event is emitted.\n */\nexport type EventHandler = (...args: any[]) => void | Promise<void>;\n/**\n * Function to unsubscribe an event handler.\n */\nexport type EventUnsubscribe = () => void;\n/**\n * Event name string identifier.\n */\nexport type EventName = string;\n/**\n * Interface describing the public API of an Emitter.\n */\nexport type EmitterLike = {\n    /**\n     *           Subscribe to an event.\n     */\n    on: (event: string, handler: EventHandler) => EventUnsubscribe;\n    /**\n     *           Unsubscribe from an event.\n     */\n    off: (event: string, handler?: EventHandler) => void;\n    /**\n     *           Emit an event with arguments.\n     */\n    emit: (event: string, ...args: unknown[]) => void;\n};\n//# sourceMappingURL=Emitter.d.ts.map","/**\n * @module eleva/signal\n * @fileoverview Reactive Signal primitive for fine-grained state management and change notification.\n */\n/**\n * Callback function invoked when a signal's value changes.\n * @template T The type of value held by the signal.\n * @callback SignalWatcher\n * @param {T} value\n *        The new value of the signal.\n * @returns {void}\n */\n/**\n * Function to unsubscribe a watcher from a signal.\n * @callback SignalUnsubscribe\n * @returns {boolean}\n *          True if the watcher was successfully removed, false if already removed.\n *          Safe to call multiple times (idempotent).\n */\n/**\n * Interface describing the public API of a Signal.\n * @template T The type of value held by the signal.\n * @typedef {Object} SignalLike\n * @property {T} value\n *           The current value of the signal.\n * @property {function(SignalWatcher<T>): SignalUnsubscribe} watch\n *           Subscribe to value changes.\n */\n/**\n * @class âš¡ Signal\n * @classdesc A reactive data holder that enables fine-grained reactivity in the Eleva framework.\n * Signals notify registered watchers synchronously when their value changes, enabling efficient\n * DOM updates through targeted patching rather than full re-renders.\n * Synchronous notification preserves stack traces and allows immediate value inspection.\n * Render batching is handled at the component level, not the signal level.\n * The class is generic, allowing type-safe handling of any value type T.\n *\n * @template T The type of value held by the signal.\n *\n * @example\n * // Basic usage\n * const count = new Signal(0);\n * count.watch((value) => console.log(`Count changed to: ${value}`));\n * count.value = 1; // Logs: \"Count changed to: 1\"\n *\n * @example\n * // With unsubscribe\n * const name = new Signal(\"John\");\n * const unsubscribe = name.watch((value) => console.log(value));\n * name.value = \"Jane\"; // Logs: \"Jane\"\n * unsubscribe(); // Stop watching\n * name.value = \"Bob\"; // No log output\n *\n * @example\n * // With objects\n * const position = new Signal({ x: 0, y: 0 });\n * position.value = { x: 10, y: 20 }; // Triggers watchers\n *\n * @implements {SignalLike<T>}\n */\nexport class Signal<T> implements SignalLike<T> {\n    /**\n     * Creates a new Signal instance with the specified initial value.\n     *\n     * @public\n     * @constructor\n     * @param {T} value - The initial value of the signal.\n     *\n     * @example\n     * // Primitive types\n     * const count = new Signal(0);        // Signal<number>\n     * const name = new Signal(\"John\");    // Signal<string>\n     * const active = new Signal(true);    // Signal<boolean>\n     *\n     * @example\n     * // Complex types\n     * const items = new Signal([]);          // Signal holding an array\n     * const user = new Signal(null);         // Signal holding nullable object\n     */\n    constructor(value: T);\n    /**\n     * Internal storage for the signal's current value.\n     * @private\n     * @type {T}\n     */\n    private _value;\n    /**\n     * Collection of callback functions to be notified when value changes.\n     * @private\n     * @type {Set<SignalWatcher<T>>}\n     */\n    private _watchers;\n    /**\n     * Sets a new value for the signal and synchronously notifies all registered watchers if the value has changed.\n     * Synchronous notification preserves stack traces and ensures immediate value consistency.\n     *\n     * Uses strict equality (===) for comparison. For objects/arrays, watchers are only notified\n     * if the reference changes, not if properties are mutated. To trigger updates with objects,\n     * assign a new reference: `signal.value = { ...signal.value, updated: true }`.\n     *\n     * @public\n     * @param {T} newVal - The new value to set.\n     * @returns {void}\n     */\n    public set value(newVal: T);\n    /**\n     * Gets the current value of the signal.\n     *\n     * @public\n     * @returns {T} The current value.\n     */\n    public get value(): T;\n    /**\n     * Registers a watcher function that will be called whenever the signal's value changes.\n     * The watcher will receive the new value as its argument.\n     *\n     * @public\n     * @param {SignalWatcher<T>} fn - The callback function to invoke on value change.\n     * @returns {SignalUnsubscribe} A function to unsubscribe the watcher.\n     *          Returns true if watcher was removed, false if it wasn't registered.\n     *          Safe to call multiple times (idempotent after first call).\n     *\n     * @example\n     * // Basic watching\n     * const unsubscribe = signal.watch((value) => console.log(value));\n     *\n     * @example\n     * // Stop watching\n     * unsubscribe(); // Returns true if watcher was removed\n     * unsubscribe(); // Returns false (already removed, safe to call again)\n     *\n     * @example\n     * // Multiple watchers\n     * const unsub1 = signal.watch((v) => console.log(\"Watcher 1:\", v));\n     * const unsub2 = signal.watch((v) => console.log(\"Watcher 2:\", v));\n     * signal.value = \"test\"; // Both watchers are called\n     */\n    public watch(fn: SignalWatcher<T>): SignalUnsubscribe;\n    /**\n     * Synchronously notifies all registered watchers of the value change.\n     * This preserves stack traces for debugging and ensures immediate\n     * value consistency. Render batching is handled at the component level.\n     *\n     * @note If a watcher throws, subsequent watchers are NOT called.\n     * The error propagates to the caller (the setter).\n     *\n     * @private\n     * @returns {void}\n     */\n    private _notify;\n}\n/**\n * Callback function invoked when a signal's value changes.\n */\nexport type SignalWatcher<T> = (value: T) => void;\n/**\n * Function to unsubscribe a watcher from a signal.\n */\nexport type SignalUnsubscribe = () => boolean;\n/**\n * Interface describing the public API of a Signal.\n */\nexport type SignalLike<T> = {\n    /**\n     *           The current value of the signal.\n     */\n    value: T;\n    /**\n     *           Subscribe to value changes.\n     */\n    watch: (arg0: SignalWatcher<T>) => SignalUnsubscribe;\n};\n//# sourceMappingURL=Signal.d.ts.map","/**\n * @module eleva/template-engine\n * @fileoverview Expression evaluator for directive attributes and property bindings.\n */\n/**\n * Data context object for expression evaluation.\n * @typedef {Record<string, unknown>} ContextData\n * @description Contains variables and functions available during template evaluation.\n */\n/**\n * JavaScript expression string to be evaluated.\n * @typedef {string} Expression\n * @description A JavaScript expression evaluated against a ContextData object.\n */\n/**\n * Result of evaluating an expression.\n * @typedef {unknown} EvaluationResult\n * @description Can be string, number, boolean, object, function, or any JavaScript value.\n */\n/**\n * Compiled expression function cached for performance.\n * @typedef {(data: ContextData) => EvaluationResult} CompiledExpressionFunction\n * @description Pre-compiled function that evaluates an expression against context data.\n */\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A minimal expression evaluator for Eleva's directive attributes.\n * Evaluates JavaScript expressions against a component's context data.\n * Used internally for `@event` handlers and `:prop` bindings.\n *\n * All methods are static and can be called directly on the class.\n *\n * @example\n * // Property access\n * TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } });\n * // Result: \"John\"\n *\n * @example\n * // Function reference (for @event handlers)\n * TemplateEngine.evaluate(\"handleClick\", { handleClick: () => console.log(\"clicked\") });\n * // Result: [Function]\n *\n * @example\n * // Signal values (for :prop bindings)\n * TemplateEngine.evaluate(\"count.value\", { count: { value: 42 } });\n * // Result: 42\n *\n * @example\n * // Complex expressions\n * TemplateEngine.evaluate(\"items.filter(i => i.active)\", { items: [{active: true}, {active: false}] });\n * // Result: [{active: true}]\n */\nexport class TemplateEngine {\n    /**\n     * Cache for compiled expression functions.\n     * Stores compiled Function objects keyed by expression string for O(1) lookup.\n     * The cache persists for the application lifetime and is never cleared.\n     * This improves performance for repeated evaluations of the same expression.\n     *\n     * Memory consideration: For applications with highly dynamic expressions\n     * (e.g., user-generated), memory usage grows unbounded. This is typically\n     * not an issue for static templates where expressions are finite.\n     *\n     * @static\n     * @private\n     * @type {Map<string, CompiledExpressionFunction>}\n     */\n    private static _functionCache;\n    /**\n     * Evaluates an expression in the context of the provided data object.\n     * Used for resolving `@event` handlers and `:prop` bindings.\n     * Non-string expressions are returned as-is.\n     *\n     * @security CRITICAL SECURITY WARNING\n     * This method is NOT sandboxed. It uses `new Function()` and `with` statement,\n     * allowing full access to the global scope. Potential attack vectors include:\n     * - Code injection via malicious expressions\n     * - XSS attacks if user input is used as expressions\n     * - Access to sensitive globals (window, document, fetch, etc.)\n     *\n     * ONLY use with developer-defined template strings.\n     * NEVER use with user-provided input or untrusted data.\n     *\n     * Mitigation strategies:\n     * - Always sanitize any user-generated content before rendering in templates\n     * - Use Content Security Policy (CSP) headers to restrict script execution\n     * - Keep expressions simple (property access, method calls) - avoid complex logic\n     *\n     * @public\n     * @static\n     * @param {Expression | unknown} expression - The expression to evaluate.\n     * @param {ContextData} data - The data context for evaluation.\n     * @returns {EvaluationResult} The result of the evaluation, or empty string if evaluation fails.\n     * @note Evaluation failures return an empty string without throwing.\n     *\n     * @example\n     * // Property access\n     * TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } });\n     * // Result: \"John\"\n     *\n     * @example\n     * // Function reference\n     * TemplateEngine.evaluate(\"increment\", { increment: () => count++ });\n     * // Result: [Function]\n     *\n     * @example\n     * // Nested property with Signal\n     * TemplateEngine.evaluate(\"count.value\", { count: { value: 42 } });\n     * // Result: 42\n     *\n     * @example\n     * // Object reference (no JSON.stringify needed)\n     * TemplateEngine.evaluate(\"user\", { user: { name: \"John\", age: 30 } });\n     * // Result: { name: \"John\", age: 30 }\n     *\n     * @example\n     * // Expressions\n     * TemplateEngine.evaluate(\"items.length > 0\", { items: [1, 2, 3] });\n     * // Result: true\n     *\n     * @example\n     * // Failed evaluation returns empty string\n     * TemplateEngine.evaluate(\"nonexistent.property\", {});\n     * // Result: \"\"\n     */\n    public static evaluate(expression: Expression | unknown, data: ContextData): EvaluationResult;\n}\n/**\n * Data context object for expression evaluation.\n */\nexport type ContextData = Record<string, unknown>;\n/**\n * JavaScript expression string to be evaluated.\n */\nexport type Expression = string;\n/**\n * Result of evaluating an expression.\n */\nexport type EvaluationResult = unknown;\n/**\n * Compiled expression function cached for performance.\n */\nexport type CompiledExpressionFunction = (data: ContextData) => EvaluationResult;\n//# sourceMappingURL=TemplateEngine.d.ts.map","/**\n * @class ðŸŽ¨ Renderer\n * @classdesc A high-performance DOM renderer that implements an optimized two-pointer diffing\n * algorithm with key-based node reconciliation. The renderer efficiently updates the DOM by\n * computing the minimal set of operations needed to transform the current state to the desired state.\n *\n * Key features:\n * - Two-pointer diffing algorithm for efficient DOM updates\n * - Key-based node reconciliation for optimal list performance (O(1) lookup)\n * - Preserves DOM node identity during reordering (maintains event listeners, focus, animations)\n * - Intelligent attribute synchronization (skips Eleva event attributes)\n * - Preservation of Eleva-managed component instances and style elements\n *\n * @example\n * // Basic usage\n * const renderer = new Renderer();\n * renderer.patchDOM(container, '<div>Updated content</div>');\n *\n * @example\n * // With keyed elements for optimal list updates\n * const html = items.map(item => `<li key=\"${item.id}\">${item.name}</li>`).join('');\n * renderer.patchDOM(listContainer, `<ul>${html}</ul>`);\n *\n * @example\n * // Keyed elements preserve DOM identity during reordering\n * // Before: [A, B, C] -> After: [C, A, B]\n * // The actual DOM nodes are moved, not recreated\n * renderer.patchDOM(container, '<div key=\"C\">C</div><div key=\"A\">A</div><div key=\"B\">B</div>');\n *\n * @implements {RendererLike}\n */\nexport class Renderer implements RendererLike {\n    /**\n     * Temporary container for parsing new HTML content.\n     * Reused across patch operations to minimize memory allocation.\n     * @private\n     * @type {HTMLDivElement}\n     */\n    private _tempContainer;\n    /**\n     * Patches the DOM of the given container with the provided HTML string.\n     * Uses an optimized two-pointer diffing algorithm to minimize DOM operations.\n     * The algorithm computes the minimal set of insertions, deletions, and updates\n     * needed to transform the current DOM state to match the new HTML.\n     *\n     * @public\n     * @param {HTMLElement} container - The container element to patch.\n     * @param {string} newHtml - The new HTML string to render.\n     * @returns {void}\n     *\n     * @example\n     * // Simple content update\n     * renderer.patchDOM(container, '<div class=\"updated\">New content</div>');\n     *\n     * @example\n     * // List with keyed items (optimal for reordering)\n     * renderer.patchDOM(container, '<ul><li key=\"1\">First</li><li key=\"2\">Second</li></ul>');\n     *\n     * @example\n     * // Empty the container\n     * renderer.patchDOM(container, '');\n     *\n     * @see _diff - Low-level diffing algorithm.\n     * @see _patchNode - Individual node patching.\n     */\n    public patchDOM(container: HTMLElement, newHtml: string): void;\n    /**\n     * Performs a diff between two DOM nodes and patches the old node to match the new node.\n     * Uses a two-pointer algorithm with key-based reconciliation for optimal performance.\n     * This method modifies oldParent in-place - it is not a pure function.\n     *\n     * Algorithm details:\n     * 1. Early exit if both nodes have no children (O(1) leaf node optimization)\n     * 2. Convert NodeLists to arrays for indexed access\n     * 3. Initialize two-pointer indices (oldStart/oldEnd, newStart/newEnd)\n     * 4. While pointers haven't crossed:\n     *    a. Skip null entries (from previous moves)\n     *    b. If nodes match (same key+tag or same type+name): patch and advance\n     *    c. On mismatch: lazily build keyâ†’node map for O(1) lookup\n     *    d. If keyed match found: move existing node (preserves DOM identity)\n     *    e. Otherwise: clone and insert new node\n     * 5. After loop: append remaining new nodes or remove remaining old nodes\n     *\n     * Complexity: O(n) for most cases, O(nÂ²) worst case with no keys.\n     * Non-keyed elements are matched by position and tag name.\n     *\n     * @private\n     * @param {Element} oldParent - The original DOM element to update (modified in-place).\n     * @param {Element} newParent - The new DOM element with desired state.\n     * @returns {void}\n     */\n    private _diff;\n    /**\n     * Patches a single node, updating its content and attributes to match the new node.\n     * Handles text nodes (nodeType 3 / Node.TEXT_NODE) by updating nodeValue,\n     * and element nodes (nodeType 1 / Node.ELEMENT_NODE) by updating attributes\n     * and recursively diffing children.\n     *\n     * Skips nodes that are managed by Eleva component instances to prevent interference\n     * with nested component state.\n     *\n     * @private\n     * @param {Node} oldNode - The original DOM node to update.\n     * @param {Node} newNode - The new DOM node with desired state.\n     * @returns {void}\n     */\n    private _patchNode;\n    /**\n     * Removes a node from its parent, with special handling for Eleva-managed elements.\n     * Style elements with the `data-e-style` attribute are preserved to maintain\n     * component styles across re-renders. Without this protection, component styles\n     * would be removed during DOM diffing and lost until the next full re-render.\n     *\n     * @note Style tags persist for the component's entire lifecycle. If the template\n     * conditionally removes elements that the CSS rules target (e.g., `.foo` elements),\n     * the style rules remain but simply have no matching elements. This is expected\n     * behavior - styles are cleaned up when the component unmounts, not when individual\n     * elements are removed.\n     *\n     * @private\n     * @param {HTMLElement} parent - The parent element containing the node.\n     * @param {Node} node - The node to remove.\n     * @returns {void}\n     * @see _injectStyles - Where data-e-style elements are created.\n     */\n    private _removeNode;\n    /**\n     * Updates the attributes of an element to match a new element's attributes.\n     * Adds new attributes, updates changed values, and removes attributes no longer present.\n     * Also syncs DOM properties that can diverge from attributes after user interaction.\n     *\n     * Processing order:\n     * 1. Iterate new attributes, skip @ prefixed (event) attributes\n     * 2. Update attribute if value changed\n     * 3. Sync corresponding DOM property if writable (handles boolean conversion)\n     * 4. Iterate old attributes in reverse, remove if not in new element\n     * 5. Sync SYNC_PROPS (value, checked, selected) from new to old element\n     *\n     * @private\n     * @param {Element} oldEl - The original element to update.\n     * @param {Element} newEl - The new element with target attributes.\n     * @returns {void}\n     */\n    private _updateAttributes;\n    /**\n     * Determines if two nodes are the same for reconciliation purposes.\n     * Two nodes are considered the same if:\n     * - Both have keys: keys match AND tag names match\n     * - Neither has keys: node types match AND node names match\n     * - One has key, other doesn't: not the same\n     *\n     * This ensures keyed elements are only reused when both key and tag match,\n     * preventing bugs like `<div key=\"a\">` incorrectly matching `<span key=\"a\">`.\n     *\n     * @private\n     * @param {Node} oldNode - The first node to compare.\n     * @param {Node} newNode - The second node to compare.\n     * @returns {boolean} True if the nodes are considered the same for reconciliation.\n     */\n    private _isSameNode;\n    /**\n     * Extracts the key attribute from a node if it exists.\n     * Only element nodes (nodeType === 1) can have key attributes.\n     * Uses optional chaining for null-safe access.\n     *\n     * @private\n     * @param {Node | null | undefined} node - The node to extract the key from.\n     * @returns {string | null} The key attribute value, or null if not an element or no key.\n     */\n    private _getNodeKey;\n    /**\n     * Creates a key map for efficient O(1) lookup of keyed elements during diffing.\n     * The map is built lazily only when needed (when a mismatch occurs during diffing).\n     *\n     * @private\n     * @param {ChildNode[]} children - The array of child nodes to map.\n     * @param {number} start - The start index (inclusive) for mapping.\n     * @param {number} end - The end index (inclusive) for mapping.\n     * @returns {KeyMap} A Map of key strings to their corresponding DOM nodes.\n     */\n    private _createKeyMap;\n}\n/**\n * Map of key attribute values to their corresponding DOM nodes.\n */\nexport type KeyMap = Map<string, Node>;\n/**\n * Interface describing the public API of a Renderer.\n */\nexport type RendererLike = {\n    /**\n     *           Patches the DOM with new HTML content.\n     */\n    patchDOM: (arg0: HTMLElement, arg1: string) => void;\n};\n//# sourceMappingURL=Renderer.d.ts.map","/**\n * Configuration options for the Eleva instance (reserved for future use).\n * @typedef {Record<string, unknown>} ElevaConfig\n */\n/**\n * Component definition object.\n * @typedef {Object} ComponentDefinition\n * @property {SetupFunction} [setup]\n *           Optional setup function that initializes the component's state and returns reactive data.\n * @property {TemplateFunction | string} template\n *           Required function or string that defines the component's HTML structure.\n * @property {StyleFunction | string} [style]\n *           Optional function or string that provides CSS styles for the component.\n *           Styles are preserved across DOM diffs via data-e-style markers.\n * @property {ChildrenMap} [children]\n *           Optional object defining nested child components.\n */\n/**\n * Setup function that initializes component state.\n * @callback SetupFunction\n * @param {ComponentContext} ctx\n *        The component context with props, emitter, and signal factory.\n * @returns {SetupResult | Promise<SetupResult>}\n *          Reactive data and lifecycle hooks.\n */\n/**\n * Data returned from setup function, may include lifecycle hooks.\n * @typedef {Record<string, unknown> & LifecycleHooks} SetupResult\n */\n/**\n * Template function that returns HTML markup.\n * @callback TemplateFunction\n * @param {ComponentContext & SetupResult} ctx\n *        The merged component context and setup data.\n * @returns {string | Promise<string>}\n *          HTML template string.\n */\n/**\n * Style function that returns CSS styles.\n * @callback StyleFunction\n * @param {ComponentContext & SetupResult} ctx\n *        The merged component context and setup data.\n * @returns {string}\n *          CSS styles string.\n */\n/**\n * Map of CSS selectors to component definitions or registered component names.\n * @typedef {Record<string, ComponentDefinition | string>} ChildrenMap\n */\n/**\n * Context passed to component setup function.\n * @typedef {Object} ComponentContext\n * @property {ComponentProps} props\n *           Component properties passed during mounting.\n * @property {Emitter} emitter\n *           Event emitter instance for component event handling.\n * @property {SignalFactory} signal\n *           Factory function to create reactive Signal instances.\n * @description\n * Plugins may extend this context with additional properties (e.g., `ctx.router`, `ctx.store`).\n * @see RouterContext - Router plugin injected context.\n * @see StoreApi - Store plugin injected context.\n */\n/**\n * Properties passed to a component during mounting.\n * @typedef {Record<string, unknown>} ComponentProps\n */\n/**\n * Factory function to create reactive Signal instances.\n * @typedef {<T>(initialValue: T) => Signal<T>} SignalFactory\n */\n/**\n * Lifecycle hooks that can be returned from setup function.\n * @typedef {Object} LifecycleHooks\n * @property {LifecycleHook} [onBeforeMount]\n *           Called before component mounting.\n * @property {LifecycleHook} [onMount]\n *           Called after component mounting.\n * @property {LifecycleHook} [onBeforeUpdate]\n *           Called before component update.\n * @property {LifecycleHook} [onUpdate]\n *           Called after component update.\n * @property {UnmountHook} [onUnmount]\n *           Called during component unmounting.\n */\n/**\n * Lifecycle hook function.\n * @callback LifecycleHook\n * @param {LifecycleHookContext} ctx\n *        Context with container and component data.\n * @returns {void | Promise<void>}\n */\n/**\n * Unmount hook function with cleanup resources.\n * @callback UnmountHook\n * @param {UnmountHookContext} ctx\n *        Context with cleanup resources.\n * @returns {void | Promise<void>}\n */\n/**\n * Context passed to lifecycle hooks.\n * @typedef {Object} LifecycleHookContext\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted.\n * @property {ComponentContext & SetupResult} context\n *           The component's reactive state and context data.\n */\n/**\n * Context passed to unmount hook with cleanup resources.\n * @typedef {Object} UnmountHookContext\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted.\n * @property {ComponentContext & SetupResult} context\n *           The component's reactive state and context data.\n * @property {CleanupResources} cleanup\n *           Object containing cleanup functions and instances.\n */\n/**\n * Resources available for cleanup during unmount.\n * @typedef {Object} CleanupResources\n * @property {UnsubscribeFunction[]} watchers\n *           Signal watcher cleanup functions.\n * @property {UnsubscribeFunction[]} listeners\n *           Event listener cleanup functions.\n * @property {MountResult[]} children\n *           Child component instances.\n */\n/**\n * Result of mounting a component.\n * @typedef {Object} MountResult\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted.\n * @property {ComponentContext & SetupResult} data\n *           The component's reactive state and context data.\n * @property {UnmountFunction} unmount\n *           Function to clean up and unmount the component.\n */\n/**\n * Function to unmount a component and clean up resources.\n * @callback UnmountFunction\n * @returns {Promise<void>}\n */\n/**\n * Function to unsubscribe from events or watchers.\n * @callback UnsubscribeFunction\n * @returns {void | boolean}\n */\n/**\n * Plugin interface for extending Eleva.\n * @typedef {Object} ElevaPlugin\n * @property {string} name\n *           Unique identifier name for the plugin.\n * @property {string} [version]\n *           Optional version string for the plugin.\n * @property {PluginInstallFunction} install\n *           Function that installs the plugin.\n * @property {PluginUninstallFunction} [uninstall]\n *           Optional function to uninstall the plugin.\n */\n/**\n * Plugin install function.\n * @callback PluginInstallFunction\n * @param {Eleva} eleva\n *        The Eleva instance.\n * @param {PluginOptions} [options]\n *        Plugin configuration options.\n * @returns {void | Eleva | unknown}\n */\n/**\n * Plugin uninstall function.\n * @callback PluginUninstallFunction\n * @param {Eleva} eleva\n *        The Eleva instance.\n * @returns {void | Promise<void>}\n */\n/**\n * Configuration options passed to a plugin during installation.\n * @typedef {Record<string, unknown>} PluginOptions\n */\n/**\n * Handler function for DOM events (e.g., click, input, submit).\n * @typedef {(event: Event) => void} DOMEventHandler\n */\n/**\n * Common DOM event names (prefixed with @ in templates).\n * @typedef {'click'|'submit'|'input'|'change'|'focus'|'blur'|'keydown'|'keyup'|'keypress'|'mouseenter'|'mouseleave'|'mouseover'|'mouseout'|'mousedown'|'mouseup'|'touchstart'|'touchend'|'touchmove'|'scroll'|'resize'|'load'|'error'|string} DOMEventName\n */\n/**\n * @class ðŸ§© Eleva\n * @classdesc A modern, signal-based component runtime framework that provides lifecycle hooks,\n * component styles, and plugin support. Eleva manages component registration, plugin integration,\n * event handling, and DOM rendering with a focus on performance and developer experience.\n *\n * @example\n * // Basic component creation and mounting\n * const app = new Eleva(\"myApp\");\n * app.component(\"myComponent\", {\n *   setup: (ctx) => ({ count: ctx.signal(0) }),\n *   template: (ctx) => `<div>Hello ${ctx.props.name}</div>`\n * });\n * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n *\n * @example\n * // Using lifecycle hooks\n * app.component(\"lifecycleDemo\", {\n *   setup: () => {\n *     return {\n *       onMount: ({ container, context }) => {\n *         console.log('Component mounted!');\n *       }\n *     };\n *   },\n *   template: `<div>Lifecycle Demo</div>`\n * });\n */\nexport class Eleva {\n    /**\n     * Creates a new Eleva instance with the specified name and configuration.\n     *\n     * @public\n     * @constructor\n     * @param {string} name - The unique identifier name for this Eleva instance.\n     * @param {ElevaConfig} [config={}] - Optional configuration object for the instance.\n     * @throws {Error} If the name is not provided or is not a string.\n     *\n     * @example\n     * const app = new Eleva(\"myApp\");\n     * app.component(\"myComponent\", {\n     *   setup: (ctx) => ({ count: ctx.signal(0) }),\n     *   template: (ctx) => `<div>Hello ${ctx.props.name}!</div>`\n     * });\n     * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n     *\n     */\n    constructor(name: string, config?: ElevaConfig);\n    /** @public @readonly {string} The unique identifier name for this Eleva instance */\n    public readonly name: string;\n    /** @public @readonly {Record<string, unknown>} Configuration object for the Eleva instance */\n    public readonly config: ElevaConfig;\n    /** @public @readonly {Emitter} Event emitter for handling component events */\n    public readonly emitter: Emitter;\n    /** @public @readonly {typeof Signal} Signal class for creating reactive state */\n    public readonly signal: typeof Signal;\n    /** @public @readonly {typeof TemplateEngine} TemplateEngine class for template parsing */\n    public readonly templateEngine: typeof TemplateEngine;\n    /** @public @readonly {Renderer} Renderer for handling DOM updates and patching */\n    public readonly renderer: Renderer;\n    /** @private {Map<string, ComponentDefinition>} Registry of all component definitions by name */\n    private _components;\n    /** @private {Map<string, ElevaPlugin>} Collection of installed plugin instances by name */\n    private _plugins;\n    /** @private {number} Counter for generating unique component IDs */\n    private _componentCounter;\n    /**\n     * Integrates a plugin with the Eleva framework.\n     * The plugin's install function will be called with the Eleva instance and provided options.\n     * After installation, the plugin will be available for use by components.\n     *\n     * @note Plugins that wrap core methods (e.g., mount) must be uninstalled in reverse order\n     * of installation (LIFO - Last In, First Out) to avoid conflicts.\n     *\n     * @public\n     * @param {ElevaPlugin} plugin - The plugin object which must have an `install` function.\n     * @param {PluginOptions} [options={}] - Optional configuration options for the plugin.\n     * @returns {Eleva | unknown} The Eleva instance (for method chaining) or the result returned by the plugin.\n     * @throws {Error} If plugin does not have an install function.\n     * @see component - Register components after installing plugins.\n     * @see mount - Mount components to the DOM.\n     * @example\n     * app.use(myPlugin, { option1: \"value1\" });\n     *\n     * @example\n     * // Correct uninstall order (LIFO)\n     * app.use(PluginA);\n     * app.use(PluginB);\n     * // Uninstall in reverse order:\n     * PluginB.uninstall(app);\n     * PluginA.uninstall(app);\n     */\n    public use(plugin: ElevaPlugin, options?: PluginOptions): Eleva | unknown;\n    /**\n     * Registers a new component with the Eleva instance.\n     * The component will be available for mounting using its registered name.\n     *\n     * @public\n     * @param {string} name - The unique name of the component to register.\n     * @param {ComponentDefinition} definition - The component definition including setup, template, style, and children.\n     * @returns {Eleva} The Eleva instance (for method chaining).\n     * @throws {Error} If name is not a non-empty string or definition has no template.\n     * @see mount - Mount this component to the DOM.\n     * @example\n     * app.component(\"myButton\", {\n     *   template: (ctx) => `<button>${ctx.props.text}</button>`,\n     *   style: `button { color: blue; }`\n     * });\n     */\n    public component(name: string, definition: ComponentDefinition): Eleva;\n    /**\n     * Mounts a registered component to a DOM element.\n     * This will initialize the component, set up its reactive state, and render it to the DOM.\n     * If the container already has a mounted Eleva instance, it is returned as-is.\n     * Unmount clears the container contents and removes the internal instance marker.\n     *\n     * @public\n     * @async\n     * @param {HTMLElement} container - The DOM element where the component will be mounted.\n     * @param {string | ComponentDefinition} compName - The name of the registered component or a direct component definition.\n     * @param {ComponentProps} [props={}] - Optional properties to pass to the component.\n     * @returns {Promise<MountResult>}\n     *          A Promise that resolves to an object containing:\n     *          - container: The mounted component's container element\n     *          - data: The component's reactive state and context\n     *          - unmount: Function to clean up and unmount the component\n     * @throws {Error} If container is not a DOM element or component is not registered.\n     * @throws {Error} If setup function, template function, or style function throws.\n     * @example\n     * const instance = await app.mount(document.getElementById(\"app\"), \"myComponent\", { text: \"Click me\" });\n     * // Later...\n     * await instance.unmount();\n     */\n    public mount(container: HTMLElement, compName: string | ComponentDefinition, props?: ComponentProps): Promise<MountResult>;\n    /**\n     * Processes DOM elements for event binding based on attributes starting with \"@\".\n     * This method attaches event listeners directly to elements and ensures proper cleanup.\n     * Bound `@event` attributes are removed after listeners are attached.\n     *\n     * Handler resolution order:\n     * 1. Direct context property lookup (e.g., context[\"handleClick\"])\n     * 2. Template expression evaluation via TemplateEngine (e.g., \"increment()\")\n     *\n     * @private\n     * @param {HTMLElement} container - The container element in which to search for event attributes.\n     * @param {ComponentContext & SetupResult} context - The merged component context and setup data.\n     * @param {UnsubscribeFunction[]} listeners - Array to collect cleanup functions for each event listener.\n     * @returns {void}\n     * @see TemplateEngine.evaluate - Expression evaluation. fallback.\n     */\n    private _processEvents;\n    /**\n     * Injects styles into the component's container.\n     * Styles are placed in a `<style>` element with a `data-e-style` attribute for identification.\n     *\n     * @note Styles are not automatically scoped - use unique class names or CSS nesting for isolation.\n     *\n     * Optimization: Skips DOM update if style content hasn't changed.\n     *\n     * @private\n     * @param {HTMLElement} container - The container element where styles should be injected.\n     * @param {string} compId - The component ID used to identify the style element.\n     * @param {StyleFunction | string} styleDef - The component's style definition (function or string).\n     * @param {ComponentContext & SetupResult} context - The merged component context and setup data.\n     * @returns {void}\n     */\n    private _injectStyles;\n    /**\n     * Extracts and evaluates props from an element's attributes that start with `:`.\n     * Prop values are evaluated as expressions against the component context,\n     * allowing direct passing of objects, arrays, and other complex types.\n     * Processed attributes are removed from the element after extraction.\n     *\n     * @private\n     * @param {HTMLElement} element - The DOM element to extract props from.\n     * @param {ComponentContext & SetupResult} context - The merged component context and setup data.\n     * @returns {ComponentProps} An object containing the evaluated props.\n     * @see TemplateEngine.evaluate - Expression evaluation.\n     * @example\n     * // For an element with attributes:\n     * // <div :name=\"user.name\" :data=\"items\">\n     * // With context: { user: { name: \"John\" }, items: [1, 2, 3] }\n     * // Returns: { name: \"John\", data: [1, 2, 3] }\n     */\n    private _extractProps;\n    /**\n     * Mounts all components within the parent component's container.\n     * This method handles mounting of explicitly defined children components.\n     *\n     * The mounting process follows these steps:\n     * 1. Finds matching DOM nodes within the container\n     * 2. Mounts explicitly defined children components\n     *\n     * @private\n     * @async\n     * @param {HTMLElement} container - The container element to mount components in.\n     * @param {ChildrenMap} children - Map of selectors to component definitions for explicit children.\n     * @param {MountResult[]} childInstances - Array to store all mounted component instances.\n     * @param {ComponentContext & SetupResult} context - The merged component context and setup data.\n     * @returns {Promise<void>}\n     *\n     * @example\n     * // Explicit children mounting:\n     * const children = {\n     *   'user-profile': UserProfileComponent,\n     *   '#settings-panel': \"settings-panel\"\n     * };\n     */\n    private _mountComponents;\n}\n/**\n * Configuration options for the Eleva instance (reserved for future use).\n */\nexport type ElevaConfig = Record<string, unknown>;\n/**\n * Component definition object.\n */\nexport type ComponentDefinition = {\n    /**\n     * Optional setup function that initializes the component's state and returns reactive data.\n     */\n    setup?: SetupFunction | undefined;\n    /**\n     *           Required function or string that defines the component's HTML structure.\n     */\n    template: TemplateFunction | string;\n    /**\n     * Optional function or string that provides CSS styles for the component.\n     * Styles are preserved across DOM diffs via data-e-style markers.\n     */\n    style?: string | StyleFunction | undefined;\n    /**\n     * Optional object defining nested child components.\n     */\n    children?: ChildrenMap | undefined;\n};\n/**\n * Setup function that initializes component state.\n */\nexport type SetupFunction = (ctx: ComponentContext) => SetupResult | Promise<SetupResult>;\n/**\n * Data returned from setup function, may include lifecycle hooks.\n */\nexport type SetupResult = Record<string, unknown> & LifecycleHooks;\n/**\n * Template function that returns HTML markup.\n */\nexport type TemplateFunction = (ctx: ComponentContext & SetupResult) => string | Promise<string>;\n/**\n * Style function that returns CSS styles.\n */\nexport type StyleFunction = (ctx: ComponentContext & SetupResult) => string;\n/**\n * Map of CSS selectors to component definitions or registered component names.\n */\nexport type ChildrenMap = Record<string, ComponentDefinition | string>;\n/**\n * Context passed to component setup function.\n */\nexport type ComponentContext = {\n    /**\n     *           Component properties passed during mounting.\n     */\n    props: ComponentProps;\n    /**\n     *           Event emitter instance for component event handling.\n     */\n    emitter: Emitter;\n    /**\n     *           Factory function to create reactive Signal instances.\n     */\n    signal: SignalFactory;\n};\n/**\n * Properties passed to a component during mounting.\n */\nexport type ComponentProps = Record<string, unknown>;\n/**\n * Factory function to create reactive Signal instances.\n */\nexport type SignalFactory = <T>(initialValue: T) => Signal<T>;\n/**\n * Lifecycle hooks that can be returned from setup function.\n */\nexport type LifecycleHooks = {\n    /**\n     * Called before component mounting.\n     */\n    onBeforeMount?: LifecycleHook | undefined;\n    /**\n     * Called after component mounting.\n     */\n    onMount?: LifecycleHook | undefined;\n    /**\n     * Called before component update.\n     */\n    onBeforeUpdate?: LifecycleHook | undefined;\n    /**\n     * Called after component update.\n     */\n    onUpdate?: LifecycleHook | undefined;\n    /**\n     * Called during component unmounting.\n     */\n    onUnmount?: UnmountHook | undefined;\n};\n/**\n * Lifecycle hook function.\n */\nexport type LifecycleHook = (ctx: LifecycleHookContext) => void | Promise<void>;\n/**\n * Unmount hook function with cleanup resources.\n */\nexport type UnmountHook = (ctx: UnmountHookContext) => void | Promise<void>;\n/**\n * Context passed to lifecycle hooks.\n */\nexport type LifecycleHookContext = {\n    /**\n     *           The DOM element where the component is mounted.\n     */\n    container: HTMLElement;\n    /**\n     *           The component's reactive state and context data.\n     */\n    context: ComponentContext & SetupResult;\n};\n/**\n * Context passed to unmount hook with cleanup resources.\n */\nexport type UnmountHookContext = {\n    /**\n     *           The DOM element where the component is mounted.\n     */\n    container: HTMLElement;\n    /**\n     *           The component's reactive state and context data.\n     */\n    context: ComponentContext & SetupResult;\n    /**\n     *           Object containing cleanup functions and instances.\n     */\n    cleanup: CleanupResources;\n};\n/**\n * Resources available for cleanup during unmount.\n */\nexport type CleanupResources = {\n    /**\n     *           Signal watcher cleanup functions.\n     */\n    watchers: UnsubscribeFunction[];\n    /**\n     *           Event listener cleanup functions.\n     */\n    listeners: UnsubscribeFunction[];\n    /**\n     *           Child component instances.\n     */\n    children: MountResult[];\n};\n/**\n * Result of mounting a component.\n */\nexport type MountResult = {\n    /**\n     *           The DOM element where the component is mounted.\n     */\n    container: HTMLElement;\n    /**\n     *           The component's reactive state and context data.\n     */\n    data: ComponentContext & SetupResult;\n    /**\n     *           Function to clean up and unmount the component.\n     */\n    unmount: UnmountFunction;\n};\n/**\n * Function to unmount a component and clean up resources.\n */\nexport type UnmountFunction = () => Promise<void>;\n/**\n * Function to unsubscribe from events or watchers.\n */\nexport type UnsubscribeFunction = () => void | boolean;\n/**\n * Plugin interface for extending Eleva.\n */\nexport type ElevaPlugin = {\n    /**\n     *           Unique identifier name for the plugin.\n     */\n    name: string;\n    /**\n     * Optional version string for the plugin.\n     */\n    version?: string | undefined;\n    /**\n     *           Function that installs the plugin.\n     */\n    install: PluginInstallFunction;\n    /**\n     * Optional function to uninstall the plugin.\n     */\n    uninstall?: PluginUninstallFunction | undefined;\n};\n/**\n * Plugin install function.\n */\nexport type PluginInstallFunction = (eleva: Eleva, options?: PluginOptions | undefined) => void | Eleva | unknown;\n/**\n * Plugin uninstall function.\n */\nexport type PluginUninstallFunction = (eleva: Eleva) => void | Promise<void>;\n/**\n * Configuration options passed to a plugin during installation.\n */\nexport type PluginOptions = Record<string, unknown>;\n/**\n * Handler function for DOM events (e.g., click, input, submit).\n */\nexport type DOMEventHandler = (event: Event) => void;\n/**\n * Common DOM event names (prefixed with @ in templates).\n */\nexport type DOMEventName = \"click\" | \"submit\" | \"input\" | \"change\" | \"focus\" | \"blur\" | \"keydown\" | \"keyup\" | \"keypress\" | \"mouseenter\" | \"mouseleave\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"touchstart\" | \"touchend\" | \"touchmove\" | \"scroll\" | \"resize\" | \"load\" | \"error\" | string;\nimport { Emitter } from \"../modules/Emitter.js\";\nimport { Signal } from \"../modules/Signal.js\";\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\nimport { Renderer } from \"../modules/Renderer.js\";\n//# sourceMappingURL=Eleva.d.ts.map","export * from \"./core/Eleva.js\";\nexport { Emitter } from \"./modules/Emitter.js\";\nexport { Signal } from \"./modules/Signal.js\";\nexport { TemplateEngine } from \"./modules/TemplateEngine.js\";\nexport { Renderer } from \"./modules/Renderer.js\";\nexport default Eleva;\nimport { Eleva } from \"./core/Eleva.js\";\n//# sourceMappingURL=index.d.ts.map"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAA,OAAA,YAAA,WAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAA,YAAA,GAAA,gBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAA,YAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,KAAA,YAAA,8BAAA,OAAA;AACP;AACA;AACA;AACO,KAAA,gBAAA;AAKP;AACA;AACA;AACO,KAAA,WAAA;AACP;AACA;AACA;AACA,iCAAA,YAAA,KAAA,gBAAA;AACA;AACA;AACA;AACA,mCAAA,YAAA;AACA;AACA;AACA;AACA;AACA;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAA,MAAA,eAAA,UAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAA,aAAA,MAAA,iBAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,KAAA,aAAA;AACP;AACA;AACA;AACO,KAAA,iBAAA;AACP;AACA;AACA;AACO,KAAA,UAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAA,aAAA,QAAA,iBAAA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAA,cAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAA,UAAA,kBAAA,WAAA,GAAA,gBAAA;AACA;AACA;AACA;AACA;AACO,KAAA,WAAA,GAAA,MAAA;AACP;AACA;AACA;AACO,KAAA,UAAA;AACP;AACA;AACA;AACO,KAAA,gBAAA;;AC1IP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAA,QAAA,YAAA,YAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAAA,WAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACO,KAAA,YAAA;AACP;AACA;AACA;AACA,qBAAA,WAAA;AACA;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAA,KAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAA,WAAA;AACA;AACA;AACA;AACA,4BAAA,WAAA;AACA;AACA,6BAAA,OAAA;AACA;AACA,mCAAA,MAAA;AACA;AACA,2CAAA,cAAA;AACA;AACA,8BAAA,QAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAA,WAAA,YAAA,aAAA,GAAA,KAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAAA,mBAAA,GAAA,KAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAAA,WAAA,qBAAA,mBAAA,UAAA,cAAA,GAAA,OAAA,CAAA,WAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,KAAA,WAAA,GAAA,MAAA;AACP;AACA;AACA;AACO,KAAA,mBAAA;AACP;AACA;AACA;AACA,YAAA,aAAA;AACA;AACA;AACA;AACA,cAAA,gBAAA;AACA;AACA;AACA;AACA;AACA,qBAAA,aAAA;AACA;AACA;AACA;AACA,eAAA,WAAA;AACA;AACA;AACA;AACA;AACO,KAAA,aAAA,SAAA,gBAAA,KAAA,WAAA,GAAA,OAAA,CAAA,WAAA;AACP;AACA;AACA;AACO,KAAA,WAAA,GAAA,MAAA,oBAAA,cAAA;AACP;AACA;AACA;AACO,KAAA,gBAAA,SAAA,gBAAA,GAAA,WAAA,cAAA,OAAA;AACP;AACA;AACA;AACO,KAAA,aAAA,SAAA,gBAAA,GAAA,WAAA;AACP;AACA;AACA;AACO,KAAA,WAAA,GAAA,MAAA,SAAA,mBAAA;AACP;AACA;AACA;AACO,KAAA,gBAAA;AACP;AACA;AACA;AACA,WAAA,cAAA;AACA;AACA;AACA;AACA,aAAA,OAAA;AACA;AACA;AACA;AACA,YAAA,aAAA;AACA;AACA;AACA;AACA;AACO,KAAA,cAAA,GAAA,MAAA;AACP;AACA;AACA;AACO,KAAA,aAAA,2BAAA,MAAA;AACP;AACA;AACA;AACO,KAAA,cAAA;AACP;AACA;AACA;AACA,oBAAA,aAAA;AACA;AACA;AACA;AACA,cAAA,aAAA;AACA;AACA;AACA;AACA,qBAAA,aAAA;AACA;AACA;AACA;AACA,eAAA,aAAA;AACA;AACA;AACA;AACA,gBAAA,WAAA;AACA;AACA;AACA;AACA;AACO,KAAA,aAAA,SAAA,oBAAA,YAAA,OAAA;AACP;AACA;AACA;AACO,KAAA,WAAA,SAAA,kBAAA,YAAA,OAAA;AACP;AACA;AACA;AACO,KAAA,oBAAA;AACP;AACA;AACA;AACA,eAAA,WAAA;AACA;AACA;AACA;AACA,aAAA,gBAAA,GAAA,WAAA;AACA;AACA;AACA;AACA;AACO,KAAA,kBAAA;AACP;AACA;AACA;AACA,eAAA,WAAA;AACA;AACA;AACA;AACA,aAAA,gBAAA,GAAA,WAAA;AACA;AACA;AACA;AACA,aAAA,gBAAA;AACA;AACA;AACA;AACA;AACO,KAAA,gBAAA;AACP;AACA;AACA;AACA,cAAA,mBAAA;AACA;AACA;AACA;AACA,eAAA,mBAAA;AACA;AACA;AACA;AACA,cAAA,WAAA;AACA;AACA;AACA;AACA;AACO,KAAA,WAAA;AACP;AACA;AACA;AACA,eAAA,WAAA;AACA;AACA;AACA;AACA,UAAA,gBAAA,GAAA,WAAA;AACA;AACA;AACA;AACA,aAAA,eAAA;AACA;AACA;AACA;AACA;AACO,KAAA,eAAA,SAAA,OAAA;AACP;AACA;AACA;AACO,KAAA,mBAAA;AACP;AACA;AACA;AACO,KAAA,WAAA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,qBAAA;AACA;AACA;AACA;AACA,gBAAA,uBAAA;AACA;AACA;AACA;AACA;AACO,KAAA,qBAAA,WAAA,KAAA,YAAA,aAAA,wBAAA,KAAA;AACP;AACA;AACA;AACO,KAAA,uBAAA,WAAA,KAAA,YAAA,OAAA;AACP;AACA;AACA;AACO,KAAA,aAAA,GAAA,MAAA;AACP;AACA;AACA;AACO,KAAA,eAAA,WAAA,KAAA;AACP;AACA;AACA;AACO,KAAA,YAAA;;AC9lBP;;;;"}
{"version":3,"file":"router.umd.min.js","sources":["../../src/plugins/Router.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {import('eleva').Eleva} Eleva\n * @typedef {import('eleva').Signal} Signal\n * @typedef {import('eleva').ComponentDefinition} ComponentDefinition\n */\n\n/**\n * Simple error handler for the core router.\n * Can be overridden by error handling plugins.\n * Provides consistent error formatting and logging for router operations.\n * @private\n */\nconst CoreErrorHandler = {\n  /**\n   * Handles router errors with basic formatting.\n   * @param {Error} error - The error to handle.\n   * @param {string} context - The context where the error occurred.\n   * @param {Object} details - Additional error details.\n   * @throws {Error} The formatted error.\n   */\n  handle(error, context, details = {}) {\n    const message = `[ElevaRouter] ${context}: ${error.message}`;\n    const formattedError = new Error(message);\n\n    // Preserve original error details\n    formattedError.originalError = error;\n    formattedError.context = context;\n    formattedError.details = details;\n\n    console.error(message, { error, context, details });\n    throw formattedError;\n  },\n\n  /**\n   * Logs a warning without throwing an error.\n   * @param {string} message - The warning message.\n   * @param {Object} details - Additional warning details.\n   */\n  warn(message, details = {}) {\n    console.warn(`[ElevaRouter] ${message}`, details);\n  },\n\n  /**\n   * Logs an error without throwing.\n   * @param {string} message - The error message.\n   * @param {Error} error - The original error.\n   * @param {Object} details - Additional error details.\n   */\n  log(message, error, details = {}) {\n    console.error(`[ElevaRouter] ${message}`, { error, details });\n  },\n};\n\n/**\n * @typedef {Object} RouteLocation\n * @property {string} path - The path of the route (e.g., '/users/123').\n * @property {Object<string, string>} query - An object representing the query parameters.\n * @property {string} fullUrl - The complete URL including hash, path, and query string.\n * @property {Object<string, string>} params - An object containing dynamic route parameters.\n * @property {Object<string, any>} meta - The meta object associated with the matched route.\n * @property {string} [name] - The optional name of the matched route.\n * @property {RouteDefinition} matched - The raw route definition object that was matched.\n */\n\n/**\n * @typedef {(to: RouteLocation, from: RouteLocation | null) => boolean | string | {path: string} | void | Promise<boolean | string | {path: string} | void>} NavigationGuard\n * A function that acts as a guard for navigation. It runs *before* the navigation is confirmed.\n * It can return:\n * - `true` or `undefined`: to allow navigation.\n * - `false`: to abort the navigation.\n * - a `string` (path) or a `location object`: to redirect to a new route.\n */\n\n/**\n * @typedef {(...args: any[]) => void | Promise<void>} NavigationHook\n * A function that acts as a lifecycle hook, typically for side effects. It does not affect navigation flow.\n */\n\n/**\n * @typedef {Object} RouterPlugin\n * @property {string} name - The plugin name.\n * @property {string} [version] - The plugin version.\n * @property {Function} install - The install function that receives the router instance.\n * @property {Function} [destroy] - Optional cleanup function called when the router is destroyed.\n */\n\n/**\n * @typedef {Object} RouteDefinition\n * @property {string} path - The URL path pattern (e.g., '/', '/about', '/users/:id', '*').\n * @property {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} component - The component to render. Can be a registered name, a definition object, or an async import function.\n * @property {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} [layout] - An optional layout component to wrap the route's component.\n * @property {string} [name] - An optional name for the route.\n * @property {Object<string, any>} [meta] - Optional metadata for the route (e.g., for titles, auth flags).\n * @property {NavigationGuard} [beforeEnter] - A route-specific guard executed before entering the route.\n * @property {NavigationHook} [afterEnter] - A hook executed *after* the route has been entered and the new component is mounted.\n * @property {NavigationGuard} [beforeLeave] - A guard executed *before* leaving the current route.\n * @property {NavigationHook} [afterLeave] - A hook executed *after* leaving the current route and its component has been unmounted.\n */\n\n/**\n * @class Router\n * @classdesc A powerful, reactive, and flexible Router Plugin for Eleva.js.\n * This class manages all routing logic, including state, navigation, and rendering.\n * @private\n */\nclass Router {\n  /**\n   * Creates an instance of the Router.\n   * @param {Eleva} eleva - The Eleva framework instance.\n   * @param {RouterOptions} options - The configuration options for the router.\n   */\n  constructor(eleva, options = {}) {\n    /** @type {Eleva} The Eleva framework instance. */\n    this.eleva = eleva;\n\n    /** @type {RouterOptions} The merged router options. */\n    this.options = {\n      mode: \"hash\",\n      queryParam: \"view\",\n      viewSelector: \"root\",\n      ...options,\n    };\n\n    /** @private @type {RouteDefinition[]} The processed list of route definitions. */\n    this.routes = this._processRoutes(options.routes || []);\n\n    /** @private @type {import('eleva').Emitter} The shared Eleva event emitter for global hooks. */\n    this.emitter = this.eleva.emitter;\n\n    /** @private @type {boolean} A flag indicating if the router has been started. */\n    this.isStarted = false;\n\n    /** @private @type {boolean} A flag to prevent navigation loops from history events. */\n    this._isNavigating = false;\n\n    /** @private @type {Array<() => void>} A collection of cleanup functions for event listeners. */\n    this.eventListeners = [];\n\n    /** @type {Signal<RouteLocation | null>} A reactive signal holding the current route's information. */\n    this.currentRoute = new this.eleva.signal(null);\n\n    /** @type {Signal<RouteLocation | null>} A reactive signal holding the previous route's information. */\n    this.previousRoute = new this.eleva.signal(null);\n\n    /** @type {Signal<Object<string, string>>} A reactive signal holding the current route's parameters. */\n    this.currentParams = new this.eleva.signal({});\n\n    /** @type {Signal<Object<string, string>>} A reactive signal holding the current route's query parameters. */\n    this.currentQuery = new this.eleva.signal({});\n\n    /** @type {Signal<import('eleva').MountResult | null>} A reactive signal for the currently mounted layout instance. */\n    this.currentLayout = new this.eleva.signal(null);\n\n    /** @type {Signal<import('eleva').MountResult | null>} A reactive signal for the currently mounted view (page) instance. */\n    this.currentView = new this.eleva.signal(null);\n\n    /** @private @type {Map<string, RouterPlugin>} Map of registered plugins by name. */\n    this.plugins = new Map();\n\n    /** @type {Object} The error handler instance. Can be overridden by plugins. */\n    this.errorHandler = CoreErrorHandler;\n\n    this._validateOptions();\n  }\n\n  /**\n   * Validates the provided router options.\n   * @private\n   * @throws {Error} If the routing mode is invalid.\n   */\n  _validateOptions() {\n    if (![\"hash\", \"query\", \"history\"].includes(this.options.mode)) {\n      this.errorHandler.handle(\n        new Error(\n          `Invalid routing mode: ${this.options.mode}. Must be \"hash\", \"query\", or \"history\".`\n        ),\n        \"Configuration validation failed\"\n      );\n    }\n  }\n\n  /**\n   * Pre-processes route definitions to parse their path segments for efficient matching.\n   * @private\n   * @param {RouteDefinition[]} routes - The raw route definitions.\n   * @returns {RouteDefinition[]} The processed routes.\n   */\n  _processRoutes(routes) {\n    const processedRoutes = [];\n    for (const route of routes) {\n      try {\n        processedRoutes.push({\n          ...route,\n          segments: this._parsePathIntoSegments(route.path),\n        });\n      } catch (error) {\n        this.errorHandler.warn(\n          `Invalid path in route definition \"${route.path || \"undefined\"}\": ${error.message}`,\n          { route, error }\n        );\n      }\n    }\n    return processedRoutes;\n  }\n\n  /**\n   * Parses a route path string into an array of static and parameter segments.\n   * @private\n   * @param {string} path - The path pattern to parse.\n   * @returns {Array<{type: 'static' | 'param', value?: string, name?: string}>} An array of segment objects.\n   * @throws {Error} If the route path is not a valid string.\n   */\n  _parsePathIntoSegments(path) {\n    if (!path || typeof path !== \"string\") {\n      this.errorHandler.handle(\n        new Error(\"Route path must be a non-empty string\"),\n        \"Path parsing failed\",\n        { path }\n      );\n    }\n\n    const normalizedPath = path.replace(/\\/+/g, \"/\").replace(/\\/$/, \"\") || \"/\";\n\n    if (normalizedPath === \"/\") {\n      return [];\n    }\n\n    return normalizedPath\n      .split(\"/\")\n      .filter(Boolean)\n      .map((segment) => {\n        if (segment.startsWith(\":\")) {\n          const paramName = segment.substring(1);\n          if (!paramName) {\n            this.errorHandler.handle(\n              new Error(`Invalid parameter segment: ${segment}`),\n              \"Path parsing failed\",\n              { segment, path }\n            );\n          }\n          return { type: \"param\", name: paramName };\n        }\n        return { type: \"static\", value: segment };\n      });\n  }\n\n  /**\n   * Finds the view element within a container using multiple selector strategies.\n   * @private\n   * @param {HTMLElement} container - The parent element to search within.\n   * @returns {HTMLElement} The found view element or the container itself as a fallback.\n   */\n  _findViewElement(container) {\n    const selector = this.options.viewSelector;\n    return (\n      container.querySelector(`#${selector}`) ||\n      container.querySelector(`.${selector}`) ||\n      container.querySelector(`[data-${selector}]`) ||\n      container.querySelector(selector) ||\n      container\n    );\n  }\n\n  /**\n   * Starts the router, initializes event listeners, and performs the initial navigation.\n   * @returns {Promise<void>}\n   */\n  async start() {\n    if (this.isStarted) {\n      this.errorHandler.warn(\"Router is already started\");\n      return;\n    }\n    if (typeof window === \"undefined\") {\n      this.errorHandler.warn(\n        \"Router start skipped: `window` object not available (SSR environment)\"\n      );\n      return;\n    }\n    if (\n      typeof document !== \"undefined\" &&\n      !document.querySelector(this.options.mount)\n    ) {\n      this.errorHandler.warn(\n        `Mount element \"${this.options.mount}\" was not found in the DOM. The router will not start.`,\n        { mountSelector: this.options.mount }\n      );\n      return;\n    }\n    const handler = () => this._handleRouteChange();\n    if (this.options.mode === \"hash\") {\n      window.addEventListener(\"hashchange\", handler);\n      this.eventListeners.push(() =>\n        window.removeEventListener(\"hashchange\", handler)\n      );\n    } else {\n      window.addEventListener(\"popstate\", handler);\n      this.eventListeners.push(() =>\n        window.removeEventListener(\"popstate\", handler)\n      );\n    }\n    this.isStarted = true;\n    await this._handleRouteChange();\n  }\n\n  /**\n   * Stops the router and cleans up all event listeners and mounted components.\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    if (!this.isStarted) return;\n\n    // Clean up plugins\n    for (const plugin of this.plugins.values()) {\n      if (typeof plugin.destroy === \"function\") {\n        try {\n          await plugin.destroy(this);\n        } catch (error) {\n          this.errorHandler.log(`Plugin ${plugin.name} destroy failed`, error);\n        }\n      }\n    }\n\n    this.eventListeners.forEach((cleanup) => cleanup());\n    this.eventListeners = [];\n    if (this.currentLayout.value) {\n      await this.currentLayout.value.unmount();\n    }\n    this.isStarted = false;\n  }\n\n  /**\n   * Programmatically navigates to a new route.\n   * @param {string | {path: string, query?: object, params?: object, replace?: boolean, state?: object}} location - The target location as a string or object.\n   * @param {object} [params] - Optional route parameters (for string-based location).\n   * @returns {Promise<void>}\n   */\n  async navigate(location, params = {}) {\n    try {\n      const target =\n        typeof location === \"string\" ? { path: location, params } : location;\n      let path = this._buildPath(target.path, target.params || {});\n      const query = target.query || {};\n\n      if (Object.keys(query).length > 0) {\n        const queryString = new URLSearchParams(query).toString();\n        if (queryString) path += `?${queryString}`;\n      }\n\n      if (this._isSameRoute(path, target.params, query)) {\n        return;\n      }\n\n      const navigationSuccessful = await this._proceedWithNavigation(path);\n\n      if (navigationSuccessful) {\n        this._isNavigating = true;\n        const state = target.state || {};\n        const replace = target.replace || false;\n        const historyMethod = replace ? \"replaceState\" : \"pushState\";\n\n        if (this.options.mode === \"hash\") {\n          if (replace) {\n            const newUrl = `${window.location.pathname}${window.location.search}#${path}`;\n            window.history.replaceState(state, \"\", newUrl);\n          } else {\n            window.location.hash = path;\n          }\n        } else {\n          const url =\n            this.options.mode === \"query\" ? this._buildQueryUrl(path) : path;\n          history[historyMethod](state, \"\", url);\n        }\n        queueMicrotask(() => {\n          this._isNavigating = false;\n        });\n      }\n    } catch (error) {\n      this.errorHandler.log(\"Navigation failed\", error);\n      await this.emitter.emit(\"router:onError\", error);\n    }\n  }\n\n  /**\n   * Builds a URL for query mode.\n   * @private\n   * @param {string} path - The path to set as the query parameter.\n   * @returns {string} The full URL with the updated query string.\n   */\n  _buildQueryUrl(path) {\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set(this.options.queryParam, path.split(\"?\")[0]);\n    return `${window.location.pathname}?${urlParams.toString()}`;\n  }\n\n  /**\n   * Checks if the target route is identical to the current route.\n   * @private\n   * @param {string} path - The target path with query string.\n   * @param {object} params - The target params.\n   * @param {object} query - The target query.\n   * @returns {boolean} - True if the routes are the same.\n   */\n  _isSameRoute(path, params, query) {\n    const current = this.currentRoute.value;\n    if (!current) return false;\n    const [targetPath, queryString] = path.split(\"?\");\n    const targetQuery = query || this._parseQuery(queryString || \"\");\n    return (\n      current.path === targetPath &&\n      JSON.stringify(current.params) === JSON.stringify(params || {}) &&\n      JSON.stringify(current.query) === JSON.stringify(targetQuery)\n    );\n  }\n\n  /**\n   * Injects dynamic parameters into a path string.\n   * @private\n   */\n  _buildPath(path, params) {\n    let result = path;\n    for (const [key, value] of Object.entries(params)) {\n      // Fix: Handle special characters and ensure proper encoding\n      const encodedValue = encodeURIComponent(String(value));\n      result = result.replace(new RegExp(`:${key}\\\\b`, \"g\"), encodedValue);\n    }\n    return result;\n  }\n\n  /**\n   * The handler for browser-initiated route changes (e.g., back/forward buttons).\n   * @private\n   */\n  async _handleRouteChange() {\n    if (this._isNavigating) return;\n    const from = this.currentRoute.value;\n    const toLocation = this._getCurrentLocation();\n\n    const navigationSuccessful = await this._proceedWithNavigation(\n      toLocation.fullUrl\n    );\n\n    // If navigation was blocked by a guard, revert the URL change\n    if (!navigationSuccessful && from) {\n      this.navigate({ path: from.path, query: from.query, replace: true });\n    }\n  }\n\n  /**\n   * Manages the core navigation lifecycle. Runs guards before committing changes.\n   * @private\n   * @param {string} fullPath - The full path (e.g., '/users/123?foo=bar') to navigate to.\n   * @returns {Promise<boolean>} - `true` if navigation succeeded, `false` if aborted.\n   */\n  async _proceedWithNavigation(fullPath) {\n    const from = this.currentRoute.value;\n    const [path, queryString] = (fullPath || \"/\").split(\"?\");\n    const toLocation = {\n      path: path.startsWith(\"/\") ? path : `/${path}`,\n      query: this._parseQuery(queryString),\n      fullUrl: fullPath,\n    };\n\n    let toMatch = this._matchRoute(toLocation.path);\n\n    if (!toMatch) {\n      const notFoundRoute = this.routes.find((route) => route.path === \"*\");\n      if (notFoundRoute) {\n        toMatch = {\n          route: notFoundRoute,\n          params: { pathMatch: toLocation.path.substring(1) },\n        };\n      } else {\n        await this.emitter.emit(\n          \"router:onError\",\n          new Error(`Route not found: ${toLocation.path}`),\n          toLocation,\n          from\n        );\n        return false;\n      }\n    }\n\n    const to = {\n      ...toLocation,\n      params: toMatch.params,\n      meta: toMatch.route.meta || {},\n      name: toMatch.route.name,\n      matched: toMatch.route,\n    };\n\n    try {\n      // 1. Run all *pre-navigation* guards.\n      const canNavigate = await this._runGuards(to, from, toMatch.route);\n      if (!canNavigate) return false;\n\n      // 2. Resolve async components *before* touching the DOM.\n      const { layoutComponent, pageComponent } = await this._resolveComponents(\n        toMatch.route\n      );\n\n      // 3. Unmount the previous view/layout.\n      if (from) {\n        const toLayout = toMatch.route.layout || this.options.globalLayout;\n        const fromLayout = from.matched.layout || this.options.globalLayout;\n\n        const tryUnmount = async (instance) => {\n          if (!instance) return;\n\n          try {\n            await instance.unmount();\n          } catch (error) {\n            this.errorHandler.warn(\"Error during component unmount\", {\n              error,\n              instance,\n            });\n          }\n        };\n\n        if (toLayout !== fromLayout) {\n          await tryUnmount(this.currentLayout.value);\n          this.currentLayout.value = null;\n        } else {\n          await tryUnmount(this.currentView.value);\n          this.currentView.value = null;\n        }\n\n        // 4. Call `afterLeave` hook *after* the old component has been unmounted.\n        if (from.matched.afterLeave) {\n          await from.matched.afterLeave(to, from);\n          await this.emitter.emit(\"router:afterLeave\", to, from);\n        }\n      }\n\n      // 5. Update reactive state.\n      this.previousRoute.value = from;\n      this.currentRoute.value = to;\n      this.currentParams.value = to.params || {};\n      this.currentQuery.value = to.query || {};\n\n      // 6. Render the new components.\n      await this._render(layoutComponent, pageComponent, to);\n\n      // 7. Run post-navigation hooks.\n      if (toMatch.route.afterEnter) {\n        await toMatch.route.afterEnter(to, from);\n        await this.emitter.emit(\"router:afterEnter\", to, from);\n      }\n      await this.emitter.emit(\"router:afterEach\", to, from);\n\n      return true;\n    } catch (error) {\n      this.errorHandler.log(\"Error during navigation\", error, { to, from });\n      await this.emitter.emit(\"router:onError\", error, to, from);\n      return false;\n    }\n  }\n\n  /**\n   * Executes all applicable navigation guards for a transition in order.\n   * @private\n   * @returns {Promise<boolean>} - `false` if navigation should be aborted.\n   */\n  async _runGuards(to, from, route) {\n    const guards = [\n      ...(this.options.onBeforeEach ? [this.options.onBeforeEach] : []),\n      ...(from && from.matched.beforeLeave ? [from.matched.beforeLeave] : []),\n      ...(route.beforeEnter ? [route.beforeEnter] : []),\n    ];\n    for (const guard of guards) {\n      const result = await guard(to, from);\n      if (result === false) return false;\n      if (typeof result === \"string\" || typeof result === \"object\") {\n        this.navigate(result);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Resolves a string component definition to a component object.\n   * @private\n   * @param {string} def - The component name to resolve.\n   * @returns {ComponentDefinition} The resolved component.\n   * @throws {Error} If the component is not registered.\n   */\n  _resolveStringComponent(def) {\n    const componentDef = this.eleva._components.get(def);\n    if (!componentDef) {\n      this.errorHandler.handle(\n        new Error(`Component \"${def}\" not registered.`),\n        \"Component resolution failed\",\n        {\n          componentName: def,\n          availableComponents: Array.from(this.eleva._components.keys()),\n        }\n      );\n    }\n    return componentDef;\n  }\n\n  /**\n   * Resolves a function component definition to a component object.\n   * @private\n   * @param {Function} def - The function to resolve.\n   * @returns {Promise<ComponentDefinition>} The resolved component.\n   * @throws {Error} If the function fails to load the component.\n   */\n  async _resolveFunctionComponent(def) {\n    try {\n      const funcStr = def.toString();\n      const isAsyncImport =\n        funcStr.includes(\"import(\") || funcStr.startsWith(\"() =>\");\n\n      const result = await def();\n      return isAsyncImport ? result.default || result : result;\n    } catch (error) {\n      this.errorHandler.handle(\n        new Error(`Failed to load async component: ${error.message}`),\n        \"Component resolution failed\",\n        { function: def.toString(), error }\n      );\n    }\n  }\n\n  /**\n   * Validates a component definition object.\n   * @private\n   * @param {any} def - The component definition to validate.\n   * @returns {ComponentDefinition} The validated component.\n   * @throws {Error} If the component definition is invalid.\n   */\n  _validateComponentDefinition(def) {\n    if (!def || typeof def !== \"object\") {\n      this.errorHandler.handle(\n        new Error(`Invalid component definition: ${typeof def}`),\n        \"Component validation failed\",\n        { definition: def }\n      );\n    }\n\n    if (\n      typeof def.template !== \"function\" &&\n      typeof def.template !== \"string\"\n    ) {\n      this.errorHandler.handle(\n        new Error(\"Component missing template property\"),\n        \"Component validation failed\",\n        { definition: def }\n      );\n    }\n\n    return def;\n  }\n\n  /**\n   * Resolves a component definition to a component object.\n   * @private\n   * @param {any} def - The component definition to resolve.\n   * @returns {Promise<ComponentDefinition | null>} The resolved component or null.\n   */\n  async _resolveComponent(def) {\n    if (def === null || def === undefined) {\n      return null;\n    }\n\n    if (typeof def === \"string\") {\n      return this._resolveStringComponent(def);\n    }\n\n    if (typeof def === \"function\") {\n      return await this._resolveFunctionComponent(def);\n    }\n\n    if (def && typeof def === \"object\") {\n      return this._validateComponentDefinition(def);\n    }\n\n    this.errorHandler.handle(\n      new Error(`Invalid component definition: ${typeof def}`),\n      \"Component resolution failed\",\n      { definition: def }\n    );\n  }\n\n  /**\n   * Asynchronously resolves the layout and page components for a route.\n   * @private\n   * @param {RouteDefinition} route - The route to resolve components for.\n   * @returns {Promise<{layoutComponent: ComponentDefinition | null, pageComponent: ComponentDefinition}>}\n   */\n  async _resolveComponents(route) {\n    const effectiveLayout = route.layout || this.options.globalLayout;\n\n    try {\n      const [layoutComponent, pageComponent] = await Promise.all([\n        this._resolveComponent(effectiveLayout),\n        this._resolveComponent(route.component),\n      ]);\n\n      if (!pageComponent) {\n        this.errorHandler.handle(\n          new Error(\n            `Page component is null or undefined for route: ${route.path}`\n          ),\n          \"Component resolution failed\",\n          { route: route.path }\n        );\n      }\n\n      return { layoutComponent, pageComponent };\n    } catch (error) {\n      this.errorHandler.log(\n        `Error resolving components for route ${route.path}`,\n        error,\n        { route: route.path }\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Renders the components for the current route into the DOM.\n   * @private\n   * @param {ComponentDefinition | null} layoutComponent - The pre-loaded layout component.\n   * @param {ComponentDefinition} pageComponent - The pre-loaded page component.\n   */\n  async _render(layoutComponent, pageComponent) {\n    const mountEl = document.querySelector(this.options.mount);\n    if (!mountEl) {\n      this.errorHandler.handle(\n        new Error(`Mount element \"${this.options.mount}\" not found.`),\n        { mountSelector: this.options.mount }\n      );\n    }\n\n    if (layoutComponent) {\n      const layoutInstance = await this.eleva.mount(\n        mountEl,\n        this._wrapComponentWithChildren(layoutComponent)\n      );\n      this.currentLayout.value = layoutInstance;\n      const viewEl = this._findViewElement(layoutInstance.container);\n      const viewInstance = await this.eleva.mount(\n        viewEl,\n        this._wrapComponentWithChildren(pageComponent)\n      );\n      this.currentView.value = viewInstance;\n    } else {\n      const viewInstance = await this.eleva.mount(\n        mountEl,\n        this._wrapComponentWithChildren(pageComponent)\n      );\n      this.currentView.value = viewInstance;\n      this.currentLayout.value = null;\n    }\n  }\n\n  /**\n   * Creates a getter function for router context properties.\n   * @private\n   * @param {string} property - The property name to access.\n   * @param {any} defaultValue - The default value if property is undefined.\n   * @returns {Function} A getter function.\n   */\n  _createRouteGetter(property, defaultValue) {\n    return () => this.currentRoute.value?.[property] ?? defaultValue;\n  }\n\n  /**\n   * Wraps a component definition to inject router-specific context into its setup function.\n   * @private\n   * @param {ComponentDefinition} component - The component to wrap.\n   * @returns {ComponentDefinition} The wrapped component definition.\n   */\n  _wrapComponent(component) {\n    const originalSetup = component.setup;\n    const self = this;\n\n    return {\n      ...component,\n      async setup(ctx) {\n        ctx.router = {\n          navigate: self.navigate.bind(self),\n          current: self.currentRoute,\n          previous: self.previousRoute,\n\n          // Route property getters\n          get params() {\n            return self._createRouteGetter(\"params\", {})();\n          },\n          get query() {\n            return self._createRouteGetter(\"query\", {})();\n          },\n          get path() {\n            return self._createRouteGetter(\"path\", \"/\")();\n          },\n          get fullUrl() {\n            return self._createRouteGetter(\"fullUrl\", window.location.href)();\n          },\n          get meta() {\n            return self._createRouteGetter(\"meta\", {})();\n          },\n        };\n\n        return originalSetup ? await originalSetup(ctx) : {};\n      },\n    };\n  }\n\n  /**\n   * Recursively wraps all child components to ensure they have access to router context.\n   * @private\n   * @param {ComponentDefinition} component - The component to wrap.\n   * @returns {ComponentDefinition} The wrapped component definition.\n   */\n  _wrapComponentWithChildren(component) {\n    const wrappedComponent = this._wrapComponent(component);\n\n    // If the component has children, wrap them too\n    if (\n      wrappedComponent.children &&\n      typeof wrappedComponent.children === \"object\"\n    ) {\n      const wrappedChildren = {};\n      for (const [selector, childComponent] of Object.entries(\n        wrappedComponent.children\n      )) {\n        wrappedChildren[selector] =\n          this._wrapComponentWithChildren(childComponent);\n      }\n      wrappedComponent.children = wrappedChildren;\n    }\n\n    return wrappedComponent;\n  }\n\n  /**\n   * Gets the current location information from the browser's window object.\n   * @private\n   * @returns {Omit<RouteLocation, 'params' | 'meta' | 'name' | 'matched'>}\n   */\n  _getCurrentLocation() {\n    if (typeof window === \"undefined\")\n      return { path: \"/\", query: {}, fullUrl: \"\" };\n    let path, queryString, fullUrl;\n    switch (this.options.mode) {\n      case \"hash\":\n        fullUrl = window.location.hash.slice(1) || \"/\";\n        [path, queryString] = fullUrl.split(\"?\");\n        break;\n      case \"query\":\n        const urlParams = new URLSearchParams(window.location.search);\n        path = urlParams.get(this.options.queryParam) || \"/\";\n        queryString = window.location.search.slice(1);\n        fullUrl = path;\n        break;\n      default: // 'history' mode\n        path = window.location.pathname || \"/\";\n        queryString = window.location.search.slice(1);\n        fullUrl = `${path}${queryString ? \"?\" + queryString : \"\"}`;\n    }\n    return {\n      path: path.startsWith(\"/\") ? path : `/${path}`,\n      query: this._parseQuery(queryString),\n      fullUrl,\n    };\n  }\n\n  /**\n   * Parses a query string into a key-value object.\n   * @private\n   */\n  _parseQuery(queryString) {\n    const query = {};\n    if (queryString) {\n      new URLSearchParams(queryString).forEach((value, key) => {\n        query[key] = value;\n      });\n    }\n    return query;\n  }\n\n  /**\n   * Matches a given path against the registered routes.\n   * @private\n   * @param {string} path - The path to match.\n   * @returns {{route: RouteDefinition, params: Object<string, string>} | null} The matched route and its params, or null.\n   */\n  _matchRoute(path) {\n    const pathSegments = path.split(\"/\").filter(Boolean);\n\n    for (const route of this.routes) {\n      // Handle the root path as a special case.\n      if (route.path === \"/\") {\n        if (pathSegments.length === 0) return { route, params: {} };\n        continue;\n      }\n\n      if (route.segments.length !== pathSegments.length) continue;\n\n      const params = {};\n      let isMatch = true;\n      for (let i = 0; i < route.segments.length; i++) {\n        const routeSegment = route.segments[i];\n        const pathSegment = pathSegments[i];\n        if (routeSegment.type === \"param\") {\n          params[routeSegment.name] = decodeURIComponent(pathSegment);\n        } else if (routeSegment.value !== pathSegment) {\n          isMatch = false;\n          break;\n        }\n      }\n      if (isMatch) return { route, params };\n    }\n    return null;\n  }\n\n  /** Registers a global pre-navigation guard. */\n  onBeforeEach(guard) {\n    this.options.onBeforeEach = guard;\n  }\n  /** Registers a global hook that runs after a new route component has been mounted *if* the route has an `afterEnter` hook. */\n  onAfterEnter(hook) {\n    this.emitter.on(\"router:afterEnter\", hook);\n  }\n  /** Registers a global hook that runs after a route component has been unmounted *if* the route has an `afterLeave` hook. */\n  onAfterLeave(hook) {\n    this.emitter.on(\"router:afterLeave\", hook);\n  }\n  /** Registers a global hook that runs after a navigation has been confirmed and all hooks have completed. */\n  onAfterEach(hook) {\n    this.emitter.on(\"router:afterEach\", hook);\n  }\n  /** Registers a global error handler for navigation. */\n  onError(handler) {\n    this.emitter.on(\"router:onError\", handler);\n  }\n\n  /**\n   * Registers a plugin with the router.\n   * @param {RouterPlugin} plugin - The plugin to register.\n   */\n  use(plugin, options = {}) {\n    if (typeof plugin.install !== \"function\") {\n      this.errorHandler.handle(\n        new Error(\"Plugin must have an install method\"),\n        \"Plugin registration failed\",\n        { plugin }\n      );\n    }\n\n    // Check if plugin is already registered\n    if (this.plugins.has(plugin.name)) {\n      this.errorHandler.warn(`Plugin \"${plugin.name}\" is already registered`, {\n        existingPlugin: this.plugins.get(plugin.name),\n      });\n      return;\n    }\n\n    this.plugins.set(plugin.name, plugin);\n    plugin.install(this, options);\n  }\n\n  /**\n   * Gets all registered plugins.\n   * @returns {RouterPlugin[]} Array of registered plugins.\n   */\n  getPlugins() {\n    return Array.from(this.plugins.values());\n  }\n\n  /**\n   * Gets a plugin by name.\n   * @param {string} name - The plugin name.\n   * @returns {RouterPlugin | undefined} The plugin or undefined.\n   */\n  getPlugin(name) {\n    return this.plugins.get(name);\n  }\n\n  /**\n   * Removes a plugin from the router.\n   * @param {string} name - The plugin name.\n   * @returns {boolean} True if the plugin was removed.\n   */\n  removePlugin(name) {\n    const plugin = this.plugins.get(name);\n    if (!plugin) return false;\n\n    // Call destroy if available\n    if (typeof plugin.destroy === \"function\") {\n      try {\n        plugin.destroy(this);\n      } catch (error) {\n        this.errorHandler.log(`Plugin ${name} destroy failed`, error);\n      }\n    }\n\n    return this.plugins.delete(name);\n  }\n\n  /**\n   * Sets a custom error handler. Used by error handling plugins.\n   * @param {Object} errorHandler - The error handler object with handle, warn, and log methods.\n   */\n  setErrorHandler(errorHandler) {\n    if (\n      errorHandler &&\n      typeof errorHandler.handle === \"function\" &&\n      typeof errorHandler.warn === \"function\" &&\n      typeof errorHandler.log === \"function\"\n    ) {\n      this.errorHandler = errorHandler;\n    } else {\n      console.warn(\n        \"[ElevaRouter] Invalid error handler provided. Must have handle, warn, and log methods.\"\n      );\n    }\n  }\n}\n\n/**\n * @typedef {Object} RouterOptions\n * @property {string} mount - A CSS selector for the main element where the app is mounted.\n * @property {RouteDefinition[]} routes - An array of route definitions.\n * @property {'hash' | 'query' | 'history'} [mode='hash'] - The routing mode.\n * @property {string} [queryParam='page'] - The query parameter to use in 'query' mode.\n * @property {string} [viewSelector='view'] - The selector for the view element within a layout.\n * @property {boolean} [autoStart=true] - Whether to start the router automatically.\n * @property {NavigationGuard} [onBeforeEach] - A global guard executed before every navigation.\n * @property {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} [globalLayout] - A global layout for all routes. Can be overridden by a route's specific layout.\n */\n\n/**\n * @class ðŸš€ RouterPlugin\n * @classdesc A powerful, reactive, and flexible Router Plugin for Eleva.js applications.\n * This plugin provides comprehensive client-side routing functionality including:\n * - Multiple routing modes (hash, history, query)\n * - Navigation guards and lifecycle hooks\n * - Reactive state management\n * - Component resolution and lazy loading\n * - Layout and page component separation\n * - Plugin system for extensibility\n * - Advanced error handling\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n *\n * const HomePage = { template: () => `<h1>Home</h1>` };\n * const AboutPage = { template: () => `<h1>About Us</h1>` };\n * const UserPage = {\n *   template: (ctx) => `<h1>User: ${ctx.router.params.id}</h1>`\n * };\n *\n * app.use(RouterPlugin, {\n *   mount: '#app',\n *   mode: 'hash',\n *   routes: [\n *     { path: '/', component: HomePage },\n *     { path: '/about', component: AboutPage },\n *     { path: '/users/:id', component: UserPage }\n *   ]\n * });\n */\nexport const RouterPlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"router\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.0.0-rc.1\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description: \"Client-side routing for Eleva applications\",\n\n  /**\n   * Installs the RouterPlugin into an Eleva instance.\n   *\n   * @param {Eleva} eleva - The Eleva instance\n   * @param {RouterOptions} options - Router configuration options\n   * @param {string} options.mount - A CSS selector for the main element where the app is mounted\n   * @param {RouteDefinition[]} options.routes - An array of route definitions\n   * @param {'hash' | 'query' | 'history'} [options.mode='hash'] - The routing mode\n   * @param {string} [options.queryParam='page'] - The query parameter to use in 'query' mode\n   * @param {string} [options.viewSelector='view'] - The selector for the view element within a layout\n   * @param {boolean} [options.autoStart=true] - Whether to start the router automatically\n   * @param {NavigationGuard} [options.onBeforeEach] - A global guard executed before every navigation\n   * @param {string | ComponentDefinition | (() => Promise<{default: ComponentDefinition}>)} [options.globalLayout] - A global layout for all routes\n   *\n   * @example\n   * // main.js\n   * import Eleva from './eleva.js';\n   * import { RouterPlugin } from './plugins/RouterPlugin.js';\n   *\n   * const app = new Eleva('myApp');\n   *\n   * const HomePage = { template: () => `<h1>Home</h1>` };\n   * const AboutPage = { template: () => `<h1>About Us</h1>` };\n   *\n   * app.use(RouterPlugin, {\n   *  mount: '#app',\n   *  routes: [\n   *    { path: '/', component: HomePage },\n   *    { path: '/about', component: AboutPage }\n   *  ]\n   * });\n   */\n  install(eleva, options = {}) {\n    if (!options.mount) {\n      throw new Error(\"[RouterPlugin] 'mount' option is required\");\n    }\n\n    if (!options.routes || !Array.isArray(options.routes)) {\n      throw new Error(\"[RouterPlugin] 'routes' option must be an array\");\n    }\n\n    /**\n     * Registers a component definition with the Eleva instance.\n     * This method handles both inline component objects and pre-registered component names.\n     *\n     * @param {any} def - The component definition to register\n     * @param {string} type - The type of component for naming (e.g., \"Route\", \"Layout\")\n     * @returns {string | null} The registered component name or null if no definition provided\n     */\n    const register = (def, type) => {\n      if (!def) return null;\n\n      if (typeof def === \"object\" && def !== null && !def.name) {\n        const name = `Eleva${type}Component_${Math.random()\n          .toString(36)\n          .slice(2, 11)}`;\n\n        try {\n          eleva.component(name, def);\n          return name;\n        } catch (error) {\n          throw new Error(\n            `[RouterPlugin] Failed to register ${type} component: ${error.message}`\n          );\n        }\n      }\n      return def;\n    };\n\n    if (options.globalLayout) {\n      options.globalLayout = register(options.globalLayout, \"GlobalLayout\");\n    }\n\n    (options.routes || []).forEach((route) => {\n      route.component = register(route.component, \"Route\");\n      if (route.layout) {\n        route.layout = register(route.layout, \"RouteLayout\");\n      }\n    });\n\n    const router = new Router(eleva, options);\n    eleva.router = router;\n\n    if (options.autoStart !== false) {\n      queueMicrotask(() => router.start());\n    }\n\n    // Add plugin metadata to the Eleva instance\n    if (!eleva.plugins) {\n      eleva.plugins = new Map();\n    }\n    eleva.plugins.set(this.name, {\n      name: this.name,\n      version: this.version,\n      description: this.description,\n      options,\n    });\n\n    // Add utility methods for manual router access\n    eleva.navigate = router.navigate.bind(router);\n    eleva.getCurrentRoute = () => router.currentRoute.value;\n    eleva.getRouteParams = () => router.currentParams.value;\n    eleva.getRouteQuery = () => router.currentQuery.value;\n\n    return router;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance\n   *\n   * @param {Eleva} eleva - The Eleva instance\n   */\n  async uninstall(eleva) {\n    if (eleva.router) {\n      await eleva.router.destroy();\n      delete eleva.router;\n    }\n\n    // Remove plugin metadata\n    if (eleva.plugins) {\n      eleva.plugins.delete(this.name);\n    }\n\n    // Remove utility methods\n    delete eleva.navigate;\n    delete eleva.getCurrentRoute;\n    delete eleva.getRouteParams;\n    delete eleva.getRouteQuery;\n  },\n};\n"],"names":["CoreErrorHandler","handle","error","context","details","formattedError","Error","message","originalError","warn","log","Router","constructor","eleva","options","this","_extends","mode","queryParam","viewSelector","routes","_processRoutes","emitter","isStarted","_isNavigating","eventListeners","currentRoute","signal","previousRoute","currentParams","currentQuery","currentLayout","currentView","plugins","Map","errorHandler","_validateOptions","includes","processedRoutes","route","push","segments","_parsePathIntoSegments","path","normalizedPath","replace","split","filter","Boolean","map","segment","startsWith","paramName","substring","type","name","value","_findViewElement","container","selector","querySelector","start","window","document","mount","mountSelector","handler","_handleRouteChange","addEventListener","removeEventListener","destroy","plugin","values","forEach","cleanup","unmount","navigate","location","params","target","_buildPath","query","Object","keys","length","queryString","URLSearchParams","toString","_isSameRoute","_proceedWithNavigation","state","historyMethod","newUrl","pathname","search","history","replaceState","hash","url","_buildQueryUrl","queueMicrotask","emit","urlParams","set","current","targetPath","targetQuery","_parseQuery","JSON","stringify","result","key","entries","encodedValue","encodeURIComponent","String","RegExp","from","toLocation","_getCurrentLocation","fullUrl","fullPath","toMatch","_matchRoute","notFoundRoute","find","pathMatch","to","meta","matched","_runGuards","layoutComponent","pageComponent","_resolveComponents","tryUnmount","async","instance","layout","globalLayout","afterLeave","_render","afterEnter","guards","onBeforeEach","beforeLeave","beforeEnter","guard","_resolveStringComponent","def","componentDef","_components","get","componentName","availableComponents","Array","_resolveFunctionComponent","funcStr","isAsyncImport","default","function","_validateComponentDefinition","definition","template","_resolveComponent","effectiveLayout","Promise","all","component","mountEl","layoutInstance","_wrapComponentWithChildren","viewEl","viewInstance","_createRouteGetter","property","defaultValue","_this$currentRoute$va","_this$currentRoute$va2","_wrapComponent","originalSetup","setup","self","ctx","router","bind","previous","href","wrappedComponent","children","wrappedChildren","childComponent","slice","pathSegments","isMatch","i","routeSegment","pathSegment","decodeURIComponent","onAfterEnter","hook","on","onAfterLeave","onAfterEach","onError","use","install","has","existingPlugin","getPlugins","getPlugin","removePlugin","delete","setErrorHandler","version","description","isArray","register","Math","random","autoStart","getCurrentRoute","getRouteParams","getRouteQuery","uninstall"],"mappings":"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"}
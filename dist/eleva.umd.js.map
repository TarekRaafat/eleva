{"version":3,"file":"eleva.umd.js","sources":["../src/modules/TemplateEngine.js","../src/modules/Signal.js","../src/modules/Emitter.js","../src/modules/Renderer.js","../src/core/Eleva.js"],"sourcesContent":["\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @typedef {Record<string, unknown>} TemplateData\n *           Data context for template interpolation\n */\n\n/**\n * @typedef {string} TemplateString\n *           A string containing {{ expression }} interpolation markers\n */\n\n/**\n * @typedef {string} Expression\n *           A JavaScript expression to be evaluated in the data context\n */\n\n/**\n * @typedef {unknown} EvaluationResult\n *           The result of evaluating an expression (string, number, boolean, object, etc.)\n */\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A secure template engine that handles interpolation and dynamic attribute parsing.\n * Provides a way to evaluate expressions in templates.\n * All methods are static and can be called directly on the class.\n *\n * Template Syntax:\n * - `{{ expression }}` - Interpolate any JavaScript expression\n * - `{{ variable }}` - Access data properties directly\n * - `{{ object.property }}` - Access nested properties\n * - `{{ condition ? a : b }}` - Ternary expressions\n * - `{{ func(arg) }}` - Call functions from data context\n *\n * @example\n * // Basic interpolation\n * const template = \"Hello, {{name}}!\";\n * const data = { name: \"World\" };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Hello, World!\"\n *\n * @example\n * // Nested properties\n * const template = \"Welcome, {{user.name}}!\";\n * const data = { user: { name: \"John\" } };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Welcome, John!\"\n *\n * @example\n * // Expressions\n * const template = \"Status: {{active ? 'Online' : 'Offline'}}\";\n * const data = { active: true };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Status: Online\"\n *\n * @example\n * // With Signal values\n * const template = \"Count: {{count.value}}\";\n * const data = { count: { value: 42 } };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Count: 42\"\n */\nexport class TemplateEngine {\n  /**\n   * Regular expression for matching template expressions in the format {{ expression }}\n   * Matches: {{ anything }} with optional whitespace inside braces\n   *\n   * @static\n   * @private\n   * @type {RegExp}\n   */\n  static expressionPattern = /\\{\\{\\s*(.*?)\\s*\\}\\}/g;\n\n  /**\n   * Cache for compiled expression functions.\n   * Stores compiled Function objects keyed by expression string for O(1) lookup.\n   *\n   * @static\n   * @private\n   * @type {Map<string, Function>}\n   */\n  static _functionCache = new Map();\n\n  /**\n   * Parses a template string, replacing expressions with their evaluated values.\n   * Expressions are evaluated in the provided data context.\n   *\n   * @public\n   * @static\n   * @param {TemplateString|unknown} template - The template string to parse.\n   * @param {TemplateData} data - The data context for evaluating expressions.\n   * @returns {string} The parsed template with expressions replaced by their values.\n   *\n   * @example\n   * // Simple variables\n   * TemplateEngine.parse(\"Hello, {{name}}!\", { name: \"World\" });\n   * // Result: \"Hello, World!\"\n   *\n   * @example\n   * // Nested properties\n   * TemplateEngine.parse(\"{{user.name}} is {{user.age}} years old\", {\n   *   user: { name: \"John\", age: 30 }\n   * });\n   * // Result: \"John is 30 years old\"\n   *\n   * @example\n   * // Multiple expressions\n   * TemplateEngine.parse(\"{{greeting}}, {{name}}! You have {{count}} messages.\", {\n   *   greeting: \"Hello\",\n   *   name: \"User\",\n   *   count: 5\n   * });\n   * // Result: \"Hello, User! You have 5 messages.\"\n   *\n   * @example\n   * // With conditionals\n   * TemplateEngine.parse(\"Status: {{online ? 'Active' : 'Inactive'}}\", {\n   *   online: true\n   * });\n   * // Result: \"Status: Active\"\n   */\n  static parse(template, data) {\n    if (typeof template !== \"string\") return template;\n    return template.replace(this.expressionPattern, (_, expression) =>\n      this.evaluate(expression, data)\n    );\n  }\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   *\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   * The use of the `with` statement is necessary for expression evaluation but has security implications.\n   * Only use with trusted templates. User input should never be directly interpolated.\n   *\n   * @public\n   * @static\n   * @param {Expression|unknown} expression - The expression to evaluate.\n   * @param {TemplateData} data - The data context for evaluation.\n   * @returns {EvaluationResult} The result of the evaluation, or empty string if evaluation fails.\n   *\n   * @example\n   * // Property access\n   * TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } });\n   * // Result: \"John\"\n   *\n   * @example\n   * // Numeric values\n   * TemplateEngine.evaluate(\"user.age\", { user: { age: 30 } });\n   * // Result: 30\n   *\n   * @example\n   * // Expressions\n   * TemplateEngine.evaluate(\"items.length > 0\", { items: [1, 2, 3] });\n   * // Result: true\n   *\n   * @example\n   * // Function calls\n   * TemplateEngine.evaluate(\"formatDate(date)\", {\n   *   date: new Date(),\n   *   formatDate: (d) => d.toISOString()\n   * });\n   * // Result: \"2024-01-01T00:00:00.000Z\"\n   *\n   * @example\n   * // Failed evaluation returns empty string\n   * TemplateEngine.evaluate(\"nonexistent.property\", {});\n   * // Result: \"\"\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    let fn = this._functionCache.get(expression);\n    if (!fn) {\n      try {\n        fn = new Function(\"data\", `with(data) { return ${expression}; }`);\n        this._functionCache.set(expression, fn);\n      } catch {\n        return \"\";\n      }\n    }\n    try {\n      return fn(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @template T\n * @callback SignalWatcher\n * @param {T} value - The new value of the signal\n * @returns {void}\n */\n\n/**\n * @callback SignalUnsubscribe\n * @returns {boolean} True if the watcher was successfully removed\n */\n\n/**\n * @template T\n * @typedef {Object} SignalLike\n * @property {T} value - The current value\n * @property {function(SignalWatcher<T>): SignalUnsubscribe} watch - Subscribe to changes\n */\n\n/**\n * @class âš¡ Signal\n * @classdesc A reactive data holder that enables fine-grained reactivity in the Eleva framework.\n * Signals notify registered watchers synchronously when their value changes, enabling efficient\n * DOM updates through targeted patching rather than full re-renders.\n * Synchronous notification preserves stack traces and allows immediate value inspection.\n * Render batching is handled at the component level, not the signal level.\n * The class is generic, allowing type-safe handling of any value type T.\n *\n * @template T The type of value held by this signal\n *\n * @example\n * // Basic usage\n * const count = new Signal(0);\n * count.watch((value) => console.log(`Count changed to: ${value}`));\n * count.value = 1; // Logs: \"Count changed to: 1\"\n *\n * @example\n * // With unsubscribe\n * const name = new Signal(\"John\");\n * const unsubscribe = name.watch((value) => console.log(value));\n * name.value = \"Jane\"; // Logs: \"Jane\"\n * unsubscribe(); // Stop watching\n * name.value = \"Bob\"; // No log output\n *\n * @example\n * // With objects\n * /** @type {Signal<{x: number, y: number}>} *\\/\n * const position = new Signal({ x: 0, y: 0 });\n * position.value = { x: 10, y: 20 }; // Triggers watchers\n *\n * @implements {SignalLike<T>}\n */\nexport class Signal {\n  /**\n   * Creates a new Signal instance with the specified initial value.\n   *\n   * @public\n   * @param {T} value - The initial value of the signal.\n   *\n   * @example\n   * // Primitive types\n   * const count = new Signal(0);        // Signal<number>\n   * const name = new Signal(\"John\");    // Signal<string>\n   * const active = new Signal(true);    // Signal<boolean>\n   *\n   * @example\n   * // Complex types (use JSDoc for type inference)\n   * /** @type {Signal<string[]>} *\\/\n   * const items = new Signal([]);\n   *\n   * /** @type {Signal<{id: number, name: string} | null>} *\\/\n   * const user = new Signal(null);\n   */\n  constructor(value) {\n    /**\n     * Internal storage for the signal's current value.\n     * @private\n     * @type {T}\n     */\n    this._value = value;\n    /**\n     * Collection of callback functions to be notified when value changes.\n     * @private\n     * @type {Set<SignalWatcher<T>>}\n     */\n    this._watchers = new Set();\n  }\n\n  /**\n   * Gets the current value of the signal.\n   *\n   * @public\n   * @returns {T} The current value.\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Sets a new value for the signal and synchronously notifies all registered watchers if the value has changed.\n   * Synchronous notification preserves stack traces and ensures immediate value consistency.\n   *\n   * @public\n   * @param {T} newVal - The new value to set.\n   * @returns {void}\n   */\n  set value(newVal) {\n    if (this._value !== newVal) {\n      this._value = newVal;\n      this._notify();\n    }\n  }\n\n  /**\n   * Registers a watcher function that will be called whenever the signal's value changes.\n   * The watcher will receive the new value as its argument.\n   *\n   * @public\n   * @param {SignalWatcher<T>} fn - The callback function to invoke on value change.\n   * @returns {SignalUnsubscribe} A function to unsubscribe the watcher.\n   *\n   * @example\n   * // Basic watching\n   * const unsubscribe = signal.watch((value) => console.log(value));\n   *\n   * @example\n   * // Stop watching\n   * unsubscribe(); // Returns true if watcher was removed\n   *\n   * @example\n   * // Multiple watchers\n   * const unsub1 = signal.watch((v) => console.log(\"Watcher 1:\", v));\n   * const unsub2 = signal.watch((v) => console.log(\"Watcher 2:\", v));\n   * signal.value = \"test\"; // Both watchers are called\n   */\n  watch(fn) {\n    this._watchers.add(fn);\n    return () => this._watchers.delete(fn);\n  }\n\n  /**\n   * Synchronously notifies all registered watchers of the value change.\n   * This preserves stack traces for debugging and ensures immediate\n   * value consistency. Render batching is handled at the component level.\n   *\n   * @private\n   * @returns {void}\n   */\n  _notify() {\n    for (const fn of this._watchers) fn(this._value);\n  }\n}\n","\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @template T\n * @callback EventHandler\n * @param {...T} args - Event arguments\n * @returns {void|Promise<void>}\n */\n\n/**\n * @callback EventUnsubscribe\n * @returns {void}\n */\n\n/**\n * @typedef {`${string}:${string}`} EventName\n *           Event names follow the format 'namespace:action' (e.g., 'user:login', 'cart:update')\n */\n\n/**\n * @typedef {Object} EmitterLike\n * @property {function(string, EventHandler<unknown>): EventUnsubscribe} on - Subscribe to an event\n * @property {function(string, EventHandler<unknown>=): void} off - Unsubscribe from an event\n * @property {function(string, ...unknown): void} emit - Emit an event\n */\n\n/**\n * @class ðŸ“¡ Emitter\n * @classdesc A robust event emitter that enables inter-component communication through a publish-subscribe pattern.\n * Components can emit events and listen for events from other components, facilitating loose coupling\n * and reactive updates across the application.\n * Events are handled synchronously in the order they were registered, with proper cleanup\n * of unsubscribed handlers.\n *\n * Event names should follow the format 'namespace:action' for consistency and organization.\n *\n * @example\n * // Basic usage\n * const emitter = new Emitter();\n * emitter.on('user:login', (user) => console.log(`User logged in: ${user.name}`));\n * emitter.emit('user:login', { name: 'John' }); // Logs: \"User logged in: John\"\n *\n * @example\n * // With unsubscribe\n * const unsub = emitter.on('cart:update', (items) => {\n *   console.log(`Cart has ${items.length} items`);\n * });\n * emitter.emit('cart:update', [{ id: 1, name: 'Book' }]); // Logs: \"Cart has 1 items\"\n * unsub(); // Stop listening\n * emitter.emit('cart:update', []); // No log output\n *\n * @example\n * // Multiple arguments\n * emitter.on('order:placed', (orderId, amount, currency) => {\n *   console.log(`Order ${orderId}: ${amount} ${currency}`);\n * });\n * emitter.emit('order:placed', 'ORD-123', 99.99, 'USD');\n *\n * @example\n * // Common event patterns\n * // Lifecycle events\n * emitter.on('component:mount', (component) => {});\n * emitter.on('component:unmount', (component) => {});\n * // State events\n * emitter.on('state:change', (newState, oldState) => {});\n * // Navigation events\n * emitter.on('router:navigate', (to, from) => {});\n *\n * @implements {EmitterLike}\n */\nexport class Emitter {\n  /**\n   * Creates a new Emitter instance.\n   *\n   * @public\n   *\n   * @example\n   * const emitter = new Emitter();\n   */\n  constructor() {\n    /**\n     * Map of event names to their registered handler functions\n     * @private\n     * @type {Map<string, Set<EventHandler<unknown>>>}\n     */\n    this._events = new Map();\n  }\n\n  /**\n   * Registers an event handler for the specified event name.\n   * The handler will be called with the event data when the event is emitted.\n   * Event names should follow the format 'namespace:action' for consistency.\n   *\n   * @public\n   * @template T\n   * @param {string} event - The name of the event to listen for (e.g., 'user:login').\n   * @param {EventHandler<T>} handler - The callback function to invoke when the event occurs.\n   * @returns {EventUnsubscribe} A function to unsubscribe the event handler.\n   *\n   * @example\n   * // Basic subscription\n   * const unsubscribe = emitter.on('user:login', (user) => console.log(user));\n   *\n   * @example\n   * // Typed handler\n   * emitter.on('user:update', (/** @type {{id: number, name: string}} *\\/ user) => {\n   *   console.log(`User ${user.id}: ${user.name}`);\n   * });\n   *\n   * @example\n   * // Cleanup\n   * unsubscribe(); // Stops listening for the event\n   */\n  on(event, handler) {\n    let h = this._events.get(event);\n    if (!h) this._events.set(event, (h = new Set()));\n    h.add(handler);\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Removes an event handler for the specified event name.\n   * If no handler is provided, all handlers for the event are removed.\n   * Automatically cleans up empty event sets to prevent memory leaks.\n   *\n   * @public\n   * @template T\n   * @param {string} event - The name of the event to remove handlers from.\n   * @param {EventHandler<T>} [handler] - The specific handler function to remove.\n   * @returns {void}\n   *\n   * @example\n   * // Remove a specific handler\n   * const loginHandler = (user) => console.log(user);\n   * emitter.on('user:login', loginHandler);\n   * emitter.off('user:login', loginHandler);\n   *\n   * @example\n   * // Remove all handlers for an event\n   * emitter.off('user:login');\n   */\n  off(event, handler) {\n    if (!this._events.has(event)) return;\n    if (handler) {\n      const handlers = this._events.get(event);\n      handlers.delete(handler);\n      if (handlers.size === 0) this._events.delete(event);\n    } else {\n      this._events.delete(event);\n    }\n  }\n\n  /**\n   * Emits an event with the specified data to all registered handlers.\n   * Handlers are called synchronously in the order they were registered.\n   * If no handlers are registered for the event, the emission is silently ignored.\n   *\n   * @public\n   * @template T\n   * @param {string} event - The name of the event to emit.\n   * @param {...T} args - Optional arguments to pass to the event handlers.\n   * @returns {void}\n   *\n   * @example\n   * // Emit an event with data\n   * emitter.emit('user:login', { name: 'John', role: 'admin' });\n   *\n   * @example\n   * // Emit an event with multiple arguments\n   * emitter.emit('order:placed', 'ORD-123', 99.99, 'USD');\n   *\n   * @example\n   * // Emit without data\n   * emitter.emit('app:ready');\n   */\n  emit(event, ...args) {\n    const handlers = this._events.get(event);\n    if (handlers) for (const handler of handlers) handler(...args);\n  }\n}\n","\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @typedef {Map<string, Node>} KeyMap\n *          Map of key attribute values to their corresponding DOM nodes for O(1) lookup\n */\n\n/**\n * @typedef {Object} RendererLike\n * @property {function(HTMLElement, string): void} patchDOM - Patches the DOM with new HTML\n */\n\n/**\n * Properties that can diverge from attributes via user interaction.\n * @private\n * @type {string[]}\n */\nconst SYNC_PROPS = [\"value\", \"checked\", \"selected\"];\n\n/**\n * @class ðŸŽ¨ Renderer\n * @classdesc A high-performance DOM renderer that implements an optimized two-pointer diffing\n * algorithm with key-based node reconciliation. The renderer efficiently updates the DOM by\n * computing the minimal set of operations needed to transform the current state to the desired state.\n *\n * Key features:\n * - Two-pointer diffing algorithm for efficient DOM updates\n * - Key-based node reconciliation for optimal list performance (O(1) lookup)\n * - Preserves DOM node identity during reordering (maintains event listeners, focus, animations)\n * - Intelligent attribute synchronization (skips Eleva event attributes)\n * - Preservation of Eleva-managed component instances and style elements\n *\n * @example\n * // Basic usage\n * const renderer = new Renderer();\n * renderer.patchDOM(container, '<div>Updated content</div>');\n *\n * @example\n * // With keyed elements for optimal list updates\n * const html = items.map(item => `<li key=\"${item.id}\">${item.name}</li>`).join('');\n * renderer.patchDOM(listContainer, `<ul>${html}</ul>`);\n *\n * @example\n * // Keyed elements preserve DOM identity during reordering\n * // Before: [A, B, C] -> After: [C, A, B]\n * // The actual DOM nodes are moved, not recreated\n * renderer.patchDOM(container, '<div key=\"C\">C</div><div key=\"A\">A</div><div key=\"B\">B</div>');\n *\n * @implements {RendererLike}\n */\nexport class Renderer {\n  /**\n   * Creates a new Renderer instance.\n   *\n   * @public\n   *\n   * @example\n   * const renderer = new Renderer();\n   */\n  constructor() {\n    /**\n     * Temporary container for parsing new HTML content.\n     * Reused across patch operations to minimize memory allocation.\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this._tempContainer = document.createElement(\"div\");\n  }\n\n  /**\n   * Patches the DOM of the given container with the provided HTML string.\n   * Uses an optimized two-pointer diffing algorithm to minimize DOM operations.\n   * The algorithm computes the minimal set of insertions, deletions, and updates\n   * needed to transform the current DOM state to match the new HTML.\n   *\n   * @public\n   * @param {HTMLElement} container - The container element to patch.\n   * @param {string} newHtml - The new HTML string to render.\n   * @returns {void}\n   *\n   * @example\n   * // Simple content update\n   * renderer.patchDOM(container, '<div class=\"updated\">New content</div>');\n   *\n   * @example\n   * // List with keyed items (optimal for reordering)\n   * renderer.patchDOM(container, '<ul><li key=\"1\">First</li><li key=\"2\">Second</li></ul>');\n   *\n   * @example\n   * // Empty the container\n   * renderer.patchDOM(container, '');\n   */\n  patchDOM(container, newHtml) {\n    this._tempContainer.innerHTML = newHtml;\n    this._diff(container, this._tempContainer);\n  }\n\n  /**\n   * Performs a diff between two DOM nodes and patches the old node to match the new node.\n   * Uses a two-pointer algorithm with key-based reconciliation for optimal performance.\n   *\n   * Algorithm overview:\n   * 1. Compare children from start using two pointers\n   * 2. For mismatches, build a key map lazily for O(1) lookup\n   * 3. Move or insert nodes as needed\n   * 4. Clean up remaining nodes at the end\n   *\n   * @private\n   * @param {HTMLElement} oldParent - The original DOM element to update.\n   * @param {HTMLElement} newParent - The new DOM element with desired state.\n   * @returns {void}\n   */\n  _diff(oldParent, newParent) {\n    // Early exit for leaf nodes (no children)\n    if (!oldParent.firstChild && !newParent.firstChild) return;\n\n    const oldChildren = Array.from(oldParent.childNodes);\n    const newChildren = Array.from(newParent.childNodes);\n    let oldStart = 0,\n      newStart = 0;\n    let oldEnd = oldChildren.length - 1;\n    let newEnd = newChildren.length - 1;\n    let keyMap = null;\n\n    // Two-pointer algorithm with key-based reconciliation\n    while (oldStart <= oldEnd && newStart <= newEnd) {\n      const oldNode = oldChildren[oldStart];\n      const newNode = newChildren[newStart];\n\n      if (!oldNode) {\n        oldStart++;\n        continue;\n      }\n\n      if (this._isSameNode(oldNode, newNode)) {\n        this._patchNode(oldNode, newNode);\n        oldStart++;\n        newStart++;\n      } else {\n        // Build key map lazily for O(1) lookup\n        if (!keyMap) {\n          keyMap = this._createKeyMap(oldChildren, oldStart, oldEnd);\n        }\n\n        const key = this._getNodeKey(newNode);\n        const matchedNode = key ? keyMap.get(key) : null;\n\n        // Only use matched node if tag also matches\n        if (matchedNode && matchedNode.nodeName === newNode.nodeName) {\n          // Move existing keyed node (preserves DOM identity)\n          this._patchNode(matchedNode, newNode);\n          oldParent.insertBefore(matchedNode, oldNode);\n          oldChildren[oldChildren.indexOf(matchedNode)] = null;\n        } else {\n          // Insert new node\n          oldParent.insertBefore(newNode.cloneNode(true), oldNode);\n        }\n        newStart++;\n      }\n    }\n\n    // Add remaining new nodes\n    if (oldStart > oldEnd) {\n      const refNode = newChildren[newEnd + 1] ? oldChildren[oldStart] : null;\n      for (let i = newStart; i <= newEnd; i++) {\n        if (newChildren[i]) {\n          oldParent.insertBefore(newChildren[i].cloneNode(true), refNode);\n        }\n      }\n    }\n    // Remove remaining old nodes\n    else if (newStart > newEnd) {\n      for (let i = oldStart; i <= oldEnd; i++) {\n        if (oldChildren[i]) this._removeNode(oldParent, oldChildren[i]);\n      }\n    }\n  }\n\n  /**\n   * Patches a single node, updating its content and attributes to match the new node.\n   * Handles text nodes by updating nodeValue, and element nodes by updating attributes\n   * and recursively diffing children.\n   *\n   * Skips nodes that are managed by Eleva component instances to prevent interference\n   * with nested component state.\n   *\n   * @private\n   * @param {Node} oldNode - The original DOM node to update.\n   * @param {Node} newNode - The new DOM node with desired state.\n   * @returns {void}\n   */\n  _patchNode(oldNode, newNode) {\n    // Skip nodes managed by Eleva component instances\n    if (oldNode._eleva_instance) return;\n\n    if (oldNode.nodeType === 3) {\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue;\n      }\n    } else if (oldNode.nodeType === 1) {\n      this._updateAttributes(oldNode, newNode);\n      this._diff(oldNode, newNode);\n    }\n  }\n\n  /**\n   * Removes a node from its parent, with special handling for Eleva-managed elements.\n   * Style elements with the `data-e-style` attribute are preserved to maintain\n   * component-scoped styles across re-renders.\n   *\n   * @private\n   * @param {HTMLElement} parent - The parent element containing the node.\n   * @param {Node} node - The node to remove.\n   * @returns {void}\n   */\n  _removeNode(parent, node) {\n    // Preserve Eleva-managed style elements\n    if (node.nodeName === \"STYLE\" && node.hasAttribute(\"data-e-style\")) return;\n    parent.removeChild(node);\n  }\n\n  /**\n   * Updates the attributes of an element to match a new element's attributes.\n   * Adds new attributes, updates changed values, and removes attributes no longer present.\n   * Also syncs DOM properties that can diverge from attributes after user interaction.\n   *\n   * Event attributes (prefixed with `@`) are skipped as they are handled separately\n   * by Eleva's event binding system.\n   *\n   * @private\n   * @param {HTMLElement} oldEl - The original element to update.\n   * @param {HTMLElement} newEl - The new element with target attributes.\n   * @returns {void}\n   */\n  _updateAttributes(oldEl, newEl) {\n    // Add/update attributes from new element\n    for (const attr of newEl.attributes) {\n      // Skip event attributes (handled by Eleva's event system)\n      if (attr.name[0] === \"@\") continue;\n\n      if (oldEl.getAttribute(attr.name) !== attr.value) {\n        oldEl.setAttribute(attr.name, attr.value);\n      }\n\n      // Sync property if it exists and is writable (handles value, checked, selected, disabled, etc.)\n      if (attr.name in oldEl) {\n        try {\n          const newProp =\n            typeof oldEl[attr.name] === \"boolean\"\n              ? attr.value !== \"false\" // Attribute presence = true, unless explicitly \"false\"\n              : attr.value;\n          if (oldEl[attr.name] !== newProp) oldEl[attr.name] = newProp;\n        } catch {\n          continue; // Property is readonly\n        }\n      }\n    }\n\n    // Remove attributes no longer present\n    for (let i = oldEl.attributes.length - 1; i >= 0; i--) {\n      const name = oldEl.attributes[i].name;\n      if (!newEl.hasAttribute(name)) {\n        oldEl.removeAttribute(name);\n      }\n    }\n\n    // Sync properties that can diverge from attributes via user interaction\n    for (const prop of SYNC_PROPS) {\n      if (prop in newEl && oldEl[prop] !== newEl[prop])\n        oldEl[prop] = newEl[prop];\n    }\n  }\n\n  /**\n   * Determines if two nodes are the same for reconciliation purposes.\n   * Two nodes are considered the same if:\n   * - Both have keys: keys match AND tag names match\n   * - Neither has keys: node types match AND node names match\n   * - One has key, other doesn't: not the same\n   *\n   * This ensures keyed elements are only reused when both key and tag match,\n   * preventing bugs like `<div key=\"a\">` incorrectly matching `<span key=\"a\">`.\n   *\n   * @private\n   * @param {Node} oldNode - The first node to compare.\n   * @param {Node} newNode - The second node to compare.\n   * @returns {boolean} True if the nodes are considered the same for reconciliation.\n   */\n  _isSameNode(oldNode, newNode) {\n    if (!oldNode || !newNode) return false;\n\n    const oldKey = this._getNodeKey(oldNode);\n    const newKey = this._getNodeKey(newNode);\n\n    // If both have keys, compare by key AND tag name\n    if (oldKey && newKey) {\n      return oldKey === newKey && oldNode.nodeName === newNode.nodeName;\n    }\n\n    // Otherwise, compare by type and name\n    return (\n      !oldKey &&\n      !newKey &&\n      oldNode.nodeType === newNode.nodeType &&\n      oldNode.nodeName === newNode.nodeName\n    );\n  }\n\n  /**\n   * Extracts the key attribute from a node if it exists.\n   * Only element nodes (nodeType === 1) can have key attributes.\n   *\n   * @private\n   * @param {Node|null|undefined} node - The node to extract the key from.\n   * @returns {string|null} The key attribute value, or null if not an element or no key.\n   */\n  _getNodeKey(node) {\n    return node?.nodeType === 1 ? node.getAttribute(\"key\") : null;\n  }\n\n  /**\n   * Creates a key map for efficient O(1) lookup of keyed elements during diffing.\n   * The map is built lazily only when needed (when a mismatch occurs during diffing).\n   *\n   * @private\n   * @param {Array<ChildNode>} children - The array of child nodes to map.\n   * @param {number} start - The start index (inclusive) for mapping.\n   * @param {number} end - The end index (inclusive) for mapping.\n   * @returns {KeyMap} A Map of key strings to their corresponding DOM nodes.\n   */\n  _createKeyMap(children, start, end) {\n    const map = new Map();\n    for (let i = start; i <= end; i++) {\n      const key = this._getNodeKey(children[i]);\n      if (key) map.set(key, children[i]);\n    }\n    return map;\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\nimport { Signal } from \"../modules/Signal.js\";\nimport { Emitter } from \"../modules/Emitter.js\";\nimport { Renderer } from \"../modules/Renderer.js\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n// -----------------------------------------------------------------------------\n// Configuration Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ElevaConfig\n * @property {boolean} [debug=false]\n *           Enable debug mode for verbose logging\n * @property {string} [prefix='e']\n *           Prefix for component style scoping\n * @property {boolean} [async=true]\n *           Enable async component setup\n */\n\n// -----------------------------------------------------------------------------\n// Component Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ComponentDefinition\n * @property {SetupFunction} [setup]\n *           Optional setup function that initializes the component's state and returns reactive data\n * @property {TemplateFunction|string} template\n *           Required function or string that defines the component's HTML structure\n * @property {StyleFunction|string} [style]\n *           Optional function or string that provides component-scoped CSS styles\n * @property {ChildrenMap} [children]\n *           Optional object defining nested child components\n */\n\n/**\n * @callback SetupFunction\n * @param {ComponentContext} ctx - The component context with props, emitter, and signal factory\n * @returns {SetupResult|Promise<SetupResult>} Reactive data and lifecycle hooks\n */\n\n/**\n * @typedef {Record<string, unknown> & LifecycleHooks} SetupResult\n *           Data returned from setup function, may include lifecycle hooks\n */\n\n/**\n * @callback TemplateFunction\n * @param {ComponentContext} ctx - The component context\n * @returns {string|Promise<string>} HTML template string\n */\n\n/**\n * @callback StyleFunction\n * @param {ComponentContext} ctx - The component context\n * @returns {string} CSS styles string\n */\n\n/**\n * @typedef {Record<string, ComponentDefinition|string>} ChildrenMap\n *           Map of CSS selectors to component definitions or registered component names\n */\n\n// -----------------------------------------------------------------------------\n// Context Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ComponentContext\n * @property {ComponentProps} props\n *           Component properties passed during mounting\n * @property {Emitter} emitter\n *           Event emitter instance for component event handling\n * @property {SignalFactory} signal\n *           Factory function to create reactive Signal instances\n */\n\n/**\n * @typedef {Record<string, unknown>} ComponentProps\n *           Properties passed to a component during mounting\n */\n\n/**\n * @callback SignalFactory\n * @template T\n * @param {T} initialValue - The initial value for the signal\n * @returns {Signal<T>} A new Signal instance\n */\n\n// -----------------------------------------------------------------------------\n// Lifecycle Hook Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} LifecycleHooks\n * @property {LifecycleHook} [onBeforeMount]\n *           Hook called before component mounting\n * @property {LifecycleHook} [onMount]\n *           Hook called after component mounting\n * @property {LifecycleHook} [onBeforeUpdate]\n *           Hook called before component update\n * @property {LifecycleHook} [onUpdate]\n *           Hook called after component update\n * @property {UnmountHook} [onUnmount]\n *           Hook called during component unmounting\n */\n\n/**\n * @callback LifecycleHook\n * @param {LifecycleHookContext} ctx - Context with container and component data\n * @returns {void|Promise<void>}\n */\n\n/**\n * @callback UnmountHook\n * @param {UnmountHookContext} ctx - Context with cleanup resources\n * @returns {void|Promise<void>}\n */\n\n/**\n * @typedef {Object} LifecycleHookContext\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {ComponentContext & SetupResult} context\n *           The component's reactive state and context data\n */\n\n/**\n * @typedef {Object} UnmountHookContext\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {ComponentContext & SetupResult} context\n *           The component's reactive state and context data\n * @property {CleanupResources} cleanup\n *           Object containing cleanup functions and instances\n */\n\n/**\n * @typedef {Object} CleanupResources\n * @property {Array<UnsubscribeFunction>} watchers\n *           Signal watcher cleanup functions\n * @property {Array<UnsubscribeFunction>} listeners\n *           Event listener cleanup functions\n * @property {Array<MountResult>} children\n *           Child component instances\n */\n\n// -----------------------------------------------------------------------------\n// Mount Result Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} MountResult\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {ComponentContext & SetupResult} data\n *           The component's reactive state and context data\n * @property {UnmountFunction} unmount\n *           Function to clean up and unmount the component\n */\n\n/**\n * @callback UnmountFunction\n * @returns {Promise<void>}\n */\n\n/**\n * @callback UnsubscribeFunction\n * @returns {void|boolean}\n */\n\n// -----------------------------------------------------------------------------\n// Plugin Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ElevaPlugin\n * @property {PluginInstallFunction} install\n *           Function that installs the plugin into the Eleva instance\n * @property {string} name\n *           Unique identifier name for the plugin\n * @property {PluginUninstallFunction} [uninstall]\n *           Optional function to uninstall the plugin\n */\n\n/**\n * @callback PluginInstallFunction\n * @param {Eleva} eleva - The Eleva instance\n * @param {PluginOptions} options - Plugin configuration options\n * @returns {void|Eleva|unknown} Optionally returns the Eleva instance or plugin result\n */\n\n/**\n * @callback PluginUninstallFunction\n * @param {Eleva} eleva - The Eleva instance\n * @returns {void}\n */\n\n/**\n * @typedef {Record<string, unknown>} PluginOptions\n *           Configuration options passed to a plugin during installation\n */\n\n// -----------------------------------------------------------------------------\n// Event Types\n// -----------------------------------------------------------------------------\n\n/**\n * @callback EventHandler\n * @param {Event} event - The DOM event object\n * @returns {void}\n */\n\n/**\n * @typedef {'click'|'submit'|'input'|'change'|'focus'|'blur'|'keydown'|'keyup'|'keypress'|'mouseenter'|'mouseleave'|'mouseover'|'mouseout'|'mousedown'|'mouseup'|'touchstart'|'touchend'|'touchmove'|'scroll'|'resize'|'load'|'error'|string} DOMEventName\n *           Common DOM event names (prefixed with @ in templates)\n */\n\n/**\n * @class ðŸ§© Eleva\n * @classdesc A modern, signal-based component runtime framework that provides lifecycle hooks,\n * scoped styles, and plugin support. Eleva manages component registration, plugin integration,\n * event handling, and DOM rendering with a focus on performance and developer experience.\n *\n * @example\n * // Basic component creation and mounting\n * const app = new Eleva(\"myApp\");\n * app.component(\"myComponent\", {\n *   setup: (ctx) => ({ count: ctx.signal(0) }),\n *   template: (ctx) => `<div>Hello ${ctx.props.name}</div>`\n * });\n * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n *\n * @example\n * // Using lifecycle hooks\n * app.component(\"lifecycleDemo\", {\n *   setup: () => {\n *     return {\n *       onMount: ({ container, context }) => {\n *         console.log('Component mounted!');\n *       }\n *     };\n *   },\n *   template: `<div>Lifecycle Demo</div>`\n * });\n */\nexport class Eleva {\n  /**\n   * Creates a new Eleva instance with the specified name and configuration.\n   *\n   * @public\n   * @param {string} name - The unique identifier name for this Eleva instance.\n   * @param {Record<string, unknown>} [config={}] - Optional configuration object for the instance.\n   *        May include framework-wide settings and default behaviors.\n   * @throws {Error} If the name is not provided or is not a string.\n   * @returns {Eleva} A new Eleva instance.\n   *\n   * @example\n   * const app = new Eleva(\"myApp\");\n   * app.component(\"myComponent\", {\n   *   setup: (ctx) => ({ count: ctx.signal(0) }),\n   *   template: (ctx) => `<div>Hello ${ctx.props.name}!</div>`\n   * });\n   * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n   *\n   */\n  constructor(name, config = {}) {\n    if (!name || typeof name !== \"string\") {\n      throw new Error(\"Eleva: name must be a non-empty string\");\n    }\n    /** @public {string} The unique identifier name for this Eleva instance */\n    this.name = name;\n    /** @public {Object<string, unknown>} Optional configuration object for the Eleva instance */\n    this.config = config;\n    /** @public {Emitter} Instance of the event emitter for handling component events */\n    this.emitter = new Emitter();\n    /** @public {typeof Signal} Static reference to the Signal class for creating reactive state */\n    this.signal = Signal;\n    /** @public {typeof TemplateEngine} Static reference to the TemplateEngine class for template parsing */\n    this.templateEngine = TemplateEngine;\n    /** @public {Renderer} Instance of the renderer for handling DOM updates and patching */\n    this.renderer = new Renderer();\n\n    /** @private {Map<string, ComponentDefinition>} Registry of all component definitions by name */\n    this._components = new Map();\n    /** @private {Map<string, ElevaPlugin>} Collection of installed plugin instances by name */\n    this._plugins = new Map();\n    /** @private {number} Counter for generating unique component IDs */\n    this._componentCounter = 0;\n  }\n\n  /**\n   * Integrates a plugin with the Eleva framework.\n   * The plugin's install function will be called with the Eleva instance and provided options.\n   * After installation, the plugin will be available for use by components.\n   *\n   * Note: Plugins that wrap core methods (e.g., mount) must be uninstalled in reverse order\n   * of installation (LIFO - Last In, First Out) to avoid conflicts.\n   *\n   * @public\n   * @param {ElevaPlugin} plugin - The plugin object which must have an `install` function.\n   * @param {Object<string, unknown>} [options={}] - Optional configuration options for the plugin.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If plugin does not have an install function.\n   * @example\n   * app.use(myPlugin, { option1: \"value1\" });\n   *\n   * @example\n   * // Correct uninstall order (LIFO)\n   * app.use(PluginA);\n   * app.use(PluginB);\n   * // Uninstall in reverse order:\n   * PluginB.uninstall(app);\n   * PluginA.uninstall(app);\n   */\n  use(plugin, options = {}) {\n    if (!plugin?.install || typeof plugin.install !== \"function\") {\n      throw new Error(\"Eleva: plugin must have an install function\");\n    }\n    this._plugins.set(plugin.name, plugin);\n    const result = plugin.install(this, options);\n\n    return result !== undefined ? result : this;\n  }\n\n  /**\n   * Registers a new component with the Eleva instance.\n   * The component will be available for mounting using its registered name.\n   *\n   * @public\n   * @param {string} name - The unique name of the component to register.\n   * @param {ComponentDefinition} definition - The component definition including setup, template, style, and children.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If name is not a non-empty string or definition has no template.\n   * @example\n   * app.component(\"myButton\", {\n   *   template: (ctx) => `<button>${ctx.props.text}</button>`,\n   *   style: `button { color: blue; }`\n   * });\n   */\n  component(name, definition) {\n    if (!name || typeof name !== \"string\") {\n      throw new Error(\"Eleva: component name must be a non-empty string\");\n    }\n    if (!definition?.template) {\n      throw new Error(`Eleva: component \"${name}\" must have a template`);\n    }\n    /** @type {Map<string, ComponentDefinition>} */\n    this._components.set(name, definition);\n    return this;\n  }\n\n  /**\n   * Mounts a registered component to a DOM element.\n   * This will initialize the component, set up its reactive state, and render it to the DOM.\n   *\n   * @public\n   * @param {HTMLElement} container - The DOM element where the component will be mounted.\n   * @param {string|ComponentDefinition} compName - The name of the registered component or a direct component definition.\n   * @param {Object<string, unknown>} [props={}] - Optional properties to pass to the component.\n   * @returns {Promise<MountResult>}\n   *          A Promise that resolves to an object containing:\n   *          - container: The mounted component's container element\n   *          - data: The component's reactive state and context\n   *          - unmount: Function to clean up and unmount the component\n   * @throws {Error} If container is not a DOM element or component is not registered.\n   * @example\n   * const instance = await app.mount(document.getElementById(\"app\"), \"myComponent\", { text: \"Click me\" });\n   * // Later...\n   * instance.unmount();\n   */\n  async mount(container, compName, props = {}) {\n    if (!container?.nodeType) {\n      throw new Error(\"Eleva: container must be a DOM element\");\n    }\n\n    if (container._eleva_instance) return container._eleva_instance;\n\n    /** @type {ComponentDefinition} */\n    const definition =\n      typeof compName === \"string\" ? this._components.get(compName) : compName;\n    if (!definition) throw new Error(`Component \"${compName}\" not registered.`);\n\n    /** @type {string} */\n    const compId = `c${++this._componentCounter}`;\n\n    /**\n     * Destructure the component definition to access core functionality.\n     * - setup: Optional function for component initialization and state management\n     * - template: Required function or string that returns the component's HTML structure\n     * - style: Optional function or string for component-scoped CSS styles\n     * - children: Optional object defining nested child components\n     */\n    const { setup, template, style, children } = definition;\n\n    /** @type {ComponentContext} */\n    const context = {\n      props,\n      emitter: this.emitter,\n      /** @type {(v: unknown) => Signal<unknown>} */\n      signal: (v) => new this.signal(v),\n    };\n\n    /**\n     * Processes the mounting of the component.\n     * This function handles:\n     * 1. Merging setup data with the component context\n     * 2. Setting up reactive watchers\n     * 3. Rendering the component\n     * 4. Managing component lifecycle\n     *\n     * @param {Object<string, unknown>} data - Data returned from the component's setup function\n     * @returns {Promise<MountResult>} An object containing:\n     *   - container: The mounted component's container element\n     *   - data: The component's reactive state and context\n     *   - unmount: Function to clean up and unmount the component\n     */\n    const processMount = async (data) => {\n      /** @type {ComponentContext} */\n      const mergedContext = { ...context, ...data };\n      /** @type {Array<() => void>} */\n      const watchers = [];\n      /** @type {Array<MountResult>} */\n      const childInstances = [];\n      /** @type {Array<() => void>} */\n      const listeners = [];\n      /** @private {boolean} Local mounted state for this component instance */\n      let isMounted = false;\n\n      // ========================================================================\n      // Render Batching\n      // ========================================================================\n\n      /** @private {boolean} Flag to prevent concurrent renders */\n      let renderScheduled = false;\n\n      /**\n       * Schedules a render using microtask batching.\n       * Since signals now notify watchers synchronously, multiple signal\n       * changes in the same synchronous block will each call this function,\n       * but only one render will be scheduled via queueMicrotask.\n       * This separates concerns: signals handle state, components handle scheduling.\n       * @private\n       */\n      const scheduleRender = () => {\n        if (renderScheduled) return;\n        renderScheduled = true;\n        queueMicrotask(async () => {\n          renderScheduled = false;\n          await render();\n        });\n      };\n\n      /**\n       * Renders the component by:\n       * 1. Executing lifecycle hooks\n       * 2. Processing the template\n       * 3. Updating the DOM\n       * 4. Processing events, injecting styles, and mounting child components.\n       */\n      const render = async () => {\n        const templateResult =\n          typeof template === \"function\"\n            ? await template(mergedContext)\n            : template;\n        const html = this.templateEngine.parse(templateResult, mergedContext);\n\n        // Execute before hooks\n        if (!isMounted) {\n          await mergedContext.onBeforeMount?.({\n            container,\n            context: mergedContext,\n          });\n        } else {\n          await mergedContext.onBeforeUpdate?.({\n            container,\n            context: mergedContext,\n          });\n        }\n\n        this.renderer.patchDOM(container, html);\n        this._processEvents(container, mergedContext, listeners);\n        if (style) this._injectStyles(container, compId, style, mergedContext);\n        if (children)\n          await this._mountComponents(container, children, childInstances);\n\n        // Execute after hooks\n        if (!isMounted) {\n          await mergedContext.onMount?.({\n            container,\n            context: mergedContext,\n          });\n          isMounted = true;\n        } else {\n          await mergedContext.onUpdate?.({\n            container,\n            context: mergedContext,\n          });\n        }\n      };\n\n      /**\n       * Sets up reactive watchers for all Signal instances in the component's data.\n       * When a Signal's value changes, a batched render is scheduled.\n       * Multiple changes within the same frame are collapsed into one render.\n       * Stores unsubscribe functions to clean up watchers when component unmounts.\n       */\n      for (const val of Object.values(data)) {\n        if (val instanceof Signal) watchers.push(val.watch(scheduleRender));\n      }\n\n      await render();\n\n      const instance = {\n        container,\n        data: mergedContext,\n        /**\n         * Unmounts the component, cleaning up watchers and listeners, child components, and clearing the container.\n         *\n         * @returns {void}\n         */\n        unmount: async () => {\n          /** @type {UnmountHookContext} */\n          await mergedContext.onUnmount?.({\n            container,\n            context: mergedContext,\n            cleanup: {\n              watchers: watchers,\n              listeners: listeners,\n              children: childInstances,\n            },\n          });\n          for (const fn of watchers) fn();\n          for (const fn of listeners) fn();\n          for (const child of childInstances) await child.unmount();\n          container.innerHTML = \"\";\n          delete container._eleva_instance;\n        },\n      };\n\n      container._eleva_instance = instance;\n      return instance;\n    };\n\n    // Handle asynchronous setup.\n    const setupResult = typeof setup === \"function\" ? await setup(context) : {};\n    return await processMount(setupResult);\n  }\n\n  /**\n   * Processes DOM elements for event binding based on attributes starting with \"@\".\n   * This method handles the event delegation system and ensures proper cleanup of event listeners.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element in which to search for event attributes.\n   * @param {ComponentContext} context - The current component context containing event handler definitions.\n   * @param {Array<() => void>} listeners - Array to collect cleanup functions for each event listener.\n   * @returns {void}\n   */\n  _processEvents(container, context, listeners) {\n    /** @type {NodeListOf<Element>} */\n    const elements = container.querySelectorAll(\"*\");\n    for (const el of elements) {\n      /** @type {NamedNodeMap} */\n      const attrs = el.attributes;\n      for (let i = 0; i < attrs.length; i++) {\n        /** @type {Attr} */\n        const attr = attrs[i];\n\n        if (!attr.name.startsWith(\"@\")) continue;\n\n        /** @type {keyof HTMLElementEventMap} */\n        const event = attr.name.slice(1);\n        /** @type {string} */\n        const handlerName = attr.value;\n        /** @type {(event: Event) => void} */\n        const handler =\n          context[handlerName] ||\n          this.templateEngine.evaluate(handlerName, context);\n        if (typeof handler === \"function\") {\n          el.addEventListener(event, handler);\n          el.removeAttribute(attr.name);\n          listeners.push(() => el.removeEventListener(event, handler));\n        }\n      }\n    }\n  }\n\n  /**\n   * Injects scoped styles into the component's container.\n   * The styles are automatically prefixed to prevent style leakage to other components.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element where styles should be injected.\n   * @param {string} compId - The component ID used to identify the style element.\n   * @param {(function(ComponentContext): string)|string} styleDef - The component's style definition (function or string).\n   * @param {ComponentContext} context - The current component context for style interpolation.\n   * @returns {void}\n   */\n  _injectStyles(container, compId, styleDef, context) {\n    /** @type {string} */\n    const newStyle =\n      typeof styleDef === \"function\"\n        ? this.templateEngine.parse(styleDef(context), context)\n        : styleDef;\n\n    /** @type {HTMLStyleElement|null} */\n    let styleEl = container.querySelector(`style[data-e-style=\"${compId}\"]`);\n\n    if (styleEl && styleEl.textContent === newStyle) return;\n    if (!styleEl) {\n      styleEl = document.createElement(\"style\");\n      styleEl.setAttribute(\"data-e-style\", compId);\n      container.appendChild(styleEl);\n    }\n\n    styleEl.textContent = newStyle;\n  }\n\n  /**\n   * Extracts props from an element's attributes that start with the specified prefix.\n   * This method is used to collect component properties from DOM elements.\n   *\n   * @private\n   * @param {HTMLElement} element - The DOM element to extract props from\n   * @returns {Record<string, string>} An object containing the extracted props\n   * @example\n   * // For an element with attributes:\n   * // <div :name=\"John\" :age=\"25\">\n   * // Returns: { name: \"John\", age: \"25\" }\n   */\n  _extractProps(element) {\n    if (!element.attributes) return {};\n\n    const props = {};\n    const attrs = element.attributes;\n\n    for (let i = attrs.length - 1; i >= 0; i--) {\n      const attr = attrs[i];\n      if (attr.name.startsWith(\":\")) {\n        const propName = attr.name.slice(1);\n        props[propName] = attr.value;\n        element.removeAttribute(attr.name);\n      }\n    }\n    return props;\n  }\n\n  /**\n   * Mounts all components within the parent component's container.\n   * This method handles mounting of explicitly defined children components.\n   *\n   * The mounting process follows these steps:\n   * 1. Cleans up any existing component instances\n   * 2. Mounts explicitly defined children components\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount components in\n   * @param {Object<string, ComponentDefinition>} children - Map of selectors to component definitions for explicit children\n   * @param {Array<MountResult>} childInstances - Array to store all mounted component instances\n   * @returns {Promise<void>}\n   *\n   * @example\n   * // Explicit children mounting:\n   * const children = {\n   *   'UserProfile': UserProfileComponent,\n   *   '#settings-panel': \"settings-panel\"\n   * };\n   */\n  async _mountComponents(container, children, childInstances) {\n    for (const [selector, component] of Object.entries(children)) {\n      if (!selector) continue;\n      for (const el of container.querySelectorAll(selector)) {\n        if (!(el instanceof HTMLElement)) continue;\n        /** @type {Record<string, string>} */\n        const props = this._extractProps(el);\n        /** @type {MountResult} */\n        const instance = await this.mount(el, component, props);\n        if (instance && !childInstances.includes(instance)) {\n          childInstances.push(instance);\n        }\n      }\n    }\n  }\n}\n"],"names":["TemplateEngine","parse","template","data","replace","expressionPattern","_","expression","evaluate","fn","_functionCache","get","Function","set","Map","Signal","value","_value","newVal","_notify","watch","_watchers","add","delete","Set","Emitter","on","event","handler","h","_events","off","has","handlers","size","emit","args","SYNC_PROPS","Renderer","patchDOM","container","newHtml","_tempContainer","innerHTML","_diff","oldParent","newParent","firstChild","oldChildren","Array","from","childNodes","newChildren","oldStart","newStart","oldEnd","length","newEnd","keyMap","oldNode","newNode","_isSameNode","_patchNode","_createKeyMap","key","_getNodeKey","matchedNode","nodeName","insertBefore","indexOf","cloneNode","refNode","i","_removeNode","_eleva_instance","nodeType","nodeValue","_updateAttributes","parent","node","hasAttribute","removeChild","oldEl","newEl","attr","attributes","name","getAttribute","setAttribute","newProp","removeAttribute","prop","oldKey","newKey","children","start","end","map","document","createElement","Eleva","use","plugin","options","install","Error","_plugins","result","undefined","component","definition","_components","mount","compName","props","compId","_componentCounter","setup","style","context","emitter","signal","v","processMount","mergedContext","watchers","childInstances","listeners","isMounted","renderScheduled","scheduleRender","queueMicrotask","render","templateResult","html","templateEngine","onBeforeMount","onBeforeUpdate","renderer","_processEvents","_injectStyles","_mountComponents","onMount","onUpdate","val","Object","values","push","instance","unmount","onUnmount","cleanup","child","setupResult","elements","querySelectorAll","el","attrs","startsWith","slice","handlerName","addEventListener","removeEventListener","styleDef","newStyle","styleEl","querySelector","textContent","appendChild","_extractProps","element","propName","selector","entries","HTMLElement","includes","config"],"mappings":"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"}
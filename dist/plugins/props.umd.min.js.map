{"version":3,"file":"props.umd.min.js","sources":["../../src/modules/TemplateEngine.js","../../src/plugins/Props.js"],"sourcesContent":["\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @typedef {Record<string, unknown>} TemplateData\n *           Data context for template interpolation\n */\n\n/**\n * @typedef {string} TemplateString\n *           A string containing {{ expression }} interpolation markers\n */\n\n/**\n * @typedef {string} Expression\n *           A JavaScript expression to be evaluated in the data context\n */\n\n/**\n * @typedef {unknown} EvaluationResult\n *           The result of evaluating an expression (string, number, boolean, object, etc.)\n */\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A secure template engine that handles interpolation and dynamic attribute parsing.\n * Provides a way to evaluate expressions in templates.\n * All methods are static and can be called directly on the class.\n *\n * Template Syntax:\n * - `{{ expression }}` - Interpolate any JavaScript expression\n * - `{{ variable }}` - Access data properties directly\n * - `{{ object.property }}` - Access nested properties\n * - `{{ condition ? a : b }}` - Ternary expressions\n * - `{{ func(arg) }}` - Call functions from data context\n *\n * @example\n * // Basic interpolation\n * const template = \"Hello, {{name}}!\";\n * const data = { name: \"World\" };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Hello, World!\"\n *\n * @example\n * // Nested properties\n * const template = \"Welcome, {{user.name}}!\";\n * const data = { user: { name: \"John\" } };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Welcome, John!\"\n *\n * @example\n * // Expressions\n * const template = \"Status: {{active ? 'Online' : 'Offline'}}\";\n * const data = { active: true };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Status: Online\"\n *\n * @example\n * // With Signal values\n * const template = \"Count: {{count.value}}\";\n * const data = { count: { value: 42 } };\n * const result = TemplateEngine.parse(template, data);\n * // Result: \"Count: 42\"\n */\nexport class TemplateEngine {\n  /**\n   * Regular expression for matching template expressions in the format {{ expression }}\n   * Matches: {{ anything }} with optional whitespace inside braces\n   *\n   * @static\n   * @private\n   * @type {RegExp}\n   */\n  static expressionPattern = /\\{\\{\\s*(.*?)\\s*\\}\\}/g;\n\n  /**\n   * Cache for compiled expression functions.\n   * Stores compiled Function objects keyed by expression string for O(1) lookup.\n   *\n   * @static\n   * @private\n   * @type {Map<string, Function>}\n   */\n  static _functionCache = new Map();\n\n  /**\n   * Parses a template string, replacing expressions with their evaluated values.\n   * Expressions are evaluated in the provided data context.\n   *\n   * @public\n   * @static\n   * @param {TemplateString|unknown} template - The template string to parse.\n   * @param {TemplateData} data - The data context for evaluating expressions.\n   * @returns {string} The parsed template with expressions replaced by their values.\n   *\n   * @example\n   * // Simple variables\n   * TemplateEngine.parse(\"Hello, {{name}}!\", { name: \"World\" });\n   * // Result: \"Hello, World!\"\n   *\n   * @example\n   * // Nested properties\n   * TemplateEngine.parse(\"{{user.name}} is {{user.age}} years old\", {\n   *   user: { name: \"John\", age: 30 }\n   * });\n   * // Result: \"John is 30 years old\"\n   *\n   * @example\n   * // Multiple expressions\n   * TemplateEngine.parse(\"{{greeting}}, {{name}}! You have {{count}} messages.\", {\n   *   greeting: \"Hello\",\n   *   name: \"User\",\n   *   count: 5\n   * });\n   * // Result: \"Hello, User! You have 5 messages.\"\n   *\n   * @example\n   * // With conditionals\n   * TemplateEngine.parse(\"Status: {{online ? 'Active' : 'Inactive'}}\", {\n   *   online: true\n   * });\n   * // Result: \"Status: Active\"\n   */\n  static parse(template, data) {\n    if (typeof template !== \"string\") return template;\n    return template.replace(this.expressionPattern, (_, expression) =>\n      this.evaluate(expression, data)\n    );\n  }\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   *\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   * The use of the `with` statement is necessary for expression evaluation but has security implications.\n   * Only use with trusted templates. User input should never be directly interpolated.\n   *\n   * @public\n   * @static\n   * @param {Expression|unknown} expression - The expression to evaluate.\n   * @param {TemplateData} data - The data context for evaluation.\n   * @returns {EvaluationResult} The result of the evaluation, or empty string if evaluation fails.\n   *\n   * @example\n   * // Property access\n   * TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } });\n   * // Result: \"John\"\n   *\n   * @example\n   * // Numeric values\n   * TemplateEngine.evaluate(\"user.age\", { user: { age: 30 } });\n   * // Result: 30\n   *\n   * @example\n   * // Expressions\n   * TemplateEngine.evaluate(\"items.length > 0\", { items: [1, 2, 3] });\n   * // Result: true\n   *\n   * @example\n   * // Function calls\n   * TemplateEngine.evaluate(\"formatDate(date)\", {\n   *   date: new Date(),\n   *   formatDate: (d) => d.toISOString()\n   * });\n   * // Result: \"2024-01-01T00:00:00.000Z\"\n   *\n   * @example\n   * // Failed evaluation returns empty string\n   * TemplateEngine.evaluate(\"nonexistent.property\", {});\n   * // Result: \"\"\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    let fn = this._functionCache.get(expression);\n    if (!fn) {\n      try {\n        fn = new Function(\"data\", `with(data) { return ${expression}; }`);\n        this._functionCache.set(expression, fn);\n      } catch {\n        return \"\";\n      }\n    }\n    try {\n      return fn(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\n\n/**\n * @class ðŸŽ¯ PropsPlugin\n * @classdesc A plugin that extends Eleva's props data handling to support any type of data structure\n * with automatic type detection, parsing, and reactive prop updates. This plugin enables seamless\n * passing of complex data types from parent to child components without manual parsing.\n *\n * Core Features:\n * - Automatic type detection and parsing (strings, numbers, booleans, objects, arrays, dates, etc.)\n * - Support for complex data structures including nested objects and arrays\n * - Reactive props that automatically update when parent data changes\n * - Comprehensive error handling with custom error callbacks\n * - Simple configuration with minimal setup required\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(PropsPlugin, {\n *   enableAutoParsing: true,\n *   enableReactivity: true,\n *   onError: (error, value) => {\n *     console.error('Props parsing error:', error, value);\n *   }\n * });\n *\n * // Use complex props in components\n * app.component(\"UserCard\", {\n *   template: (ctx) => `\n *     <div class=\"user-info-container\"\n *          :user='${JSON.stringify(ctx.user.value)}'\n *          :permissions='${JSON.stringify(ctx.permissions.value)}'\n *          :settings='${JSON.stringify(ctx.settings.value)}'>\n *     </div>\n *   `,\n *   children: {\n *     '.user-info-container': 'UserInfo'\n *   }\n * });\n *\n * app.component(\"UserInfo\", {\n *   setup({ props }) {\n *     return {\n *       user: props.user,        // Automatically parsed object\n *       permissions: props.permissions,  // Automatically parsed array\n *       settings: props.settings  // Automatically parsed object\n *     };\n *   }\n * });\n */\nexport const PropsPlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"props\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.0.0-rc.12\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description:\n    \"Advanced props data handling for complex data structures with automatic type detection and reactivity\",\n\n  /**\n   * Installs the plugin into the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   * @param {Object} options - Plugin configuration options\n   * @param {boolean} [options.enableAutoParsing=true] - Enable automatic type detection and parsing\n   * @param {boolean} [options.enableReactivity=true] - Enable reactive prop updates using Eleva's signal system\n   * @param {Function} [options.onError=null] - Error handler function called when parsing fails\n   *\n   * @example\n   * // Basic installation\n   * app.use(PropsPlugin);\n   *\n   * // Installation with custom options\n   * app.use(PropsPlugin, {\n   *   enableAutoParsing: true,\n   *   enableReactivity: false,\n   *   onError: (error, value) => {\n   *     console.error('Props parsing error:', error, value);\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      enableAutoParsing = true,\n      enableReactivity = true,\n      onError = null,\n    } = options;\n\n    /**\n     * Detects the type of a given value\n     * @private\n     * @param {any} value - The value to detect type for\n     * @returns {string} The detected type ('string', 'number', 'boolean', 'object', 'array', 'date', 'map', 'set', 'function', 'null', 'undefined', 'unknown')\n     *\n     * @example\n     * detectType(\"hello\")     // â†’ \"string\"\n     * detectType(42)          // â†’ \"number\"\n     * detectType(true)        // â†’ \"boolean\"\n     * detectType([1, 2, 3])   // â†’ \"array\"\n     * detectType({})          // â†’ \"object\"\n     * detectType(new Date())  // â†’ \"date\"\n     * detectType(null)        // â†’ \"null\"\n     */\n    const detectType = (value) => {\n      if (value === null) return \"null\";\n      if (value === undefined) return \"undefined\";\n      if (typeof value === \"boolean\") return \"boolean\";\n      if (typeof value === \"number\") return \"number\";\n      if (typeof value === \"string\") return \"string\";\n      if (typeof value === \"function\") return \"function\";\n      if (value instanceof Date) return \"date\";\n      if (value instanceof Map) return \"map\";\n      if (value instanceof Set) return \"set\";\n      if (Array.isArray(value)) return \"array\";\n      if (typeof value === \"object\") return \"object\";\n      return \"unknown\";\n    };\n\n    /**\n     * Parses a prop value with automatic type detection\n     * @private\n     * @param {any} value - The value to parse\n     * @returns {any} The parsed value with appropriate type\n     *\n     * @description\n     * This function automatically detects and parses different data types from string values:\n     * - Special strings: \"true\" â†’ true, \"false\" â†’ false, \"null\" â†’ null, \"undefined\" â†’ undefined\n     * - JSON objects/arrays: '{\"key\": \"value\"}' â†’ {key: \"value\"}, '[1, 2, 3]' â†’ [1, 2, 3]\n     * - Boolean-like strings: \"1\" â†’ true, \"0\" â†’ false, \"\" â†’ true\n     * - Numeric strings: \"42\" â†’ 42, \"3.14\" â†’ 3.14\n     * - Date strings: \"2023-01-01T00:00:00.000Z\" â†’ Date object\n     * - Other strings: returned as-is\n     *\n     * @example\n     * parsePropValue(\"true\")           // â†’ true\n     * parsePropValue(\"42\")             // â†’ 42\n     * parsePropValue('{\"key\": \"val\"}') // â†’ {key: \"val\"}\n     * parsePropValue('[1, 2, 3]')      // â†’ [1, 2, 3]\n     * parsePropValue(\"hello\")          // â†’ \"hello\"\n     */\n    const parsePropValue = (value) => {\n      try {\n        // Handle non-string values - return as-is\n        if (typeof value !== \"string\") {\n          return value;\n        }\n\n        // Handle special string patterns first\n        if (value === \"true\") return true;\n        if (value === \"false\") return false;\n        if (value === \"null\") return null;\n        if (value === \"undefined\") return undefined;\n\n        // Try to parse as JSON (for objects and arrays)\n        // This handles complex data structures like objects and arrays\n        if (value.startsWith(\"{\") || value.startsWith(\"[\")) {\n          try {\n            return JSON.parse(value);\n          } catch (e) {\n            // Not valid JSON, throw error to trigger error handler\n            throw new Error(`Invalid JSON: ${value}`);\n          }\n        }\n\n        // Handle boolean-like strings (including \"1\" and \"0\")\n        // These are common in HTML attributes and should be treated as booleans\n        if (value === \"1\") return true;\n        if (value === \"0\") return false;\n        if (value === \"\") return true; // Empty string is truthy in HTML attributes\n\n        // Handle numeric strings (after boolean check to avoid conflicts)\n        // This ensures \"0\" is treated as boolean false, not number 0\n        if (!isNaN(value) && value !== \"\" && !isNaN(parseFloat(value))) {\n          return Number(value);\n        }\n\n        // Handle date strings (ISO format)\n        // Recognizes standard ISO date format and converts to Date object\n        if (value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/)) {\n          const date = new Date(value);\n          if (!isNaN(date.getTime())) {\n            return date;\n          }\n        }\n\n        // Return as string if no other parsing applies\n        // This is the fallback for regular text strings\n        return value;\n      } catch (error) {\n        // Call error handler if provided\n        if (onError) {\n          onError(error, value);\n        }\n        // Fallback to original value to prevent breaking the application\n        return value;\n      }\n    };\n\n    /**\n     * Enhanced props extraction with automatic type detection\n     * @private\n     * @param {HTMLElement} element - The DOM element to extract props from\n     * @returns {Object} Object containing parsed props with appropriate types\n     *\n     * @description\n     * Extracts props from DOM element attributes that start with \":\" and automatically\n     * parses them to their appropriate types. Removes the attributes from the element\n     * after extraction.\n     *\n     * @example\n     * // HTML: <div :name=\"John\" :age=\"30\" :active=\"true\" :data='{\"key\": \"value\"}'></div>\n     * const props = extractProps(element);\n     * // Result: { name: \"John\", age: 30, active: true, data: {key: \"value\"} }\n     */\n    const extractProps = (element) => {\n      const props = {};\n      const attrs = element.attributes;\n\n      // Iterate through attributes in reverse order to handle removal correctly\n      for (let i = attrs.length - 1; i >= 0; i--) {\n        const attr = attrs[i];\n        // Only process attributes that start with \":\" (prop attributes)\n        if (attr.name.startsWith(\":\")) {\n          const propName = attr.name.slice(1); // Remove the \":\" prefix\n          // Parse the value if auto-parsing is enabled, otherwise use as-is\n          const parsedValue = enableAutoParsing\n            ? parsePropValue(attr.value)\n            : attr.value;\n          props[propName] = parsedValue;\n          // Remove the attribute from the DOM element after extraction\n          element.removeAttribute(attr.name);\n        }\n      }\n\n      return props;\n    };\n\n    /**\n     * Creates reactive props using Eleva's signal system\n     * @private\n     * @param {Object} props - The props object to make reactive\n     * @returns {Object} Object containing reactive props (Eleva signals)\n     *\n     * @description\n     * Converts regular prop values into Eleva signals for reactive updates.\n     * If a value is already a signal, it's passed through unchanged.\n     *\n     * @example\n     * const props = { name: \"John\", age: 30, active: true };\n     * const reactiveProps = createReactiveProps(props);\n     * // Result: {\n     * //   name: Signal(\"John\"),\n     * //   age: Signal(30),\n     * //   active: Signal(true)\n     * // }\n     */\n    const createReactiveProps = (props) => {\n      const reactiveProps = {};\n\n      // Convert each prop value to a reactive signal\n      Object.entries(props).forEach(([key, value]) => {\n        // Check if value is already a signal (has 'value' and 'watch' properties)\n        if (\n          value &&\n          typeof value === \"object\" &&\n          \"value\" in value &&\n          \"watch\" in value\n        ) {\n          // Value is already a signal, use it as-is\n          reactiveProps[key] = value;\n        } else {\n          // Create new signal for the prop value to make it reactive\n          reactiveProps[key] = new eleva.signal(value);\n        }\n      });\n\n      return reactiveProps;\n    };\n\n    // Override Eleva's internal _extractProps method with our enhanced version\n    eleva._extractProps = extractProps;\n\n    // Override Eleva's mount method to apply enhanced prop handling\n    const originalMount = eleva.mount;\n    eleva.mount = async (container, compName, props = {}) => {\n      // Create reactive props if reactivity is enabled\n      const enhancedProps = enableReactivity\n        ? createReactiveProps(props)\n        : props;\n\n      // Call the original mount method with enhanced props\n      return await originalMount.call(\n        eleva,\n        container,\n        compName,\n        enhancedProps\n      );\n    };\n\n    // Override Eleva's _mountComponents method to enable signal reference passing\n    const originalMountComponents = eleva._mountComponents;\n\n    // Cache to store parent contexts by container element\n    const parentContextCache = new WeakMap();\n    // Store child instances that need signal linking\n    const pendingSignalLinks = new Set();\n\n    eleva._mountComponents = async (container, children, childInstances) => {\n      for (const [selector, component] of Object.entries(children)) {\n        if (!selector) continue;\n        for (const el of container.querySelectorAll(selector)) {\n          if (!(el instanceof HTMLElement)) continue;\n\n          // Extract props from DOM attributes\n          const extractedProps = eleva._extractProps(el);\n\n          // Get parent context to check for signal references\n          let enhancedProps = extractedProps;\n\n          // Try to find parent context by looking up the DOM tree\n          let parentContext = parentContextCache.get(container);\n          if (!parentContext) {\n            let currentElement = container;\n            while (currentElement && !parentContext) {\n              if (\n                currentElement._eleva_instance &&\n                currentElement._eleva_instance.data\n              ) {\n                parentContext = currentElement._eleva_instance.data;\n                // Cache the parent context for future use\n                parentContextCache.set(container, parentContext);\n                break;\n              }\n              currentElement = currentElement.parentElement;\n            }\n          }\n\n          if (enableReactivity && parentContext) {\n            const signalProps = {};\n\n            // Check each extracted prop to see if there's a matching signal in parent context\n            Object.keys(extractedProps).forEach((propName) => {\n              if (\n                parentContext[propName] &&\n                parentContext[propName] instanceof eleva.signal\n              ) {\n                // Found a signal in parent context with the same name as the prop\n                // Pass the signal reference instead of creating a new one\n                signalProps[propName] = parentContext[propName];\n              }\n            });\n\n            // Merge signal props with regular props (signal props take precedence)\n            enhancedProps = {\n              ...extractedProps,\n              ...signalProps,\n            };\n          }\n\n          // Create reactive props for non-signal props only\n          let finalProps = enhancedProps;\n          if (enableReactivity) {\n            // Only create reactive props for values that aren't already signals\n            const nonSignalProps = {};\n            Object.entries(enhancedProps).forEach(([key, value]) => {\n              if (\n                !(\n                  value &&\n                  typeof value === \"object\" &&\n                  \"value\" in value &&\n                  \"watch\" in value\n                )\n              ) {\n                // This is not a signal, create a reactive prop for it\n                nonSignalProps[key] = value;\n              }\n            });\n\n            // Create reactive props only for non-signal values\n            const reactiveNonSignalProps = createReactiveProps(nonSignalProps);\n\n            // Merge signal props with reactive non-signal props\n            finalProps = {\n              ...reactiveNonSignalProps,\n              ...enhancedProps, // Signal props take precedence\n            };\n          }\n\n          /** @type {MountResult} */\n          const instance = await eleva.mount(el, component, finalProps);\n          if (instance && !childInstances.includes(instance)) {\n            childInstances.push(instance);\n\n            // If we have extracted props but no parent context yet, mark for later signal linking\n            if (\n              enableReactivity &&\n              Object.keys(extractedProps).length > 0 &&\n              !parentContext\n            ) {\n              pendingSignalLinks.add({\n                instance,\n                extractedProps,\n                container,\n                component,\n              });\n            }\n          }\n        }\n      }\n\n      // After mounting all children, try to link signals for pending instances\n      if (enableReactivity && pendingSignalLinks.size > 0) {\n        for (const pending of pendingSignalLinks) {\n          const { instance, extractedProps, container, component } = pending;\n\n          // Try to find parent context again\n          let parentContext = parentContextCache.get(container);\n          if (!parentContext) {\n            let currentElement = container;\n            while (currentElement && !parentContext) {\n              if (\n                currentElement._eleva_instance &&\n                currentElement._eleva_instance.data\n              ) {\n                parentContext = currentElement._eleva_instance.data;\n                parentContextCache.set(container, parentContext);\n                break;\n              }\n              currentElement = currentElement.parentElement;\n            }\n          }\n\n          if (parentContext) {\n            const signalProps = {};\n\n            // Check each extracted prop to see if there's a matching signal in parent context\n            Object.keys(extractedProps).forEach((propName) => {\n              if (\n                parentContext[propName] &&\n                parentContext[propName] instanceof eleva.signal\n              ) {\n                signalProps[propName] = parentContext[propName];\n              }\n            });\n\n            // Update the child instance's data with signal references\n            if (Object.keys(signalProps).length > 0) {\n              Object.assign(instance.data, signalProps);\n\n              // Create a batched render function for this child instance\n              // This ensures multiple signal changes result in a single render\n              let renderScheduled = false;\n              const childComponent =\n                eleva._components.get(component) || component;\n\n              const scheduleChildRender = () => {\n                if (renderScheduled) return;\n                renderScheduled = true;\n                queueMicrotask(() => {\n                  renderScheduled = false;\n                  if (childComponent && childComponent.template) {\n                    const templateResult =\n                      typeof childComponent.template === \"function\"\n                        ? childComponent.template(instance.data)\n                        : childComponent.template;\n                    const newHtml = TemplateEngine.parse(\n                      templateResult,\n                      instance.data\n                    );\n                    eleva.renderer.patchDOM(instance.container, newHtml);\n                  }\n                });\n              };\n\n              // Set up signal watchers for the newly linked signals\n              Object.keys(signalProps).forEach((propName) => {\n                const signal = signalProps[propName];\n                if (signal && typeof signal.watch === \"function\") {\n                  // Use batched render instead of direct patchDOM\n                  signal.watch(scheduleChildRender);\n                }\n              });\n\n              // Initial render to show the correct signal values\n              if (childComponent && childComponent.template) {\n                const templateResult =\n                  typeof childComponent.template === \"function\"\n                    ? childComponent.template(instance.data)\n                    : childComponent.template;\n                const newHtml = TemplateEngine.parse(\n                  templateResult,\n                  instance.data\n                );\n                eleva.renderer.patchDOM(instance.container, newHtml);\n              }\n            }\n\n            // Remove from pending list\n            pendingSignalLinks.delete(pending);\n          }\n        }\n      }\n    };\n\n    /**\n     * Expose utility methods on the Eleva instance\n     * @namespace eleva.props\n     */\n    eleva.props = {\n      /**\n       * Parse a single value with automatic type detection\n       * @param {any} value - The value to parse\n       * @returns {any} The parsed value with appropriate type\n       *\n       * @example\n       * app.props.parse(\"42\")             // â†’ 42\n       * app.props.parse(\"true\")           // â†’ true\n       * app.props.parse('{\"key\": \"val\"}') // â†’ {key: \"val\"}\n       */\n      parse: (value) => {\n        // Return value as-is if auto parsing is disabled\n        if (!enableAutoParsing) {\n          return value;\n        }\n        // Use our enhanced parsing function\n        return parsePropValue(value);\n      },\n\n      /**\n       * Detect the type of a value\n       * @param {any} value - The value to detect type for\n       * @returns {string} The detected type\n       *\n       * @example\n       * app.props.detectType(\"hello\")     // â†’ \"string\"\n       * app.props.detectType(42)          // â†’ \"number\"\n       * app.props.detectType([1, 2, 3])   // â†’ \"array\"\n       */\n      detectType,\n    };\n\n    // Store original methods for uninstall\n    eleva._originalExtractProps = eleva._extractProps;\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   *\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   *\n   * @example\n   * // Uninstall the plugin\n   * PropsPlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original _extractProps method\n    if (eleva._originalExtractProps) {\n      eleva._extractProps = eleva._originalExtractProps;\n      delete eleva._originalExtractProps;\n    }\n\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove plugin utility methods\n    if (eleva.props) {\n      delete eleva.props;\n    }\n  },\n};\n\n// Short name export for convenience\nexport { PropsPlugin as Props };\n"],"names":["TemplateEngine","parse","template","data","replace","expressionPattern","_","expression","evaluate","fn","_functionCache","get","Function","set","Map","PropsPlugin","name","version","description","install","eleva","options","enableAutoParsing","enableReactivity","onError","parsePropValue","value","startsWith","JSON","e","Error","isNaN","parseFloat","Number","match","date","Date","getTime","error","createReactiveProps","props","reactiveProps","Object","entries","forEach","key","signal","_extractProps","element","attrs","attributes","i","length","attr","propName","slice","parsedValue","removeAttribute","originalMount","mount","container","compName","enhancedProps","call","originalMountComponents","_mountComponents","parentContextCache","WeakMap","pendingSignalLinks","Set","children","childInstances","selector","component","el","querySelectorAll","HTMLElement","extractedProps","parentContext","currentElement","_eleva_instance","parentElement","signalProps","keys","finalProps","nonSignalProps","instance","includes","push","add","size","pending","assign","renderScheduled","childComponent","_components","scheduleChildRender","queueMicrotask","templateResult","newHtml","renderer","patchDOM","watch","delete","detectType","undefined","Array","isArray","_originalExtractProps","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
# Eleva.js Test Suite

This directory contains comprehensive tests for the Eleva.js framework, ensuring reliability, stability, and performance of the core functionality and modules.

## ğŸ“ Test Structure

The test suite is organized into logical categories to maintain clarity and facilitate targeted testing:

```
test/
â”œâ”€â”€ unit/                  # Unit tests for individual components
â”‚   â”œâ”€â”€ core/              # Tests for core functionality
â”‚   â”‚   â””â”€â”€ Eleva.test.js  # Tests for the main Eleva class
â”‚   â””â”€â”€ modules/           # Tests for individual modules
â”‚       â”œâ”€â”€ Emitter.test.js
â”‚       â”œâ”€â”€ Renderer.test.js
â”‚       â”œâ”€â”€ Signal.test.js
â”‚       â””â”€â”€ TemplateEngine.test.js
â”œâ”€â”€ performance/           # Performance benchmarks
â”‚   â””â”€â”€ templates.performance.test.js
â”œâ”€â”€ coverage/              # Test coverage reports generated by Jest
â””â”€â”€ setup/                 # Test utilities and setup files
```

## ğŸš€ Running Tests

```bash
# Run all tests
npm test

# Run with coverage report
npm test -- --coverage

# Run specific test categories
npm test -- --testPathPattern=unit
npm test -- --testPathPattern=performance

# Run specific module tests
npm test -- --testPathPattern=unit/modules/Signal

# Run tests in watch mode (automatically re-runs on file changes)
npm test -- --watch

# Run a specific test file
npm test -- path/to/test.js
```

## ğŸ“ Writing Tests for Eleva.js

### Test File Structure

Each test file should follow this general structure:

```javascript
/**
 * @fileoverview Tests for the [Module] of the Eleva framework
 *
 * These tests verify [key functionality]...
 *
 * @author [Your Name]
 * @see {@link https://github.com/tarekraafat/eleva|Eleva.js Repository}
 * @requires module:eleva/[path/to/module]
 * @category Unit|Performance
 * @group [functional group]
 */

import { ModuleName } from "../../../src/modules/ModuleName.js";

/**
 * Tests for [specific aspect of functionality]
 *
 * @group [functional group]
 */
describe("ModuleName", () => {
  // Setup code
  let instance;
  
  beforeEach(() => {
    // Initialize test environment
    instance = new ModuleName();
  });
  
  /**
   * Tests [specific behavior]
   *
   * Verifies:
   * - [Verification point 1]
   * - [Verification point 2]
   *
   * @group [sub-group]
   */
  test("specific behavior works correctly", () => {
    // Arrange
    const input = "test";
    
    // Act
    const result = instance.method(input);
    
    // Assert
    expect(result).toBe("expected output");
  });
});
```

### Test Categories

When writing tests, tag them appropriately with `@group` tags to facilitate filtering and organization:

```javascript
/**
 * @group core         // Core framework functionality
 * @group modules      // Module-specific tests
 * @group rendering    // Rendering and DOM manipulation
 * @group reactivity   // Reactive state management
 * @group performance  // Performance benchmarks
 * @group edge-cases   // Edge case handling
 * @group error-handling // Error conditions
 */
```

### Best Practices for Testing Eleva.js

#### 1. Test Isolation

Each test should be independent of other tests. This is achieved by:

- Using `beforeEach` to set up a fresh test environment
- Cleaning up DOM elements after tests
- Avoiding shared state between tests

```javascript
beforeEach(() => {
  document.body.innerHTML = `<div id="app"></div>`;
  appContainer = document.getElementById("app");
  app = new Eleva("TestApp");
});

afterEach(() => {
  document.body.innerHTML = '';
});
```

#### 2. Testing Reactivity

When testing reactive components, remember that updates are often asynchronous:

```javascript
test("signal value change triggers watcher", async () => {
  const signal = new Signal(0);
  const callback = jest.fn();
  
  signal.watch(callback);
  signal.value = 10;
  
  // Wait for the update to process
  await Promise.resolve();
  
  expect(callback).toHaveBeenCalledWith(10);
});
```

#### 3. Testing DOM Updates

When testing DOM updates, verify the actual DOM state rather than implementation details:

```javascript
test("component renders correctly", async () => {
  const component = {
    setup: ({ signal }) => ({ count: signal(0) }),
    template: (ctx) => `<div>${ctx.count.value}</div>`
  };
  
  app.component("counter", component);
  await app.mount(appContainer, "counter");
  
  expect(appContainer.innerHTML).toContain("<div>0</div>");
});
```

#### 4. Performance Testing

Performance tests should:

- Set clear benchmarks with reasonable thresholds
- Measure key operations that impact user experience
- Avoid timing variability from environmental factors

```javascript
test("template parser is fast for large templates", () => {
  const items = Array(1000).fill().map((_, i) => ({ id: i }));
  const template = items.map(i => `<div>{{ items[${i.id}].id }}</div>`).join("");
  
  const start = performance.now();
  TemplateEngine.parse(template, { items });
  const end = performance.now();
  
  expect(end - start).toBeLessThan(50); // Under 50ms
});
```

#### 5. Edge Cases

Test edge cases thoroughly, especially for:

- Empty or null inputs
- Boundary conditions
- Error states
- Circular references
- Extreme values

```javascript
describe("Signal edge cases", () => {
  test("handles undefined initial value", () => {
    const signal = new Signal();
    expect(signal.value).toBeUndefined();
  });

  test("handles circular references", () => {
    const obj = {};
    obj.self = obj;
    const signal = new Signal(obj);
    
    expect(() => signal.watch(() => {})).not.toThrow();
  });
});
```

## ğŸ“‹ Test Coverage

The test suite aims to maintain high coverage of the codebase to ensure reliability and stability:

- **Statements**: Target > 95%
- **Branches**: Target > 90%
- **Functions**: Target > 95%
- **Lines**: Target > 95%

Coverage reports are generated in the coverage directory after running tests with the `--coverage` flag.

### Interpreting Coverage Reports

- Browse the HTML coverage report in index.html
- Look for uncovered branches and edge cases
- Prioritize testing critical paths and user-facing features

## ğŸ“Š Performance Benchmarking

Performance tests are critical for ensuring Eleva.js maintains its lightweight and efficient nature. When writing performance tests:

1. Establish measurable benchmarks
2. Create realistic scenarios with appropriate scale
3. Use consistent environment for comparable results
4. Set realistic thresholds that balance precision with environmental variation

```javascript
test("diffing algorithm scales efficiently", () => {
  // Arrange: Create DOM structures of increasing size
  const sizes = [10, 100, 1000];
  const times = [];
  
  // Act: Measure time for each size
  sizes.forEach(size => {
    const oldDom = createDomStructure(size);
    const newDom = createModifiedDomStructure(size);
    
    const start = performance.now();
    renderer.diff(oldDom, newDom);
    const end = performance.now();
    
    times.push(end - start);
  });
  
  // Assert: Time should scale sublinearly (better than O(n))
  // If time[1]/time[0] > size[1]/size[0], scaling is worse than linear
  const scalingFactor = (times[1] / times[0]) / (sizes[1] / sizes[0]);
  expect(scalingFactor).toBeLessThan(1);
});
```

## ğŸ” Testing Core Components

### 1. Testing the Signal Module

The Signal module provides reactivity in Eleva.js. Test it for:

- Value initialization and updating
- Change detection optimization
- Watcher notification
- Multiple watchers on the same signal
- Unsubscribe functionality
- Memory leaks (unsubscribed watchers should be garbage collected)

### 2. Testing the Template Engine

The TemplateEngine handles string interpolation and expression evaluation:

- Basic variable interpolation
- JavaScript expression evaluation
- Nested property access
- Array and object traversal
- Error handling for invalid or missing properties
- Security (prevent code injection)

### 3. Testing the Renderer

The Renderer is responsible for efficient DOM updates:

- Correct DOM element creation
- Attribute synchronization
- Efficient diffing algorithm
- Minimizing DOM operations
- Handling different node types
- Special attribute handling (e.g., event handlers)

### 4. Testing the Emitter

The Emitter provides the event system:

- Event registration
- Event emission
- Multiple listeners per event
- Listener removal
- Memory management (no leaks from removed listeners)

### 5. Testing the Core Framework

Test the main Eleva class for:

- Component registration
- Component mounting and lifecycle
- Parent-child component relationships
- Props passing
- State management
- Style handling
- Plugin system

## ğŸ§ª Mock and Fixture Utilities

For consistent testing, use the provided utilities:

```javascript
// Create a mock DOM environment
const { createDomEnvironment } = require('../setup/test-utils');
const { dom, cleanup } = createDomEnvironment();

// Create component fixtures
const { createComponentFixture } = require('../setup/component-fixtures');
const counterComponent = createComponentFixture({
  name: 'counter',
  initialState: { count: 0 },
  template: ctx => `<div>${ctx.count}</div>`
});
```

## ğŸ”„ Continuous Integration

Our test suite is integrated with CI workflows to ensure consistent quality:

- Tests run on every pull request
- Tests run against multiple Node.js versions
- Performance benchmarks are tracked over time
- Test coverage is reported to maintain high standards

## ğŸ¤ Contributing Tests

When contributing new tests:

1. Follow the existing file structure and naming conventions
2. Include comprehensive JSDoc documentation
3. Test both normal operation and edge cases
4. Ensure tests are isolated and don't depend on other tests
5. Verify your tests pass consistently, not just occasionally
6. For performance tests, ensure thresholds are reasonable across environments

## ğŸ’¡ Debugging Tests

If you encounter failing tests:

1. Run the specific failing test in isolation
2. Use `console.log` or debugger statements to trace execution
3. Check for asynchronous operations that might need `await`
4. Examine the test environment setup
5. Look for side effects from other tests
6. Check if DOM elements are properly cleaned up between tests

```javascript
// Debug a specific test
npm test -- --testPathPattern=Signal --testNamePattern="watcher is triggered"
```

## ğŸ“š Resources

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Testing DOM Manipulation](https://jestjs.io/docs/tutorial-jquery)
- [Eleva.js Documentation](https://github.com/tarekraafat/eleva)
- [Performance Testing Best Practices](https://web.dev/metrics/)

---

By maintaining comprehensive tests, we ensure Eleva.js remains reliable, efficient, and robust across all use cases.
/*! Eleva Router Plugin v1.0.0-rc.1 | MIT License | https://elevajs.com */
var t,e;t=this,e=function(t){"use strict";const e={handle(t,e,r={}){const n=new Error(`[ElevaRouter] ${e}: ${t.message}`);throw n.originalError=t,n.context=e,n.details=r,n},warn(t,e={}){},log(t,e,r={}){}};class r{constructor(t,r={}){this.eleva=t,this.options={mode:"hash",queryParam:"view",viewSelector:"root",...r},this.routes=this._processRoutes(r.routes||[]),this.emitter=this.eleva.emitter,this.isStarted=!1,this._isNavigating=!1,this.eventListeners=[],this.currentRoute=new this.eleva.signal(null),this.previousRoute=new this.eleva.signal(null),this.currentParams=new this.eleva.signal({}),this.currentQuery=new this.eleva.signal({}),this.currentLayout=new this.eleva.signal(null),this.currentView=new this.eleva.signal(null),this.plugins=new Map,this.errorHandler=e,this._validateOptions()}_validateOptions(){["hash","query","history"].includes(this.options.mode)||this.errorHandler.handle(new Error(`Invalid routing mode: ${this.options.mode}. Must be "hash", "query", or "history".`),"Configuration validation failed")}_processRoutes(t){const e=[];for(const r of t)try{e.push({...r,segments:this._parsePathIntoSegments(r.path)})}catch(t){this.errorHandler.warn(`Invalid path in route definition "${r.path||"undefined"}": ${t.message}`,{route:r,error:t})}return e}_parsePathIntoSegments(t){t&&"string"==typeof t||this.errorHandler.handle(new Error("Route path must be a non-empty string"),"Path parsing failed",{path:t});const e=t.replace(/\/+/g,"/").replace(/\/$/,"")||"/";return"/"===e?[]:e.split("/").filter(Boolean).map(e=>{if(e.startsWith(":")){const r=e.substring(1);return r||this.errorHandler.handle(new Error(`Invalid parameter segment: ${e}`),"Path parsing failed",{segment:e,path:t}),{type:"param",name:r}}return{type:"static",value:e}})}_findViewElement(t){const e=this.options.viewSelector;return t.querySelector(`#${e}`)||t.querySelector(`.${e}`)||t.querySelector(`[data-${e}]`)||t.querySelector(e)||t}async start(){if(this.isStarted)return void this.errorHandler.warn("Router is already started");if("undefined"==typeof window)return void this.errorHandler.warn("Router start skipped: `window` object not available (SSR environment)");if("undefined"!=typeof document&&!document.querySelector(this.options.mount))return void this.errorHandler.warn(`Mount element "${this.options.mount}" was not found in the DOM. The router will not start.`,{mountSelector:this.options.mount});const t=()=>this._handleRouteChange();"hash"===this.options.mode?(window.addEventListener("hashchange",t),this.eventListeners.push(()=>window.removeEventListener("hashchange",t))):(window.addEventListener("popstate",t),this.eventListeners.push(()=>window.removeEventListener("popstate",t))),this.isStarted=!0,await this._handleRouteChange()}async destroy(){if(this.isStarted){for(const t of this.plugins.values())if("function"==typeof t.destroy)try{await t.destroy(this)}catch(e){this.errorHandler.log(`Plugin ${t.name} destroy failed`,e)}this.eventListeners.forEach(t=>t()),this.eventListeners=[],this.currentLayout.value&&await this.currentLayout.value.unmount(),this.isStarted=!1}}async navigate(t,e={}){try{const r="string"==typeof t?{path:t,params:e}:t;let n=this._buildPath(r.path,r.params||{});const o=r.query||{};if(Object.keys(o).length>0){const t=new URLSearchParams(o).toString();t&&(n+=`?${t}`)}if(this._isSameRoute(n,r.params,o))return;if(await this._proceedWithNavigation(n)){this._isNavigating=!0;const t=r.state||{},e=r.replace||!1,o=e?"replaceState":"pushState";if("hash"===this.options.mode)if(e){const e=`${window.location.pathname}${window.location.search}#${n}`;window.history.replaceState(t,"",e)}else window.location.hash=n;else{const e="query"===this.options.mode?this._buildQueryUrl(n):n;history[o](t,"",e)}queueMicrotask(()=>{this._isNavigating=!1})}}catch(t){this.errorHandler.log("Navigation failed",t),await this.emitter.emit("router:onError",t)}}_buildQueryUrl(t){const e=new URLSearchParams(window.location.search);return e.set(this.options.queryParam,t.split("?")[0]),`${window.location.pathname}?${e.toString()}`}_isSameRoute(t,e,r){const n=this.currentRoute.value;if(!n)return!1;const[o,i]=t.split("?"),a=r||this._parseQuery(i||"");return n.path===o&&JSON.stringify(n.params)===JSON.stringify(e||{})&&JSON.stringify(n.query)===JSON.stringify(a)}_buildPath(t,e){let r=t;for(const[t,n]of Object.entries(e)){const e=encodeURIComponent(String(n));r=r.replace(new RegExp(`:${t}\\b`,"g"),e)}return r}async _handleRouteChange(){if(this._isNavigating)return;const t=this.currentRoute.value,e=this._getCurrentLocation();!await this._proceedWithNavigation(e.fullUrl)&&t&&this.navigate({path:t.path,query:t.query,replace:!0})}async _proceedWithNavigation(t){const e=this.currentRoute.value,[r,n]=(t||"/").split("?"),o={path:r.startsWith("/")?r:`/${r}`,query:this._parseQuery(n),fullUrl:t};let i=this._matchRoute(o.path);if(!i){const t=this.routes.find(t=>"*"===t.path);if(!t)return await this.emitter.emit("router:onError",new Error(`Route not found: ${o.path}`),o,e),!1;i={route:t,params:{pathMatch:o.path.substring(1)}}}const a={...o,params:i.params,meta:i.route.meta||{},name:i.route.name,matched:i.route};try{if(!await this._runGuards(a,e,i.route))return!1;const{layoutComponent:t,pageComponent:r}=await this._resolveComponents(i.route);if(e){const t=async t=>{if(t)try{await t.unmount()}catch(e){this.errorHandler.warn("Error during component unmount",{error:e,instance:t})}};(i.route.layout||this.options.globalLayout)!==(e.matched.layout||this.options.globalLayout)?(await t(this.currentLayout.value),this.currentLayout.value=null):(await t(this.currentView.value),this.currentView.value=null),e.matched.afterLeave&&(await e.matched.afterLeave(a,e),await this.emitter.emit("router:afterLeave",a,e))}return this.previousRoute.value=e,this.currentRoute.value=a,this.currentParams.value=a.params||{},this.currentQuery.value=a.query||{},await this._render(t,r,a),i.route.afterEnter&&(await i.route.afterEnter(a,e),await this.emitter.emit("router:afterEnter",a,e)),await this.emitter.emit("router:afterEach",a,e),!0}catch(t){return this.errorHandler.log("Error during navigation",t,{to:a,from:e}),await this.emitter.emit("router:onError",t,a,e),!1}}async _runGuards(t,e,r){const n=[...this.options.onBeforeEach?[this.options.onBeforeEach]:[],...e&&e.matched.beforeLeave?[e.matched.beforeLeave]:[],...r.beforeEnter?[r.beforeEnter]:[]];for(const r of n){const n=await r(t,e);if(!1===n)return!1;if("string"==typeof n||"object"==typeof n)return this.navigate(n),!1}return!0}_resolveStringComponent(t){const e=this.eleva._components.get(t);return e||this.errorHandler.handle(new Error(`Component "${t}" not registered.`),"Component resolution failed",{componentName:t,availableComponents:Array.from(this.eleva._components.keys())}),e}async _resolveFunctionComponent(t){try{const e=t.toString(),r=e.includes("import(")||e.startsWith("() =>"),n=await t();return r&&n.default||n}catch(e){this.errorHandler.handle(new Error(`Failed to load async component: ${e.message}`),"Component resolution failed",{function:t.toString(),error:e})}}_validateComponentDefinition(t){return t&&"object"==typeof t||this.errorHandler.handle(new Error("Invalid component definition: "+typeof t),"Component validation failed",{definition:t}),"function"!=typeof t.template&&"string"!=typeof t.template&&this.errorHandler.handle(new Error("Component missing template property"),"Component validation failed",{definition:t}),t}async _resolveComponent(t){return null==t?null:"string"==typeof t?this._resolveStringComponent(t):"function"==typeof t?await this._resolveFunctionComponent(t):t&&"object"==typeof t?this._validateComponentDefinition(t):void this.errorHandler.handle(new Error("Invalid component definition: "+typeof t),"Component resolution failed",{definition:t})}async _resolveComponents(t){const e=t.layout||this.options.globalLayout;try{const[r,n]=await Promise.all([this._resolveComponent(e),this._resolveComponent(t.component)]);return n||this.errorHandler.handle(new Error(`Page component is null or undefined for route: ${t.path}`),"Component resolution failed",{route:t.path}),{layoutComponent:r,pageComponent:n}}catch(e){throw this.errorHandler.log(`Error resolving components for route ${t.path}`,e,{route:t.path}),e}}async _render(t,e){const r=document.querySelector(this.options.mount);if(r||this.errorHandler.handle(new Error(`Mount element "${this.options.mount}" not found.`),{mountSelector:this.options.mount}),t){const n=await this.eleva.mount(r,this._wrapComponentWithChildren(t));this.currentLayout.value=n;const o=this._findViewElement(n.container),i=await this.eleva.mount(o,this._wrapComponentWithChildren(e));this.currentView.value=i}else{const t=await this.eleva.mount(r,this._wrapComponentWithChildren(e));this.currentView.value=t,this.currentLayout.value=null}}_createRouteGetter(t,e){return()=>this.currentRoute.value?.[t]??e}_wrapComponent(t){const e=t.setup,r=this;return{...t,setup:async t=>(t.router={navigate:r.navigate.bind(r),current:r.currentRoute,previous:r.previousRoute,get params(){return r._createRouteGetter("params",{})()},get query(){return r._createRouteGetter("query",{})()},get path(){return r._createRouteGetter("path","/")()},get fullUrl(){return r._createRouteGetter("fullUrl",window.location.href)()},get meta(){return r._createRouteGetter("meta",{})()}},e?await e(t):{})}}_wrapComponentWithChildren(t){const e=this._wrapComponent(t);if(e.children&&"object"==typeof e.children){const t={};for(const[r,n]of Object.entries(e.children))t[r]=this._wrapComponentWithChildren(n);e.children=t}return e}_getCurrentLocation(){if("undefined"==typeof window)return{path:"/",query:{},fullUrl:""};let t,e,r;switch(this.options.mode){case"hash":r=window.location.hash.slice(1)||"/",[t,e]=r.split("?");break;case"query":t=new URLSearchParams(window.location.search).get(this.options.queryParam)||"/",e=window.location.search.slice(1),r=t;break;default:t=window.location.pathname||"/",e=window.location.search.slice(1),r=`${t}${e?"?"+e:""}`}return{path:t.startsWith("/")?t:`/${t}`,query:this._parseQuery(e),fullUrl:r}}_parseQuery(t){const e={};return t&&new URLSearchParams(t).forEach((t,r)=>{e[r]=t}),e}_matchRoute(t){const e=t.split("/").filter(Boolean);for(const t of this.routes){if("/"===t.path){if(0===e.length)return{route:t,params:{}};continue}if(t.segments.length!==e.length)continue;const r={};let n=!0;for(let o=0;o<t.segments.length;o++){const i=t.segments[o],a=e[o];if("param"===i.type)r[i.name]=decodeURIComponent(a);else if(i.value!==a){n=!1;break}}if(n)return{route:t,params:r}}return null}onBeforeEach(t){this.options.onBeforeEach=t}onAfterEnter(t){this.emitter.on("router:afterEnter",t)}onAfterLeave(t){this.emitter.on("router:afterLeave",t)}onAfterEach(t){this.emitter.on("router:afterEach",t)}onError(t){this.emitter.on("router:onError",t)}use(t,e={}){"function"!=typeof t.install&&this.errorHandler.handle(new Error("Plugin must have an install method"),"Plugin registration failed",{plugin:t}),this.plugins.has(t.name)?this.errorHandler.warn(`Plugin "${t.name}" is already registered`,{existingPlugin:this.plugins.get(t.name)}):(this.plugins.set(t.name,t),t.install(this,e))}getPlugins(){return Array.from(this.plugins.values())}getPlugin(t){return this.plugins.get(t)}removePlugin(t){const e=this.plugins.get(t);if(!e)return!1;if("function"==typeof e.destroy)try{e.destroy(this)}catch(e){this.errorHandler.log(`Plugin ${t} destroy failed`,e)}return this.plugins.delete(t)}setErrorHandler(t){t&&"function"==typeof t.handle&&"function"==typeof t.warn&&"function"==typeof t.log&&(this.errorHandler=t)}}t.RouterPlugin={name:"router",version:"1.0.0-rc.1",description:"Client-side routing for Eleva applications",install(t,e={}){if(!e.mount)throw new Error("[RouterPlugin] 'mount' option is required");if(!e.routes||!Array.isArray(e.routes))throw new Error("[RouterPlugin] 'routes' option must be an array");const n=(e,r)=>{if(!e)return null;if("object"==typeof e&&null!==e&&!e.name){const n=`Eleva${r}Component_${Math.random().toString(36).slice(2,11)}`;try{return t.component(n,e),n}catch(t){throw new Error(`[RouterPlugin] Failed to register ${r} component: ${t.message}`)}}return e};e.globalLayout&&(e.globalLayout=n(e.globalLayout,"GlobalLayout")),(e.routes||[]).forEach(t=>{t.component=n(t.component,"Route"),t.layout&&(t.layout=n(t.layout,"RouteLayout"))});const o=new r(t,e);return t.router=o,!1!==e.autoStart&&queueMicrotask(()=>o.start()),t.plugins||(t.plugins=new Map),t.plugins.set(this.name,{name:this.name,version:this.version,description:this.description,options:e}),t.navigate=o.navigate.bind(o),t.getCurrentRoute=()=>o.currentRoute.value,t.getRouteParams=()=>o.currentParams.value,t.getRouteQuery=()=>o.currentQuery.value,o},async uninstall(t){t.router&&(await t.router.destroy(),delete t.router),t.plugins&&t.plugins.delete(this.name),delete t.navigate,delete t.getCurrentRoute,delete t.getRouteParams,delete t.getRouteQuery}}},"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).ElevaRouterPlugin={});
//# sourceMappingURL=router.umd.min.js.map

{"version":3,"file":"store.umd.min.js","sources":["../../src/plugins/Store.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸª StorePlugin\n * @classdesc A powerful reactive state management plugin for Eleva.js that enables sharing\n * reactive data across the entire application. The Store plugin provides a centralized,\n * reactive data store that can be accessed from any component's setup function.\n *\n * Core Features:\n * - Centralized reactive state management using Eleva's signal system\n * - Global state accessibility through component setup functions\n * - Namespace support for organizing store modules\n * - Built-in persistence with localStorage/sessionStorage support\n * - Action-based state mutations with validation\n * - Subscription system for reactive updates\n * - DevTools integration for debugging\n * - Plugin architecture for extensibility\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(StorePlugin, {\n *   state: {\n *     user: { name: \"John\", email: \"john@example.com\" },\n *     counter: 0,\n *     todos: []\n *   },\n *   actions: {\n *     increment: (state) => state.counter.value++,\n *     addTodo: (state, todo) => state.todos.value.push(todo),\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: {\n *     enabled: true,\n *     key: \"myApp-store\",\n *     storage: \"localStorage\"\n *   }\n * });\n *\n * // Use store in components\n * app.component(\"Counter\", {\n *   setup({ store }) {\n *     return {\n *       count: store.state.counter,\n *       increment: () => store.dispatch(\"increment\"),\n *       user: store.state.user\n *     };\n *   },\n *   template: (ctx) => `\n *     <div>\n *       <p>Hello ${ctx.user.value.name}!</p>\n *       <p>Count: ${ctx.count.value}</p>\n *       <button onclick=\"ctx.increment()\">+</button>\n *     </div>\n *   `\n * });\n */\nexport const StorePlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"store\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.0.0-rc.1\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description: \"Reactive state management for sharing data across the entire Eleva application\",\n\n  /**\n   * Installs the plugin into the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   * @param {Object} options - Plugin configuration options\n   * @param {Object} [options.state={}] - Initial state object\n   * @param {Object} [options.actions={}] - Action functions for state mutations\n   * @param {Object} [options.namespaces={}] - Namespaced modules for organizing store\n   * @param {Object} [options.persistence] - Persistence configuration\n   * @param {boolean} [options.persistence.enabled=false] - Enable state persistence\n   * @param {string} [options.persistence.key=\"eleva-store\"] - Storage key\n   * @param {\"localStorage\" | \"sessionStorage\"} [options.persistence.storage=\"localStorage\"] - Storage type\n   * @param {Array<string>} [options.persistence.include] - State keys to persist (if not provided, all state is persisted)\n   * @param {Array<string>} [options.persistence.exclude] - State keys to exclude from persistence\n   * @param {boolean} [options.devTools=false] - Enable development tools integration\n   * @param {Function} [options.onError=null] - Error handler function\n   *\n   * @example\n   * // Basic installation\n   * app.use(StorePlugin, {\n   *   state: { count: 0, user: null },\n   *   actions: {\n   *     increment: (state) => state.count.value++,\n   *     setUser: (state, user) => state.user.value = user\n   *   }\n   * });\n   *\n   * // Advanced installation with persistence and namespaces\n   * app.use(StorePlugin, {\n   *   state: { theme: \"light\" },\n   *   namespaces: {\n   *     auth: {\n   *       state: { user: null, token: null },\n   *       actions: {\n   *         login: (state, { user, token }) => {\n   *           state.user.value = user;\n   *           state.token.value = token;\n   *         },\n   *         logout: (state) => {\n   *           state.user.value = null;\n   *           state.token.value = null;\n   *         }\n   *       }\n   *     }\n   *   },\n   *   persistence: {\n   *     enabled: true,\n   *     include: [\"theme\", \"auth.user\"]\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      state = {},\n      actions = {},\n      namespaces = {},\n      persistence = {},\n      devTools = false,\n      onError = null,\n    } = options;\n\n    /**\n     * Store instance that manages all state and provides the API\n     * @private\n     */\n    class Store {\n      constructor() {\n        this.state = {};\n        this.actions = {};\n        this.subscribers = new Set();\n        this.mutations = [];\n        this.persistence = {\n          enabled: false,\n          key: \"eleva-store\",\n          storage: \"localStorage\",\n          include: null,\n          exclude: null,\n          ...persistence\n        };\n        this.devTools = devTools;\n        this.onError = onError;\n\n        this._initializeState(state, actions);\n        this._initializeNamespaces(namespaces);\n        this._loadPersistedState();\n        this._setupDevTools();\n      }\n\n      /**\n       * Initializes the root state and actions\n       * @private\n       */\n      _initializeState(initialState, initialActions) {\n        // Create reactive signals for each state property\n        Object.entries(initialState).forEach(([key, value]) => {\n          this.state[key] = new eleva.signal(value);\n        });\n\n        // Set up actions\n        this.actions = { ...initialActions };\n      }\n\n      /**\n       * Initializes namespaced modules\n       * @private\n       */\n      _initializeNamespaces(namespaces) {\n        Object.entries(namespaces).forEach(([namespace, module]) => {\n          const { state: moduleState = {}, actions: moduleActions = {} } = module;\n\n          // Create namespace object if it doesn't exist\n          if (!this.state[namespace]) {\n            this.state[namespace] = {};\n          }\n          if (!this.actions[namespace]) {\n            this.actions[namespace] = {};\n          }\n\n          // Initialize namespaced state\n          Object.entries(moduleState).forEach(([key, value]) => {\n            this.state[namespace][key] = new eleva.signal(value);\n          });\n\n          // Set up namespaced actions\n          this.actions[namespace] = { ...moduleActions };\n        });\n      }\n\n      /**\n       * Loads persisted state from storage\n       * @private\n       */\n      _loadPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const persistedData = storage.getItem(this.persistence.key);\n\n          if (persistedData) {\n            const data = JSON.parse(persistedData);\n            this._applyPersistedData(data);\n          }\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to load persisted state\");\n          } else {\n            console.warn(\"[StorePlugin] Failed to load persisted state:\", error);\n          }\n        }\n      }\n\n      /**\n       * Applies persisted data to the current state\n       * @private\n       */\n      _applyPersistedData(data, currentState = this.state, path = \"\") {\n        Object.entries(data).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (currentState[key] && typeof currentState[key] === \"object\" && \"value\" in currentState[key]) {\n              // This is a signal, update its value\n              currentState[key].value = value;\n            } else if (typeof value === \"object\" && value !== null && currentState[key]) {\n              // This is a nested object, recurse\n              this._applyPersistedData(value, currentState[key], fullPath);\n            }\n          }\n        });\n      }\n\n      /**\n       * Determines if a state path should be persisted\n       * @private\n       */\n      _shouldPersist(path) {\n        const { include, exclude } = this.persistence;\n\n        if (include && include.length > 0) {\n          return include.some(includePath => path.startsWith(includePath));\n        }\n\n        if (exclude && exclude.length > 0) {\n          return !exclude.some(excludePath => path.startsWith(excludePath));\n        }\n\n        return true;\n      }\n\n      /**\n       * Saves current state to storage\n       * @private\n       */\n      _saveState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const dataToSave = this._extractPersistedData();\n          storage.setItem(this.persistence.key, JSON.stringify(dataToSave));\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to save state\");\n          } else {\n            console.warn(\"[StorePlugin] Failed to save state:\", error);\n          }\n        }\n      }\n\n      /**\n       * Extracts data that should be persisted\n       * @private\n       */\n      _extractPersistedData(currentState = this.state, path = \"\") {\n        const result = {};\n\n        Object.entries(currentState).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (value && typeof value === \"object\" && \"value\" in value) {\n              // This is a signal, extract its value\n              result[key] = value.value;\n            } else if (typeof value === \"object\" && value !== null) {\n              // This is a nested object, recurse\n              const nestedData = this._extractPersistedData(value, fullPath);\n              if (Object.keys(nestedData).length > 0) {\n                result[key] = nestedData;\n              }\n            }\n          }\n        });\n\n        return result;\n      }\n\n      /**\n       * Sets up development tools integration\n       * @private\n       */\n      _setupDevTools() {\n        if (!this.devTools || typeof window === \"undefined\" || !window.__ELEVA_DEVTOOLS__) {\n          return;\n        }\n\n        window.__ELEVA_DEVTOOLS__.registerStore(this);\n      }\n\n      /**\n       * Dispatches an action to mutate the state\n       * @param {string} actionName - The name of the action to dispatch (supports namespaced actions like \"auth.login\")\n       * @param {any} payload - The payload to pass to the action\n       * @returns {Promise<any>} The result of the action\n       */\n      async dispatch(actionName, payload) {\n        try {\n          const action = this._getAction(actionName);\n\n          if (!action) {\n            const error = new Error(`Action \"${actionName}\" not found`);\n            if (this.onError) {\n              this.onError(error, actionName);\n            }\n            throw error;\n          }\n\n          const mutation = {\n            type: actionName,\n            payload,\n            timestamp: Date.now()\n          };\n\n          // Record mutation for devtools\n          this.mutations.push(mutation);\n          if (this.mutations.length > 100) {\n            this.mutations.shift(); // Keep only last 100 mutations\n          }\n\n          // Execute the action\n          const result = await action.call(null, this.state, payload);\n\n          // Save state if persistence is enabled\n          this._saveState();\n\n          // Notify subscribers\n          this.subscribers.forEach(callback => {\n            try {\n              callback(mutation, this.state);\n            } catch (error) {\n              if (this.onError) {\n                this.onError(error, \"Subscriber callback failed\");\n              }\n            }\n          });\n\n          // Notify devtools\n          if (this.devTools && typeof window !== \"undefined\" && window.__ELEVA_DEVTOOLS__) {\n            window.__ELEVA_DEVTOOLS__.notifyMutation(mutation, this.state);\n          }\n\n          return result;\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, `Action dispatch failed: ${actionName}`);\n          }\n          throw error;\n        }\n      }\n\n      /**\n       * Gets an action by name (supports namespaced actions)\n       * @private\n       */\n      _getAction(actionName) {\n        const parts = actionName.split(\".\");\n        let current = this.actions;\n\n        for (const part of parts) {\n          if (current[part] === undefined) {\n            return null;\n          }\n          current = current[part];\n        }\n\n        return typeof current === \"function\" ? current : null;\n      }\n\n      /**\n       * Subscribes to store mutations\n       * @param {Function} callback - Callback function to call on mutations\n       * @returns {Function} Unsubscribe function\n       */\n      subscribe(callback) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Subscribe callback must be a function\");\n        }\n\n        this.subscribers.add(callback);\n\n        // Return unsubscribe function\n        return () => {\n          this.subscribers.delete(callback);\n        };\n      }\n\n      /**\n       * Gets a deep copy of the current state values (not signals)\n       * @returns {Object} The current state values\n       */\n      getState() {\n        return this._extractPersistedData();\n      }\n\n      /**\n       * Replaces the entire state (useful for testing or state hydration)\n       * @param {Object} newState - The new state object\n       */\n      replaceState(newState) {\n        this._applyPersistedData(newState);\n        this._saveState();\n      }\n\n      /**\n       * Clears persisted state from storage\n       */\n      clearPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          storage.removeItem(this.persistence.key);\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to clear persisted state\");\n          }\n        }\n      }\n\n      /**\n       * Registers a new namespaced module at runtime\n       * @param {string} namespace - The namespace for the module\n       * @param {Object} module - The module definition\n       * @param {Object} module.state - The module's initial state\n       * @param {Object} module.actions - The module's actions\n       */\n      registerModule(namespace, module) {\n        if (this.state[namespace] || this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" already exists`);\n          return;\n        }\n\n        // Initialize the module\n        this.state[namespace] = {};\n        this.actions[namespace] = {};\n\n        const namespaces = { [namespace]: module };\n        this._initializeNamespaces(namespaces);\n\n        this._saveState();\n      }\n\n      /**\n       * Unregisters a namespaced module\n       * @param {string} namespace - The namespace to unregister\n       */\n      unregisterModule(namespace) {\n        if (!this.state[namespace] && !this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" does not exist`);\n          return;\n        }\n\n        delete this.state[namespace];\n        delete this.actions[namespace];\n        this._saveState();\n      }\n    }\n\n    // Create the store instance\n    const store = new Store();\n\n    // Store the original mount method to override it\n    const originalMount = eleva.mount;\n\n    /**\n     * Override the mount method to inject store context into components\n     */\n    eleva.mount = async (container, compName, props = {}) => {\n      // Get the component definition\n      const componentDef = typeof compName === \"string\"\n        ? eleva._components.get(compName) || compName\n        : compName;\n\n      if (!componentDef) {\n        return await originalMount.call(eleva, container, compName, props);\n      }\n\n      // Create a wrapped component that injects store into setup\n      const wrappedComponent = {\n        ...componentDef,\n        async setup(ctx) {\n          // Inject store into the context with enhanced API\n          ctx.store = {\n            // Core store functionality\n            state: store.state,\n            dispatch: store.dispatch.bind(store),\n            subscribe: store.subscribe.bind(store),\n            getState: store.getState.bind(store),\n\n            // Module management\n            registerModule: store.registerModule.bind(store),\n            unregisterModule: store.unregisterModule.bind(store),\n\n            // Utilities for dynamic state/action creation\n            createState: (key, initialValue) => {\n              if (!store.state[key]) {\n                store.state[key] = new eleva.signal(initialValue);\n              }\n              return store.state[key];\n            },\n\n            createAction: (name, actionFn) => {\n              store.actions[name] = actionFn;\n            },\n\n            // Access to signal constructor for manual state creation\n            signal: eleva.signal\n          };\n\n          // Call original setup if it exists\n          const originalSetup = componentDef.setup;\n          const result = originalSetup ? await originalSetup(ctx) : {};\n\n          return result;\n        }\n      };\n\n      // Call original mount with wrapped component\n      return await originalMount.call(eleva, container, wrappedComponent, props);\n    };\n\n    // Override _mountComponents to ensure child components also get store context\n    const originalMountComponents = eleva._mountComponents;\n    eleva._mountComponents = async (container, children, childInstances) => {\n      // Create wrapped children with store injection\n      const wrappedChildren = {};\n\n      for (const [selector, childComponent] of Object.entries(children)) {\n        const componentDef = typeof childComponent === \"string\"\n          ? eleva._components.get(childComponent) || childComponent\n          : childComponent;\n\n        if (componentDef && typeof componentDef === \"object\") {\n          wrappedChildren[selector] = {\n            ...componentDef,\n            async setup(ctx) {\n              // Inject store into the context with enhanced API\n              ctx.store = {\n                // Core store functionality\n                state: store.state,\n                dispatch: store.dispatch.bind(store),\n                subscribe: store.subscribe.bind(store),\n                getState: store.getState.bind(store),\n\n                // Module management\n                registerModule: store.registerModule.bind(store),\n                unregisterModule: store.unregisterModule.bind(store),\n\n                // Utilities for dynamic state/action creation\n                createState: (key, initialValue) => {\n                  if (!store.state[key]) {\n                    store.state[key] = new eleva.signal(initialValue);\n                  }\n                  return store.state[key];\n                },\n\n                createAction: (name, actionFn) => {\n                  store.actions[name] = actionFn;\n                },\n\n                // Access to signal constructor for manual state creation\n                signal: eleva.signal\n              };\n\n              // Call original setup if it exists\n              const originalSetup = componentDef.setup;\n              const result = originalSetup ? await originalSetup(ctx) : {};\n\n              return result;\n            }\n          };\n        } else {\n          wrappedChildren[selector] = childComponent;\n        }\n      }\n\n      // Call original _mountComponents with wrapped children\n      return await originalMountComponents.call(eleva, container, wrappedChildren, childInstances);\n    };\n\n    // Expose store instance and utilities on the Eleva instance\n    eleva.store = store;\n\n    /**\n     * Expose utility methods on the Eleva instance\n     * @namespace eleva.store\n     */\n    eleva.createAction = (name, actionFn) => {\n      store.actions[name] = actionFn;\n    };\n\n    eleva.dispatch = (actionName, payload) => {\n      return store.dispatch(actionName, payload);\n    };\n\n    eleva.getState = () => {\n      return store.getState();\n    };\n\n    eleva.subscribe = (callback) => {\n      return store.subscribe(callback);\n    };\n\n    // Store original methods for cleanup\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   *\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   *\n   * @example\n   * // Uninstall the plugin\n   * StorePlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove store instance and utility methods\n    if (eleva.store) {\n      delete eleva.store;\n    }\n    if (eleva.createAction) {\n      delete eleva.createAction;\n    }\n    if (eleva.dispatch) {\n      delete eleva.dispatch;\n    }\n    if (eleva.getState) {\n      delete eleva.getState;\n    }\n    if (eleva.subscribe) {\n      delete eleva.subscribe;\n    }\n  },\n};"],"names":["name","version","description","install","eleva","options","state","actions","namespaces","persistence","devTools","onError","store","constructor","this","subscribers","Set","mutations","enabled","key","storage","include","exclude","_initializeState","_initializeNamespaces","_loadPersistedState","_setupDevTools","initialState","initialActions","Object","entries","forEach","value","signal","namespace","module","moduleState","moduleActions","window","persistedData","getItem","data","JSON","parse","_applyPersistedData","error","currentState","path","fullPath","_shouldPersist","length","some","includePath","startsWith","excludePath","_saveState","dataToSave","_extractPersistedData","setItem","stringify","result","nestedData","keys","__ELEVA_DEVTOOLS__","registerStore","dispatch","actionName","payload","action","_getAction","Error","mutation","type","timestamp","Date","now","push","shift","call","callback","notifyMutation","parts","split","current","part","undefined","subscribe","add","delete","getState","replaceState","newState","clearPersistedState","removeItem","registerModule","unregisterModule","originalMount","mount","async","container","compName","props","componentDef","_components","get","wrappedComponent","setup","ctx","bind","createState","initialValue","createAction","actionFn","originalSetup","originalMountComponents","_mountComponents","children","childInstances","wrappedChildren","selector","childComponent","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
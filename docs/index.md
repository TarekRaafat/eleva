---
title: Best DX for Building the Best UX
description: Eleva.js is a 6KB minimalist pure vanilla JavaScript frontend framework designed for the best Developer Experience (DX). Signal-based reactivity, zero dependencies, and built-in TypeScript support. The perfect React and Vue alternative for developers who want simplicity without sacrificing power.
image: /imgs/eleva.js%20Full%20Logo.png
---

# Eleva.js - Best DX for Building the Best UX

> **Version:** `1.0.0` | **Bundle Size:** ~6KB minified (~2.3KB gzipped) | **Dependencies:** Zero | **Language:** Pure Vanilla JavaScript | **TypeScript:** Built-in declarations included

[![License](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![GitHub package.json version](https://img.shields.io/github/package-json/v/tarekraafat/eleva?label=github)](https://github.com/TarekRaafat/eleva)
[![Version](https://img.shields.io/npm/v/eleva.svg?style=flat)](https://www.npmjs.com/package/eleva)
![100% Javascript](https://img.shields.io/github/languages/top/TarekRaafat/eleva?color=yellow)
![Zero Dependencies](https://img.shields.io/badge/dependencies-0-green.svg)
[![codecov](https://codecov.io/gh/TarekRaafat/eleva/branch/master/graph/badge.svg?token=LFA6KENM24)](https://codecov.io/gh/TarekRaafat/eleva)
[![Minified Size](https://badgen.net/bundlephobia/min/eleva@latest)](https://bundlephobia.com/package/eleva@latest)
[![Gzipped Size](https://badgen.net/bundlephobia/minzip/eleva@latest)](https://bundlephobia.com/package/eleva@latest)
[![](https://data.jsdelivr.com/v1/package/npm/eleva/badge?style=rounded)](https://www.jsdelivr.com/package/npm/eleva)

<br>

<p align="center">
  <a href="https://github.com/TarekRaafat/eleva"><img src="./imgs/eleva.js Full Logo.png" alt="Eleva.js - Lightweight JavaScript Framework Logo" width="50%"></a>
</p>

<p align="center">
  <a href="https://www.producthunt.com/posts/eleva?embed=true&utm_source=badge-featured&utm_medium=badge&utm_souce=badge-eleva" target="_blank"><img src="https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=938663&theme=light&t=1741247713068" alt="Eleva.js - A minimalist pure vanilla JavaScript frontend framework | Product Hunt" style="width: 250px; height: 54px;" width="250" height="54" /></a>
</p>

<p align="center">
  <a href="https://chatgpt.com/g/g-684b2a1bf9548191a0b0e25f44eebefc-eleva-website-builder"><img src="./imgs/Eleva Website Builder Button.png" alt="Eleva Website Builder - AI-powered website creation tool" width="30%"></a>
</p>

<br>
<br>
<br>

## What is Eleva?

**Eleva** is a minimalist, lightweight (6KB), pure vanilla JavaScript frontend framework crafted for **exceptional Developer Experience (DX)**. When developers enjoy building, users enjoy using ‚Äî Eleva makes it effortless to create beautiful, responsive, and performant User Interfaces (UI).

Unlike React, Vue, or Angular, Eleva:
- **Has zero dependencies** - No node_modules bloat
- **Requires no build step** - Works directly in browsers via CDN
- **Uses real DOM** - No virtual DOM overhead for simple apps
- **Provides signal-based reactivity** - Fine-grained updates like Solid.js
- **Includes TypeScript support** - Built-in type declarations

Eleva is ideal for developers building lightweight web applications, prototypes, micro-frontends, or anyone seeking a simpler alternative to React, Vue, or Angular.

> _"The best UX comes from developers who love their tools."_ ‚Äî Eleva's DX philosophy

> **Stable Release**: This is the official documentation for Eleva v1.0.0 - the first stable release! The framework is production-ready with a stable API. We welcome your feedback and contributions to make Eleva even better.

---

## Eleva vs Other JavaScript Frameworks

How does Eleva compare to popular JavaScript frameworks like React, Vue, Svelte, and Angular?

| Feature | Eleva 1.0 | React 19 | Vue 3.5 | Svelte 5 | Angular 19 |
|---------|-----------|----------|---------|----------|------------|
| **Bundle Size** | ~6KB | ~44KB | ~45KB | ~3KB* | ~90KB |
| **Dependencies** | 0 | 3+ | 0 | 0 | 10+ |
| **Virtual DOM** | No | Yes | Yes | No | No |
| **Reactivity** | Signals | useState/Hooks | Refs/Reactive | Compiler | Zone.js |
| **TypeScript** | Built-in | Optional | Optional | Built-in | Built-in |
| **Build Required** | No | Yes | Optional | Yes | Yes |
| **Learning Curve** | Low | Medium | Medium | Low | High |
| **Component Model** | Object-based | JSX/Functional | SFC/Options | SFC | Decorators |

_*Svelte compiles away, so runtime is minimal but build step is required._

### When to Use Eleva

**Choose Eleva when you need:**
- A lightweight framework without build complexity
- Quick prototypes or MVPs
- Micro-frontends or embedded widgets
- Server-side rendered pages with progressive enhancement
- Projects where bundle size matters
- A simpler alternative to React or Vue

**Consider other frameworks when you need:**
- Large enterprise applications (Angular)
- Extensive ecosystem and community (React)
- Full-featured SPA with routing built-in (Vue + Vue Router)
- Maximum performance for complex UIs (Svelte)

---

## Developer Experience (DX)

Eleva is built on a simple principle: **great DX leads to great UX**. When developers have intuitive tools, they build better interfaces.

### Why Eleva's DX Stands Out

| DX Feature | How It Helps You Build Better UX |
|------------|----------------------------------|
| **Zero Config** | Start building immediately ‚Äî no webpack, no bundlers, no setup |
| **Intuitive API** | Learn in minutes, master in hours ‚Äî more time for polishing UI |
| **Pure JavaScript** | No JSX, no compilation ‚Äî what you write is what runs |
| **Instant Feedback** | Signal-based reactivity shows changes immediately |
| **TypeScript Built-in** | Full autocomplete and type safety out of the box |
| **Tiny Bundle** | ~2.3KB gzipped means instant page loads for your users |
| **No Hidden Magic** | Debug easily with transparent, predictable behavior |
| **Sync & Async Hooks** | Lifecycle hooks that work the way you expect |

### DX-First Design Principles

- **üéØ Predictable** ‚Äî No surprises. The framework behaves exactly as documented.
- **üîç Debuggable** ‚Äî Clear error messages and easy-to-trace execution flow.
- **üìñ Self-Documenting** ‚Äî API names that make sense without checking docs.
- **‚ö° Fast Iteration** ‚Äî Change code, see results instantly. No build delays.
- **ü§ù Familiar Patterns** ‚Äî If you know JavaScript, you know Eleva.

---

## Browser Support

Eleva targets **modern evergreen browsers** and requires no polyfills for supported environments.

### Supported Browsers

| Browser | Minimum Version | Release Date |
|---------|-----------------|--------------|
| **Chrome** | 71+ | Dec 2018 |
| **Firefox** | 69+ | Sep 2019 |
| **Safari** | 12.1+ | Mar 2019 |
| **Edge** | 79+ (Chromium) | Jan 2020 |
| **Opera** | 58+ | Jan 2019 |
| **iOS Safari** | 12.2+ | Mar 2019 |
| **Chrome Android** | 71+ | Dec 2018 |

### Key JavaScript Features Used

Eleva uses the following modern JavaScript features:

| Feature | Purpose in Eleva |
|---------|------------------|
| `queueMicrotask()` | Batched rendering scheduler |
| `Map` / `Set` | Internal state management |
| ES6 Classes | Component architecture |
| Template Literals | Template system |
| Async/Await | Lifecycle hooks |
| Optional Chaining (`?.`) | Safe property access |
| Spread Operator | Props and context merging |

### Legacy Browser Support

Eleva does **not** support:
- Internet Explorer (any version)
- Legacy Edge (non-Chromium, version < 79)
- Older mobile browsers

If you need to support legacy browsers, consider:
1. Using a transpiler like Babel with appropriate polyfills
2. Adding polyfills for `queueMicrotask` and other modern APIs
3. Choosing a framework with built-in legacy support

### Why Modern Browsers Only?

Eleva's design philosophy prioritizes:
- **Small bundle size** - No polyfills means smaller footprint
- **Performance** - Native browser APIs are faster than polyfilled alternatives
- **Simplicity** - No build step required for modern browsers
- **Future-forward** - Aligns with web platform evolution

> **Note:** As of 2024, the supported browsers cover approximately **96%+ of global web traffic** according to [caniuse.com](https://caniuse.com/mdn-api_queuemicrotask).

---

## TL;DR - Quick Start

### 30-Second Setup

```javascript
// 1. Import
import Eleva from "eleva";

// 2. Create app
const app = new Eleva("MyApp");

// 3. Define component
app.component("Counter", {
  setup: ({ signal }) => ({ count: signal(0) }),
  template: (ctx) => `
    <button @click="() => count.value++">
      Count: ${ctx.count.value}
    </button>
  `
});

// 4. Mount
app.mount(document.getElementById("app"), "Counter");
```

### API Cheatsheet

| Method | Description | Returns |
|--------|-------------|---------|
| `new Eleva(name)` | Create app instance | `Eleva` |
| `app.component(name, def)` | Register component | `Eleva` |
| `app.mount(el, name, props?)` | Mount to DOM | `Promise<MountResult>` |
| `app.use(plugin, options?)` | Install plugin | `Eleva` or plugin result |
| `signal(value)` | Create reactive state | `Signal<T>` |
| `emitter.on(event, fn)` | Subscribe to event | `() => void` (unsubscribe) |
| `emitter.emit(event, data)` | Emit event | `void` |

### Template Syntax Cheatsheet

> **Quick Rule:** `${}` needs `ctx.` ‚Äî `@events` and `:props` don't.

| Syntax | Purpose | `ctx.`? | Example |
|--------|---------|:-------:|---------|
| `${expr}` | JavaScript value interpolation | ‚úì | `${ctx.user.name}` |
| `@event` | Event binding | ‚úó | `@click="handleClick"` |
| `:prop` | Pass prop to child | ‚úó | `:user="userData.value"` |

> **How it works:** Use `${ctx.value}` to interpolate values into your template. For `@events` and `:props`, expressions are evaluated against the component context directly ‚Äî no `ctx.` prefix needed. This allows cleaner syntax like `:user="userData.value"` instead of `:user="${ctx.userData.value}"`.

### Lifecycle Hooks

Lifecycle hooks are **returned from setup**, not destructured from context. They support **both sync and async** functions:

| Hook | When Called |
|------|-------------|
| `onBeforeMount` | Before component mounts to DOM |
| `onMount` | After component mounts to DOM |
| `onBeforeUpdate` | Before component re-renders |
| `onUpdate` | After component re-renders |
| `onUnmount` | Before component is destroyed |

```js
// Sync hooks
setup: ({ signal }) => ({
  count: signal(0),
  onMount: () => console.log("Mounted!"),
  onUnmount: () => console.log("Unmounting!")
})

// Async hooks (awaited by framework)
setup: ({ signal }) => ({
  data: signal(null),
  onMount: async ({ context }) => {
    const res = await fetch("/api/data");
    context.data.value = await res.json();
  }
})
```

### Built-in Plugins

| Plugin | Purpose | Size | Docs |
|--------|---------|------|------|
| `Attr` | ARIA, data-*, boolean attributes | ~2.4KB | [‚Üí](./plugins/attr.md) |
| `Router` | Client-side routing & guards | ~15KB | [‚Üí](./plugins/router.md) |
| `Store` | Global state management | ~6KB | [‚Üí](./plugins/store.md) |

---

## Table of Contents

- [Eleva.js - Best DX for Building the Best UX](#elevajs---best-dx-for-building-the-best-ux)
  - [What is Eleva?](#what-is-eleva)
  - [Eleva vs Other JavaScript Frameworks](#eleva-vs-other-javascript-frameworks)
    - [When to Use Eleva](#when-to-use-eleva)
  - [Developer Experience (DX)](#developer-experience-dx)
  - [Browser Support](#browser-support)
  - [TL;DR - Quick Start](#tldr---quick-start)
  - [Table of Contents](#table-of-contents)
  - [1. Introduction](#1-introduction)
  - [2. Design Philosophy](#2-design-philosophy)
  - [3. Core Principles](#3-core-principles)
  - [4. Performance Benchmarks](#4-performance-benchmarks)
  - [5. Getting Started](#5-getting-started)
    - [Installation](#installation)
    - [Quick Start Tutorial](#quick-start-tutorial)
  - [6. Core Concepts](#6-core-concepts)
    - [TemplateEngine](#templateengine)
    - [Template Interpolation](#template-interpolation)
      - [Common Mistakes](#common-mistakes)
    - [Setup Context vs. Event Context](#setup-context-vs-event-context)
      - [Setup Context](#setup-context)
      - [Event Context](#event-context)
    - [Signal (Reactivity)](#signal-reactivity)
    - [Emitter (Event Handling)](#emitter-event-handling)
    - [Renderer (DOM Diffing)](#renderer-dom-diffing)
    - [Eleva (Core)](#eleva-core)
    - [Lifecycle Hooks](#lifecycle-hooks)
    - [Component Registration \& Mounting](#component-registration--mounting)
    - [Children Components \& Passing Props](#children-components--passing-props)
      - [Types of Children Component Mounting](#types-of-children-component-mounting)
      - [Supported Children Selector Types](#supported-children-selector-types)
    - [Style Injection \& Scoped CSS](#style-injection--scoped-css)
    - [Inter-Component Communication](#inter-component-communication)
      - [Component Communication Flow](#component-communication-flow)
    - [Component Context](#component-context)
    - [Mounting Process](#mounting-process)
  - [7. Architecture \& Data Flow](#7-architecture--data-flow)
    - [Key Components](#key-components)
    - [Data Flow Process](#data-flow-process)
    - [Visual Overview](#visual-overview)
    - [Detailed Architecture Flow](#detailed-architecture-flow)
    - [Benefits](#benefits)
  - [8. Plugin System](#8-plugin-system)
    - [Plugin Structure](#plugin-structure)
    - [Installing Plugins](#installing-plugins)
    - [Plugin Capabilities](#plugin-capabilities)
    - [Plugin Development Best Practices](#plugin-development-best-practices)
    - [Example Plugin](#example-plugin)
    - [Plugin Lifecycle](#plugin-lifecycle)
    - [TypeScript Support](#typescript-support)
    - [Built-in Plugins](#built-in-plugins)
      - [üéØ Attr Plugin](#-attr-plugin)
      - [üöÄ Router Plugin](#-router-plugin)
      - [üè™ Store Plugin](#-store-plugin)
      - [Plugin Installation](#plugin-installation)
      - [Bundle Sizes](#bundle-sizes)
  - [9. Debugging \& Developer Tools](#9-debugging--developer-tools)
  - [10. Best Practices \& Use Cases](#10-best-practices--use-cases)
    - [Best Practices](#best-practices-1)
      - [Component Structure Order](#component-structure-order)
      - [Setup Function: Patterns & Best Practices](#setup-function-patterns--best-practices)
      - [Lifecycle Hooks: Patterns & Best Practices](#lifecycle-hooks-patterns--best-practices)
      - [Signal Reactivity: Patterns & Best Practices](#signal-reactivity-patterns--best-practices)
      - [Async Patterns: Setup, Template & Style](#async-patterns-setup-template--style)
      - [Style Property: String vs Function](#style-property-string-vs-function)
      - [Template Property: Patterns & Best Practices](#template-property-patterns--best-practices)
      - [Children Property: Patterns & Best Practices](#children-property-patterns--best-practices)
      - [Component Communication: Props vs Emitter vs Store](#component-communication-props-vs-emitter-vs-store)
      - [General Guidelines](#general-guidelines)
    - [Use Cases](#use-cases)
  - [11. Examples and Tutorials](#11-examples-and-tutorials)
  - [12. FAQ](#12-faq)
  - [13. Testing](#13-testing)
  - [14. Troubleshooting \& Migration](#14-troubleshooting--migration)
    - [Troubleshooting](#troubleshooting)
    - [Migration Guidelines](#migration-guidelines)
  - [15. API Reference](#15-api-reference)
  - [16. Contributing](#16-contributing)
  - [17. Community \& Support](#17-community--support)
  - [18. Changelog](#18-changelog)
  - [19. License](#19-license)
  - [Summary](#summary)

---

## 1. Introduction

Eleva is designed to offer a simple yet powerful way to build frontend applications using pure vanilla JavaScript. Its goal is to empower developers who value simplicity, performance, and full control over their application to build modular and high-performance apps without the overhead of larger frameworks.

> **New to Eleva?** Check out the [TL;DR - Quick Start](#tldr---quick-start) section above for a 30-second setup guide and API cheatsheet.

---

## 2. Design Philosophy

**Eleva is unopinionated.** Unlike many frameworks that enforce a specific project structure or coding paradigm, Eleva provides only the minimal core with a flexible plugin system, leaving architectural decisions in your hands. This means:

- **üîÑ Flexibility:** Architect your application as you prefer.
- **üéØ Native JavaScript:** Enjoy seamless integration with your existing code.
- **‚öôÔ∏è Configurability:** Extend functionality with a simple API and plugins.
- **üÜì Freedom:** Build both simple and complex applications without unnecessary constraints.

---

## 3. Core Principles

At the heart of Eleva are a few fundamental principles that guide its design and usage:

- **Minimalism:**  
  Eleva includes only the essential features needed for building functional, high-performance applications without added complexity.

- **Reactivity:**  
  With its signal-based reactivity, Eleva updates only the parts of the UI that change, ensuring smooth and efficient DOM updates.

- **Simplicity:**  
  Built using pure vanilla JavaScript, Eleva offers a shallow learning curve and seamless integration with existing projects.

- **Modularity:**  
  Each component is self-contained, making your application scalable and maintainable.

- **Flexibility:**  
  Eleva's unopinionated nature allows you to choose your own architectural patterns and extend the framework with plugins as needed.

- **Performance:**  
  Designed to be lightweight and efficient, Eleva is ideal for performance-critical applications.

---

## 4. Performance Benchmarks

### ‚ö° 240fps+ Ready - The Framework Is Never the Bottleneck

Eleva is built for high-performance applications. With an average render time of **0.011ms**, Eleva can theoretically achieve **90,000+ fps** for simple updates:

| FPS Target | Frame Budget | Eleva Capability | Status |
|------------|--------------|------------------|:------:|
| **60 fps** | 16.67ms | ~1,500 renders possible | ‚úÖ |
| **120 fps** | 8.33ms | ~750 renders possible | ‚úÖ |
| **240 fps** | 4.17ms | ~380 renders possible | ‚úÖ |

**FPS Throughput Benchmarks:**

| Scenario | Ops/Second | Avg Render Time | 240fps Ready? |
|----------|-----------|-----------------|:-------------:|
| Simple counter | 32,815 | 0.030ms | ‚úÖ |
| Position animation (2 signals) | 45,072 | 0.022ms | ‚úÖ |
| 5 signals batched | 34,290 | 0.029ms | ‚úÖ |
| 100-item list | 1,628 | 0.614ms | ‚úÖ |
| Complex nested template | 7,146 | 0.140ms | ‚úÖ |

Even the **heaviest scenario** (100-item list at 0.614ms) comfortably fits within a 240fps frame budget of 4.17ms.

### js-framework-benchmark Comparison

Benchmarks using [js-framework-benchmark](https://krausest.github.io/js-framework-benchmark/) methodology (1,000 rows):

| **Framework**                 | **Bundle Size (min+gzip)** | **Create 1K Rows** (ms) | **Partial Update** (ms) | **Memory** (MB)* |
| ----------------------------- | -------------------------- | ----------------------- | ----------------------- | ---------------- |
| **Eleva 1.0** (Direct DOM)    | **~2.3KB**                 | **~25**                 | ~86                     | **~0.5** (Chrome) |
| **React 19** (Virtual DOM)    | ~44KB                      | 40-70                   | 10-20                   | 2-5              |
| **Vue 3.5** (Reactive)        | ~45KB                      | 25-45                   | 5-15                    | 2-4              |
| **Angular 19** (Signals)      | ~90KB                      | 50-80                   | 15-25                   | 3-6              |

**Eleva's Strengths:**
- **240fps+ capable** - Framework never limits frame rate
- **Smallest bundle size** (~2.3 KB vs 35-90 KB)
- **Competitive initial render** (~25ms for 1K rows)
- **Zero dependencies** and minimal runtime overhead
- **Automatic render batching** - Multiple signal changes = 1 render

**Performance Tips:**
- Use `key` attribute on list items for optimal diffing
- Eleva excels at initial renders and memory efficiency
- For large lists, use keyed reconciliation in a single template:

```javascript
// Recommended: Single template with keyed rows
template: (ctx) => `
  <table>
    <tbody>
      ${ctx.rows.value.map(row => `
        <tr key="${row.id}">
          <td>${row.id}</td>
          <td>${row.label}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>
`
```

> ‚ö†Ô∏è **Note:** Avoid component splitting for large lists (1000+ rows). Creating separate component instances adds significant overhead (~125 MB vs ~29 MB for 10K rows).

> üí° **For 10K+ rows:** Use [virtual scrolling](./examples/patterns/best-practices.md#virtual-scrolling-10k-rows) - renders only visible rows (~17 instead of 10,000). Verified results: **5.5x less memory**, **9.5x faster updates**, **12x faster creation**.

> üí° **Run benchmarks yourself:** `bun run test:benchmark` or `bun run test:fps`

#### *Memory Measurement Details

**Chrome DevTools Measurement (Real Browser):**

Using the [js-framework-benchmark](https://github.com/krausest/js-framework-benchmark) methodology in Chrome:

```
Chrome Memory (1,000 rows):
- Baseline:    15.2 MB
- After:       15.7 MB
- Overhead:    ~0.5 MB  (~0.5 KB/row)

Chrome Memory (10,000 rows):
- Baseline:    15.2 MB
- After:       28.9 MB
- Overhead:    ~13.7 MB (~1.37 KB/row)

Chrome Memory (Append 1,000 rows to 10K):
- Before:      39.3 MB (10K rows)
- After:       40.7 MB (11K rows)
- Overhead:    ~1.4 MB  (~1.4 KB/row)

Chrome Memory (Update every 10th row):
- Before:      40.7 MB
- After:       40.7 MB
- Overhead:    ~0 MB  (no memory growth)

Chrome Memory (Clear):
- Before:      37.8 MB
- After:       37.8 MB
- Overhead:    ~0 MB  (memory properly released)

Chrome Memory (Swap Rows):
- Before:      37.8 MB
- After:       37.8 MB
- Overhead:    ~0 MB  (no memory growth)
```

This confirms Eleva uses **less memory than VDOM frameworks** because:

1. **No virtual DOM tree** - VDOM frameworks maintain a parallel JS object tree
2. **No diffing state** - No previous render state to compare against
3. **Direct DOM manipulation** - No intermediate representations

**Note on Node.js Testing:**

Our automated tests run in **happy-dom** (Node.js), which shows inflated numbers (~19 MB) because DOM nodes in happy-dom are JavaScript objects (~3KB each) rather than native browser DOM nodes.

```
Environment comparison (1,000 rows):
- Chrome (real browser):  ~0.5 MB  ‚Üê Accurate
- happy-dom (Node.js):    ~19 MB   ‚Üê Inflated by 38x
```

> üí° **Test it yourself:** Run `bun run serve` from repo root, open http://localhost:3000/test/performance/browser/standalone.html, and use Chrome DevTools Memory tab.

---

## 5. Getting Started

### Installation

Install via npm:

```bash
npm install eleva
```

**Core Framework Only (Recommended):**
```javascript
import Eleva from 'eleva';  // ~6KB - Core framework only
const app = new Eleva("MyApp");
```

**With Individual Plugins (Optional):**
```javascript
import Eleva from 'eleva';
import { Attr } from 'eleva/plugins/attr';      // ~2.4KB
import { Router } from 'eleva/plugins/router';  // ~15KB
import { Store } from 'eleva/plugins/store';    // ~6KB

const app = new Eleva("MyApp");
app.use(Attr);    // Only if needed
app.use(Router);  // Only if needed
app.use(Store);   // Only if needed
```

Or include it directly via CDN:

```html
<!-- Core framework only (Recommended) -->
<script src="https://cdn.jsdelivr.net/npm/eleva"></script>

<!-- With all plugins (Optional) -->
<script src="https://cdn.jsdelivr.net/npm/eleva/plugins"></script>

<!-- Or individual plugins -->
<script src="https://cdn.jsdelivr.net/npm/eleva/dist/plugins/attr.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/eleva/dist/plugins/router.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/eleva/dist/plugins/store.umd.min.js"></script>
```

or

```html
<!-- unpkg -->
<script src="https://unpkg.com/eleva"></script>
```

### Quick Start Tutorial

Below is a step-by-step tutorial to help you get started. This example demonstrates component registration, state creation, and mounting using a DOM element (not a selector), with asynchronous handling.

```js
import Eleva from "eleva";

const app = new Eleva("MyApp");

// Define a simple component
app.component("HelloWorld", {
  // Optional setup: if omitted, Eleva defaults to an empty state
  setup({ signal }) {
    const count = signal(0);
    return { count };
  },
  template: (ctx) => `
    <div>
      <h1>Hello, Eleva! üëã</h1>
      <p>Count: ${ctx.count.value}</p>
      <button @click="() => count.value++">Increment</button>
    </div>
  `,
});

// Mount the component by providing a DOM element and handling the returned Promise
app
  .mount(document.getElementById("app"), "HelloWorld")
  .then((instance) => console.log("Component mounted:", instance));
```

For interactive demos, check out the [CodePen Example](https://codepen.io/tarekraafat/pen/GgRrxdY?editors=1010).

---

## 6. Core Concepts

### TemplateEngine

The **TemplateEngine** is responsible for evaluating expressions in `@events` and `:props` attributes.

- **`TemplateEngine.evaluate(expr, data)`**: Safely evaluates JavaScript expressions within the provided context. Used internally for event handlers and prop values.

_Example:_

```js
// Internal usage for event handlers
const handler = TemplateEngine.evaluate("handleClick", context);
// handler is now the actual function reference

// Internal usage for props
const userData = TemplateEngine.evaluate("user.value", context);
// userData is the actual object value
```

**Key Features:**
- Static method-based API
- Expression evaluation in component context
- Function caching for performance
- Error handling for invalid expressions
- Support for complex object access and method calls

### Template Interpolation

Eleva uses JavaScript template literals for value interpolation, with special syntax for events and props.

#### Understanding the Syntax

| Syntax | Evaluated By | Requires `ctx.`? | Example |
|--------|--------------|:----------------:|---------|
| `${...}` | JavaScript | ‚úì | `${ctx.count.value}` |
| `@event="..."` | TemplateEngine | ‚úó | `@click="increment"` |
| `:prop="..."` | TemplateEngine | ‚úó | `:user="userData.value"` |

**How reactivity works:** Eleva re-executes the entire template function when any signal changes. This updates all `${}` interpolations automatically.

#### Value Interpolation with `${...}`

Use `${...}` to interpolate values into your template:

```js
// ‚úì Standard approach
const Counter = {
  setup: ({ signal }) => ({ count: signal(0) }),
  template: (ctx) => `<p>Count: ${ctx.count.value}</p>`
};
```

**Advantages:**
- Native JavaScript syntax‚Äîno learning curve
- Full IDE support (autocomplete, type checking)
- Access to all JavaScript features (methods, conditionals, etc.)

#### Event Handlers with `@event`

Event handlers are evaluated against your component context (no `ctx.` needed):

```js
const Counter = {
  setup: ({ signal }) => {
    const count = signal(0);
    const increment = () => count.value++;
    return { count, increment };
  },
  template: (ctx) => `
    <p>Count: ${ctx.count.value}</p>
    <button @click="increment">+</button>
  `
};
```

You can also use inline expressions:

```js
template: (ctx) => `
  <button @click="() => count.value++">+</button>
`
```

#### Passing Props with `:prop`

Props are evaluated against your component context (no `ctx.` needed):

```js
const Parent = {
  setup: ({ signal }) => ({
    user: signal({ name: "John", age: 30 }),
    items: ["a", "b", "c"]
  }),
  template: (ctx) => `
    <child-comp
      :user="user.value"
      :items="items"
      :count="10 + 5">
    </child-comp>
  `,
  children: { "child-comp": "ChildComponent" }
};
```

**Key benefit:** No need for `JSON.stringify` ‚Äî objects and arrays are passed directly!

#### Context Reference Rules

> **Simple Rule:** `${}` needs `ctx.` ‚Äî `@events` and `:props` don't.

| Syntax | Uses `ctx.`? | Example |
|--------|:------------:|---------|
| `${...}` | ‚úì | `${ctx.count.value}` |
| `@event="..."` | ‚úó | `@click="increment"` |
| `:prop="..."` | ‚úó | `:user="userData.value"` |

**Why the difference?** JavaScript template literals (`${}`) are evaluated where `ctx` is the function parameter. TemplateEngine evaluates `@event` and `:prop` expressions with your context already unwrapped.

```js
template: (ctx) => `
  <p>${ctx.count.value}</p>              <!-- JavaScript evaluates with ctx -->
  <button @click="increment">+</button>  <!-- TemplateEngine evaluates without ctx -->
  <child :data="items.value"></child>    <!-- TemplateEngine evaluates without ctx -->
`
```

#### Common Mistakes

```js
// ‚ùå WRONG: Using ctx. in event handlers
template: (ctx) => `<button @click="ctx.handleClick">Click</button>`

// ‚úì CORRECT: No ctx. in event handlers
template: (ctx) => `<button @click="handleClick">Click</button>`
```

```js
// ‚ùå WRONG: Using ctx. in props
template: (ctx) => `<child :user="ctx.userData.value"></child>`

// ‚úì CORRECT: No ctx. in props
template: (ctx) => `<child :user="userData.value"></child>`
```

```js
// ‚ùå WRONG: Missing ctx. in template literals
template: (ctx) => `<p>Count: ${count.value}</p>`

// ‚úì CORRECT: Use ctx. in template literals
template: (ctx) => `<p>Count: ${ctx.count.value}</p>`
```

### Setup Context vs. Event Context

Understanding how data flows during component initialization and event handling is key:

#### Setup Context

- **When It's Used:**
  Passed to the component's `setup` function during initialization.
- **What It Contains:**
  Utilities (like the `signal` function), component props, emitter, and lifecycle hooks. The returned data forms the component's reactive state.

_Example:_

```js
const MyComponent = {
  setup: ({ signal }) => {
    const counter = signal(0);
    return { counter };
  },
  template: (ctx) => `
    <div>
      <p>Counter: ${ctx.counter.value}</p>
    </div>
  `,
};
```

#### Event Context

- **When It's Used:**
  Provided when an event handler is triggered (e.g., a button click).
- **What It Contains:**
  The reactive state from `setup` along with event-specific data (like `event.target`).

_Example:_

```js
const MyComponent = {
  setup: ({ signal }) => {
    const counter = signal(0);
    function increment(event) {
      console.log("Event type:", event.type);
      counter.value++;
    }
    return { counter, increment };
  },
  template: (ctx) => `
    <div>
      <p>Counter: ${ctx.counter.value}</p>
      <button @click="increment">Increment</button>
    </div>
  `,
};
```

### Signal (Reactivity)

The **Signal** provides fine-grained reactivity by updating only the affected DOM parts.

- **`new Signal(initialValue)`**: Creates a Signal instance.
- **`.value`**: Getter/setter for the current value.
- **`.watch(callback)`**: Registers a function to execute on changes.

_Example:_

```js
const count = new Signal(0);

count.watch((newVal) => console.log("Count updated:", newVal));

count.value = 1; // Logs: "Count updated: 1"
```

**Key Features:**
- Microtask-based update batching
- Automatic watcher cleanup
- Type-safe value handling
- Efficient update propagation
- Memory leak prevention through unsubscribe

**Automatic Render Batching:**

Eleva automatically batches multiple signal changes into a single render, optimizing performance without any code changes:

```js
// All 3 changes result in just 1 render
x.value = 10;
y.value = 20;
z.value = 30;
```

| Scenario | Without Batching | With Batching |
|----------|------------------|---------------|
| Drag events (60/sec √ó 3 signals) | 180 renders/sec | 60 renders/sec |
| Form reset (10 fields) | 10 renders | 1 render |
| API response (5 state updates) | 5 renders | 1 render |

### Emitter (Event Handling)

The **Emitter** enables inter-component communication through events and using a publish‚Äìsubscribe pattern.

- **`new Emitter()`**: Creates an Emitter instance.
- **`.on(event, handler)`**: Registers an event handler.
- **`.off(event, handler)`**: Removes an event handler.
- **`.emit(event, ...args)`**: Emits an event with optional arguments.

_Example:_

```js
const emitter = new Emitter();

emitter.on("greet", (name) => console.log(`Hello, ${name}!`)); // Logs: "Hello, Alice!"

emitter.emit("greet", "Alice");
```

**Key Features:**
- Synchronous event propagation
- Multiple handlers per event
- Automatic event cleanup
- Memory-efficient handler management
- Type-safe event data

### Renderer (DOM Diffing)

The **Renderer** efficiently updates the DOM through direct manipulation, avoiding the overhead of virtual DOM implementations. It uses a performant diffing algorithm to update only the necessary parts of the DOM tree.

- **`new Renderer()`**: Creates a Renderer instance.
- **`.patchDOM(container, newHtml)`**: Updates container content with the new HTML.

_Example:_

```js
const renderer = new Renderer();

const container = document.getElementById("app");
const newHtml = "<div>Updated content</div>";

renderer.patchDOM(container, newHtml); // Update a container with new HTML
```

**Key Features:**
- Direct DOM manipulation for optimal performance
- Efficient attribute updates
- Smart node comparison and replacement
- Support for key-based reconciliation
- Handles text nodes and element nodes appropriately

### Eleva (Core)

The **Eleva** class orchestrates component registration, mounting, plugin integration, lifecycle management, and events.

- **`new Eleva(name, config)`**: Creates an instance.
- **`use(plugin, options)`**: Integrates a plugin.
- **`component(name, definition)`**: Registers a new component.
- **`mount(container, compName, props)`**: Mounts a component to a DOM element (returns a Promise).

### Lifecycle Hooks

Eleva provides a set of optional lifecycle hooks that allow you to execute code at specific stages of a component's lifecycle. These hooks are available through the setup method's return object.

**Available Hooks:**
- `onBeforeMount`: Called before the component is mounted to the DOM
- `onMount`: Called after the component is mounted to the DOM
- `onBeforeUpdate`: Called before the component updates
- `onUpdate`: Called after the component updates
- `onUnmount`: Called before the component is unmounted from the DOM

Each hook receives a context object with the following properties:
- `container`: The component's container element
- `context`: The component's context object containing props, state, and utilities

**Sync & Async Support:** All hooks are awaited by the framework, meaning they support **both synchronous and asynchronous** functions. If you return a Promise (or use `async`), the framework will wait for it to resolve before continuing.

_Example:_

```js
app.component("MyComponent", {
  setup() {
    return {
      // Your component state
      count: 0,

      // Lifecycle hooks (all optional)
      onBeforeMount: async ({ container, context }) => {
        console.log("Component will mount");
        await someAsyncOperation();
      },
      onMount: async ({ container, context }) => {
        console.log("Component mounted");
        await initializeComponent();
      },
      onBeforeUpdate: async ({ container, context }) => {
        console.log("Component will update");
        await prepareForUpdate();
      },
      onUpdate: async ({ container, context }) => {
        console.log("Component updated");
        await afterUpdate();
      },
      onUnmount: async ({ container, context }) => {
        console.log("Component will unmount");
        await cleanup();
      },
    };
  },
  template(ctx) {
    return `<div>Count: ${ctx.count.value}</div>`;
  },
});
```

**Important Notes:**
1. Lifecycle hooks are optional and only need to be defined if you want to use them
2. Hooks must be returned from the setup method to be effective
3. Each hook receives a context object with the component's container and context
4. Hooks support both sync and async functions - async hooks are awaited before continuing
5. Common async use cases: data fetching, initialization, timers, and cleanup

_Example (with Reactive State and Async Operations):_

```js
app.component("Counter", {
  setup({ signal }) {
    const count = signal(0);

    return {
      count,
      onMount: async ({ container, context }) => {
        console.log("Counter mounted with initial value:", count.value);
        // Can perform async operations
        await initializeCounter();
      },
      onUpdate: async ({ container, context }) => {
        console.log("Counter updated to:", count.value);
        // Can perform async operations
        await saveCounterState();
      },
      onUnmount: async ({ container, context }) => {
        // Cleanup async operations
        await cleanupCounter();
      },
    };
  },
  template(ctx) {
    return `
      <div>
        <p>Count: ${ctx.count.value}</p>
        <button @click="() => count.value++">Increment</button>
      </div>
    `;
  },
});
```

_Example (Async Data Fetching with Loading State):_

```js
app.component("UserProfile", {
  setup({ signal }) {
    const user = signal(null);
    const loading = signal(true);
    const error = signal(null);

    return {
      user,
      loading,
      error,

      // Async onMount - framework awaits this before continuing
      onMount: async ({ container, context }) => {
        try {
          const response = await fetch("/api/user/123");
          if (!response.ok) throw new Error("Failed to fetch");
          context.user.value = await response.json();
        } catch (err) {
          context.error.value = err.message;
        } finally {
          context.loading.value = false;
        }
      },

      // Sync onUnmount - no async needed for simple cleanup
      onUnmount: ({ context }) => {
        console.log("Cleaning up user profile");
      }
    };
  },
  template(ctx) {
    if (ctx.loading.value) {
      return `<div class="spinner">Loading...</div>`;
    }
    if (ctx.error.value) {
      return `<div class="error">Error: ${ctx.error.value}</div>`;
    }
    return `
      <div class="profile">
        <h2>${ctx.user.value.name}</h2>
        <p>${ctx.user.value.email}</p>
      </div>
    `;
  }
});
```

_Example (Async Cleanup with AbortController):_

```js
app.component("LiveData", {
  setup({ signal }) {
    const data = signal([]);
    let abortController = null;

    return {
      data,

      onMount: async ({ context }) => {
        abortController = new AbortController();

        // Start polling for live data
        const poll = async () => {
          try {
            const res = await fetch("/api/live", {
              signal: abortController.signal
            });
            context.data.value = await res.json();
          } catch (err) {
            if (err.name !== "AbortError") console.error(err);
          }
        };

        // Initial fetch
        await poll();

        // Continue polling every 5 seconds
        const interval = setInterval(poll, 5000);
        abortController.intervalId = interval;
      },

      onUnmount: async () => {
        // Cancel pending requests and stop polling
        if (abortController) {
          abortController.abort();
          clearInterval(abortController.intervalId);
        }
      }
    };
  },
  template: (ctx) => `
    <ul>
      ${ctx.data.value.map(item => `<li>${item.name}</li>`).join("")}
    </ul>
  `
});
```

### Component Registration & Mounting

Register components globally or directly, then mount using a DOM element.

_Example (Global Registration):_

```js
const app = new Eleva("MyApp");
app.component("HelloWorld", {
  setup({ signal }) {
    const count = signal(0);
    return { count };
  },
  template: (ctx) => `
    <div>
      <h1>Hello, Eleva! üëã</h1>
      <p>Count: ${ctx.count.value}</p>
      <button @click="() => count.value++">Increment</button>
    </div>
  `,
});
app.mount(document.getElementById("app"), "HelloWorld").then((instance) => {
  console.log("Component mounted:", instance);
});
```

_Example (Direct Component Definition):_

```js
const DirectComponent = {
  template: () => `<div>No setup needed!</div>`,
};

const app = new Eleva("MyApp");
app
  .mount(document.getElementById("app"), DirectComponent)
  .then((instance) => console.log("Mounted Direct:", instance));
```

### Children Components & Passing Props

Eleva provides two powerful ways to mount child components in your application:

1. **Explicit Component Mounting**
   - Components are explicitly defined in the parent component's children configuration
   - Provides clear parent-child relationships
   - Allows for dynamic prop passing via attributes prefixed with `:`.

   _Example:_

   ```js
   // Child Component
   app.component("TodoItem", {
     setup: (context) => {
       const { title, completed, onToggle } = context.props;
       return { title, completed, onToggle };
     },
     template: (ctx) => `
       <div class="todo-item ${ctx.completed ? 'completed' : ''}">
         <input type="checkbox" 
                ${ctx.completed ? 'checked' : ''} 
                @click="onToggle" />
         <span>${ctx.title}</span>
       </div>
     `,
   });

   // Parent Component using explicit mounting
   app.component("TodoList", {
     setup: ({ signal }) => {
       const todos = signal([
         { id: 1, title: "Learn Eleva", completed: false },
         { id: 2, title: "Build an app", completed: false },
       ]);

       const toggleTodo = (id) => {
         todos.value = todos.value.map((todo) =>
           todo.id === id ? { ...todo, completed: !todo.completed } : todo
         );
       };

       return { todos, toggleTodo };
     },
     template: (ctx) => `
       <div class="todo-list">
         <h2>My Todo List</h2>
         ${ctx.todos.value.map((todo) => `
           <div key="${todo.id}" class="todo-item"
                :title="${todo.title}"
                :completed="${todo.completed}"
                @click="() => toggleTodo(todo.id)">
           </div>
         `).join("")}
       </div>
     `,
     children: {
       ".todo-item": "TodoItem", // Explicitly define child component
     },
   });
   ```

2. **Component Mounting**
   - Components are mounted explicitly using their registered names
   - Provides clear and controlled component relationships
   - Supports dynamic prop passing and automatic cleanup

   _Example:_

   ```js
   // Child Component
   app.component("UserCard", {
     setup: (context) => {
       const { user, onSelect } = context.props;
       return { user, onSelect };
     },
     template: (ctx) => `
       <div class="user-card" @click="onSelect">
         <img src="${ctx.user.avatar}" alt="${ctx.user.name}" />
         <h3>${ctx.user.name}</h3>
         <p>${ctx.user.role}</p>
       </div>
     `,
   });

   // Parent Component using explicit mounting
   app.component("UserList", {
     setup: ({ signal }) => {
       const users = signal([
         { id: 1, name: "John Doe", role: "Developer", avatar: "john.jpg" },
         { id: 2, name: "Jane Smith", role: "Designer", avatar: "jane.jpg" },
       ]);

       const selectUser = (user) => {
         console.log("Selected user:", user);
       };

       return { users, selectUser };
     },
     template: (ctx) => `
       <div class="user-list">
         <h2>Team Members</h2>
         ${ctx.users.value.map((user) => `
           <div key="${user.id}" class="user-card-container"></div>
         `).join("")}
       </div>
     `,
     children: {
       "#user-card-container": {
         setup: (context) => {
           const user = context.props.user;
           return { user };
         },
         template: (ctx) => `
           <UserCard
             :user="user"
             :onSelect="selectUser"
           ></UserCard>
         `,
         children: {
          "UserCard": "UserCard",
         },
       },
     },
   });
   ```

#### Types of Children Component Mounting

Eleva supports four main approaches to mounting child components, each with its own use cases and benefits:

1. **Direct Component Mounting**
   ```js
   children: {
     "UserCard": "UserCard"  // Direct mounting without container
   }
   ```
   - **Use when:** You want to mount a component directly in the parent's template
   - **Benefits:**
     - Simplest and most performant approach
     - No additional DOM elements
     - Direct prop passing
   - **Example use case:** Simple component composition

2. **Container-Based Mounting**
   ```js
   children: {
     "#container": "UserCard"  // Mounting in a container element
   }
   ```
   - **Use when:** You need a container element for styling or layout
   - **Benefits:**
     - Better control over component positioning
     - Ability to add wrapper elements
     - Easier styling and layout management
   - **Example use case:** Complex layouts or when container styling is needed

3. **Dynamic Component Mounting**
   ```js
   children: {
     ".dynamic-container": {
       setup: (ctx) => ({ /* dynamic setup */ }),
       template: (ctx) => `<UserCard :props="${ctx.props}" />`,
       children: { "UserCard": "UserCard" }
     }
   }
   ```
   - **Use when:** You need dynamic component behavior or setup
   - **Benefits:**
     - Full control over component lifecycle
     - Ability to add custom logic
     - Dynamic prop computation
   - **Example use case:** Complex component interactions or dynamic data handling

4. **Variable-Based Component Mounting**
   ```js
   // Define component
   const UserCard = {
     setup: (ctx) => ({ /* setup logic */ }),
     template: (ctx) => `<div>User Card</div>`,
   };

   // Parent component using variable-based mounting
   app.component("UserList", {
     template: (ctx) => `
       <div class="user-list">
         <div class="user-card-container"></div>
       </div>
     `,
     children: {
       ".user-card-container": UserCard, // Mount component directly from variable
     },
   });
   ```
   - **Use when:**
     - You have component definitions stored in variables
     - Components are created dynamically
     - You want to reuse component definitions
   - **Benefits:**
     - No need to register components globally
     - More flexible component composition
     - Better code organization
   - **Example use case:**
     - Dynamic component creation
     - Component libraries
     - Reusable component patterns

**Best Practices for Component Mounting:**

1. **Choose the Right Approach:**
   - Use direct mounting for simple component relationships
   - Use container-based mounting when layout control is needed
   - Use dynamic mounting for complex component interactions

2. **Performance Considerations:**
   - Direct mounting is most performant
   - Container-based mounting adds minimal overhead
   - Dynamic mounting has the most flexibility but requires careful optimization

3. **Maintainability:**
   - Keep component hierarchies shallow when possible
   - Use meaningful container names
   - Document complex mounting patterns

#### Supported Children Selector Types

Eleva supports various selector types for defining child components in the `children` configuration:

1. **Component Name Selectors**

   ```html
    <UserCard></UserCard>
   ```

   ```js
   children: {
     "UserCard": "UserCard"  // Mounts UserCard component directly
   }
   ```
   - **Best for:** Direct component mounting without additional container elements
   - **Use when:** You want to mount a component directly without a wrapper element

2. **ID Selectors**

   ```html
    <div id="user-card-container"></div>
   ```

   ```js
   children: {
     "#user-card-container": "UserCard"  // Mounts in element with id="user-card-container"
   }
   ```
   - **Best for:** Unique, specific mounting points
   - **Use when:** You need to target a specific element in the template

3. **Class Selectors**

   ```html
    <div class="todo-item"></div>
   ```

   ```js
   children: {
     ".todo-item": "TodoItem"  // Mounts in elements with class="todo-item"
   }
   ```
   - **Best for:** Multiple instances of the same component
   - **Use when:** You have a list or grid of similar components

4. **Attribute Selectors**

   ```html
    <div data-component="user-card"></div>
   ```

   ```js
   children: {
     "[data-component='user-card']": "UserCard"  // Mounts in elements with data-component="user-card"
   }
   ```
   - **Best for:** Semantic component identification
   - **Use when:** You want to use custom attributes for component mounting

**Best Practices for Selector Types:**

1. **Prefer Component Name Selectors** when:
   - Mounting components directly without containers
   - Working with simple, direct component relationships
   - Performance is a priority (fewer DOM queries)

2. **Use ID Selectors** when:
   - You need to target specific, unique mounting points
   - Working with complex layouts
   - Components need to be mounted in specific locations

3. **Choose Class Selectors** when:
   - Working with lists or repeated components
   - Components share the same mounting pattern
   - You need to style or target multiple instances

4. **Consider Attribute Selectors** when:
   - You need semantic component identification
   - Working with custom component attributes
   - Building complex component hierarchies

**Performance Considerations:**

| Selector Type | Performance | Best For |
|---------------|-------------|----------|
| **ID** `#app` | Fastest | Root components, unique elements |
| **Component Name** `UserCard` | Very Fast | Child component mounting |
| **Class** `.container` | Fast | Lists, multiple instances |
| **Attribute** `[data-component]` | Moderate | Dynamic/generated elements |
| **Complex** `div.app > .content` | Slowest | Avoid if possible |

```js
// ‚úÖ Best - ID selector for root mounting
app.mount("#app", "App");

// ‚úÖ Good - Component name or class for children
children: {
  "UserCard": "UserCard",
  ".todo-item": "TodoItem"
}

// ‚ùå Avoid - Complex or tag-only selectors
children: {
  "div.wrapper > .item": "Item",  // Slow
  "div": "SomeComponent"          // Too generic
}
```

> **[See Best Practices Guide ‚Üí](./examples/patterns/best-practices.md#selector-performance)** for detailed selector performance benchmarks, examples, and guidelines

**Key Benefits of Component Mounting:**
- **Explicit Control**: Clear parent-child relationships and component hierarchy
- **Dynamic Props**: Support for dynamic prop passing
- **Automatic Cleanup**: Components are automatically unmounted and cleaned up when their container is removed

### Style Injection & Scoped CSS

Eleva supports component-scoped styling through an optional `style` property. The styles are injected into the component's container to avoid global leakage.

The `style` property can be defined in two ways:

#### 1. Static Styles (String)

Use a string when your styles don't depend on component state. This is slightly more performant since no function call is needed.

```js
const MyComponent = {
  template: () => `<div class="my-component">Styled Component</div>`,
  style: `
    .my-component {
      color: blue;
      padding: 1rem;
    }
  `
};
```

#### 2. Dynamic Styles (Function)

Use a function when your styles need to react to component state. The function receives the component context (`ctx`) and can use template interpolation.

```js
const MyComponent = {
  setup: ({ signal }) => {
    const isActive = signal(false);
    const padding = signal(2);
    return { isActive, padding };
  },
  template: (ctx) => `
    <div class="my-component" @click="() => isActive.value = !isActive.value">
      Click to toggle (${ctx.isActive.value ? 'Active' : 'Inactive'})
    </div>
  `,
  style: (ctx) => `
    .my-component {
      color: ${ctx.isActive.value ? 'green' : 'gray'};
      padding: ${ctx.padding.value}rem;
      transition: color 0.3s ease;
    }
  `
};
```

**When to use which:**

| Use Case | Style Type | Example |
|----------|------------|---------|
| Fixed colors, layouts, typography | String | `style: \`.btn { color: blue; }\`` |
| Theme-based colors | Function | `style: (ctx) => \`.btn { color: ${ctx.theme.value}; }\`` |
| State-dependent styles | Function | `style: (ctx) => \`.item { opacity: ${ctx.isVisible.value ? 1 : 0}; }\`` |
| Responsive values from signals | Function | `style: (ctx) => \`.box { width: ${ctx.width.value}px; }\`` |

### Inter-Component Communication

Inter-component communication is facilitated by the built-in **Emitter**. Components can publish and subscribe to events, enabling decoupled interactions.

_Example:_

```js
// Component A emits an event
app.component("ComponentA", {
  setup: ({ emitter }) => {
    function sendMessage() {
      emitter.emit("customEvent", "Hello from A");
    }
    return { sendMessage };
  },
  template: () => `<button @click="sendMessage">Send Message</button>`,
});

// Component B listens for the event
app.component("ComponentB", {
  setup: ({ emitter }) => {
    emitter.on("customEvent", (msg) => console.log(msg));
    return {};
  },
  template: () => `<div>Component B</div>`,
});

app.mount(document.getElementById("app"), "ComponentA");
app.mount(document.getElementById("app"), "ComponentB");
```

<details>
<summary><strong>Component Communication Flow</strong> (click to expand)</summary>

The following diagram illustrates how data flows between parent and child components using props (down) and events (up):

<pre>
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      PARENT COMPONENT                       ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ                 [setup() ‚Üí state signals]                   ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îÇ                            ‚ñº                                ‚îÇ
‚îÇ               [Template with :prop="value"]                 ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ props (down)
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      CHILD COMPONENT                        ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ               [setup(ctx) ‚Üí ctx.props.value]                ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îÇ                            ‚ñº                                ‚îÇ
‚îÇ                   [Template uses prop]                      ‚îÇ
‚îÇ                            ‚îÇ                                ‚îÇ
‚îÇ                            ‚ñº                                ‚îÇ
‚îÇ             [Event: emitter.emit("update", data)]           ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ events (up)
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PARENT: emitter.on("update", handler) ‚Üí updates signals   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>

This pattern ensures:
- **Unidirectional data flow**: Props flow down, events bubble up
- **Decoupled components**: Children don't directly modify parent state
- **Predictable updates**: State changes always originate from signal updates

</details>

### Component Context

The component context provides access to essential tools and data for component development:

- **`props`**: Component properties passed during mounting
- **`emitter`**: Event emitter instance for component event handling
- **`signal`**: Factory function to create reactive Signal instances
- **Lifecycle Hooks**:
  - `onBeforeMount`: Called before component mounting
  - `onMount`: Called after component mounting
  - `onBeforeUpdate`: Called before component update
  - `onUpdate`: Called after component update
  - `onUnmount`: Called during component unmounting

_Example:_

```js
app.component("MyComponent", {
  setup({ signal, emitter }) {
    const count = signal(0);
    return {
      count,
      onMount: async ({ container, context }) => {
        console.log("Component mounted!");
      },
      onUpdate: ({ container, context }) => {
        console.log("Component updated!");
      },
    };
  },
});
```

### Mounting Process

The `mount` method returns a Promise that resolves to a `MountResult` object containing:

- **`container`**: The mounted component's container element
- **`data`**: The component's reactive state and context
- **`unmount`**: Function to clean up and unmount the component

The container element receives a `_eleva_instance` property that references the mounted instance.

_Example:_

```js
const instance = await app.mount(document.getElementById("app"), "MyComponent");
// Later...
await instance.unmount();
```

---

## 7. Architecture & Data Flow

Eleva's design emphasizes clarity, modularity, and performance. This section explains how data flows through the framework and how its key components interact, providing more clarity on the underlying mechanics.

### Key Components

1. **Component Definition:**  
   Components are plain JavaScript objects that describe a UI segment. They typically include:

   - A **`template`** function that returns HTML with interpolation placeholders.
   - An optional **`setup()`** function for initializing state (using reactive signals).
   - An optional **`style`** function for scoped CSS.
   - An optional **`children`** object for nested components.

2. **Signals (Reactivity):**
   Signals are reactive data holders that notify watchers when their values change, triggering re-renders of the affected UI.

3. **TemplateEngine (Evaluation):**
   This module evaluates expressions in `@events` and `:props` attributes against the component context, enabling event binding and prop passing.

4. **Renderer (DOM Diffing and Patching):**
   The Renderer compares the new HTML structure with the current DOM and patches only the parts that have changed, ensuring high performance and efficient updates without the overhead of a virtual DOM.

5. **Emitter (Event Handling):**
   The Emitter implements a publish‚Äìsubscribe pattern to allow components to communicate by emitting and listening to custom events.

### Data Flow Process

1. **Initialization:**

   - **Registration:** Components are registered via `app.component()`.
   - **Mounting:** `app.mount()` creates a context (including props, lifecycle hooks, and an `emitter` property) and executes `setup()` (if present) to create a reactive state.

2. **Rendering:**

   - The **template** function is called with the combined context and reactive state.
   - JavaScript template literals (`${}`) interpolate values directly during template execution.
   - The **TemplateEngine** evaluates `@events` and `:props` expressions against the context.
   - The **Renderer** takes the resulting HTML and patches it into the DOM, ensuring only changes are applied.

3. **Reactivity:**

   - When a signal's value changes (e.g., through a user event), its watcher triggers a re-run of the template.
   - The Renderer diffs the new HTML against the current DOM and applies only the necessary changes.

4. **Events:**

   - Eleva binds event listeners (e.g., `@click`) during rendering.
   - When an event occurs, the handler is executed with the current state and event details.
   - Components can also emit custom events via the Emitter for cross-component communication.

### Visual Overview

```
[Component Registration]
         ‚îÇ
         ‚ñº
[Mounting & Context Creation]
         ‚îÇ
         ‚ñº
[setup() Execution ‚Üí Creates Signals]
         ‚îÇ
         ‚ñº
[Template Function Produces HTML]
         ‚îÇ
         ‚ñº
    onBeforeMount
         ‚îÇ
         ‚ñº
[Renderer: Diff ‚Üí Patch DOM]
         ‚îÇ
         ‚ñº
[Process @events & :props]
         ‚îÇ
         ‚ñº
[Inject Scoped Styles]
         ‚îÇ
         ‚ñº
[Mount Child Components]
         ‚îÇ
         ‚ñº
      onMount
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            ‚Ü∫ REACTIVE CYCLE                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                            ‚îÇ
‚îÇ  [Idle: Waiting for Signal Change] ‚óÑ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ  [User Event / Signal Change / Emit]   ‚îÇ   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ  [queueMicrotask Batches Updates]      ‚îÇ   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ  [Template Re-evaluation]              ‚îÇ   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ     onBeforeUpdate                     ‚îÇ   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ  [Renderer: Diff ‚Üí Patch DOM]          ‚îÇ   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ  [Process @events & :props]            ‚îÇ   ‚îÇ
‚îÇ           ‚îÇ                            ‚îÇ   ‚îÇ
‚îÇ           ‚ñº                            ‚îÇ   ‚îÇ
‚îÇ       onUpdate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

<details>
<summary><strong>Detailed Architecture Flow</strong> (click to expand)</summary>

For contributors or developers seeking a deeper understanding, here is the comprehensive flow including all initialization steps:

<pre>
              [Component Registration]
                         ‚îÇ
                         ‚ñº
              [Mounting & Context Creation]
              ‚Ä¢ props passed to context
              ‚Ä¢ emitter reference (shared instance)
              ‚Ä¢ signal factory function
                         ‚îÇ
                         ‚ñº
              [setup() Execution]
              ‚Ä¢ Creates signals via factory
              ‚Ä¢ Returns state + lifecycle hooks
                         ‚îÇ
                         ‚ñº
             [Template Function Produces HTML]
             ‚Ä¢ Template literals ${} evaluated
             ‚Ä¢ Returns HTML string
                         ‚îÇ
                         ‚ñº
                  ‚îÄ onBeforeMount ‚îÄ
                         ‚îÇ
                         ‚ñº
            [Renderer: Diff ‚Üí Patch]
            ‚Ä¢ Two-pointer diffing algorithm
            ‚Ä¢ Key-based reconciliation
            ‚Ä¢ Minimal DOM mutations
                         ‚îÇ
                         ‚ñº
            [TemplateEngine Processes]
            ‚Ä¢ Evaluates @event expressions
            ‚Ä¢ Binds event listeners to DOM
            ‚Ä¢ Evaluates :prop expressions
                         ‚îÇ
                         ‚ñº
               [Inject Scoped Styles]
                         ‚îÇ
                         ‚ñº
              [Mount Child Components]
                         ‚îÇ
                         ‚ñº
                    ‚îÄ onMount ‚îÄ
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 ‚Ü∫ REACTIVE CYCLE                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                    ‚îÇ
‚îÇ       [Idle: Waiting for Signal Change] ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ                        ‚îÇ                       ‚îÇ   ‚îÇ
‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ   ‚îÇ
‚îÇ    ‚ñº                   ‚ñº                   ‚ñº   ‚îÇ   ‚îÇ
‚îÇ [User Event]    [Signal.value = x]  [emitter]  ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ                   ‚îÇ                   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ   ‚îÇ
‚îÇ                        ‚ñº                       ‚îÇ   ‚îÇ
‚îÇ             [queueMicrotask Batching]          ‚îÇ   ‚îÇ
‚îÇ             ‚Ä¢ Multiple changes collapsed       ‚îÇ   ‚îÇ
‚îÇ             ‚Ä¢ Single render scheduled          ‚îÇ   ‚îÇ
‚îÇ                        ‚îÇ                       ‚îÇ   ‚îÇ
‚îÇ                        ‚ñº                       ‚îÇ   ‚îÇ
‚îÇ             [Template Re-evaluation]           ‚îÇ   ‚îÇ
‚îÇ                        ‚îÇ                       ‚îÇ   ‚îÇ
‚îÇ                        ‚ñº                       ‚îÇ   ‚îÇ
‚îÇ                ‚îÄ onBeforeUpdate ‚îÄ              ‚îÇ   ‚îÇ
‚îÇ                        ‚îÇ                       ‚îÇ   ‚îÇ
‚îÇ                        ‚ñº                       ‚îÇ   ‚îÇ
‚îÇ              [Renderer: Diff ‚Üí Patch]          ‚îÇ   ‚îÇ
‚îÇ                        ‚îÇ                       ‚îÇ   ‚îÇ
‚îÇ                        ‚ñº                       ‚îÇ   ‚îÇ
‚îÇ            [TemplateEngine Processes]          ‚îÇ   ‚îÇ
‚îÇ            ‚Ä¢ Re-binds @events                  ‚îÇ   ‚îÇ
‚îÇ            ‚Ä¢ Re-evaluates :props               ‚îÇ   ‚îÇ
‚îÇ                        ‚îÇ                       ‚îÇ   ‚îÇ
‚îÇ                        ‚ñº                       ‚îÇ   ‚îÇ
‚îÇ                   ‚îÄ onUpdate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>

</details>

### Benefits

- **Modularity:** Each component encapsulates its own logic and state, making it easy to reuse and maintain.
- **Efficiency:** Only the changed parts of the DOM are updated, ensures smooth performance even in complex applications.
- **Predictability:** One-way data flow (state ‚Üí template ‚Üí DOM) simplifies debugging.
- **Extensibility:** Clear separation of concerns facilitates custom logic and plugins.

---

## 8. Plugin System

The Plugin System in Eleva provides a powerful way to extend the framework's functionality. Plugins can add new features, modify existing behavior, or integrate with external libraries.

### Plugin Structure

A plugin in Eleva is an object that must have two required properties:

```js
const MyPlugin = {
  name: "myPlugin", // Unique identifier for the plugin
  install(eleva, options) {
    // Plugin installation logic
  },
};
```

- `name`: A unique string identifier for the plugin
- `install`: A function that receives the Eleva instance and optional configuration

### Installing Plugins

Plugins are installed using the `use` method on an Eleva instance:

```js
const app = new Eleva("myApp");
app.use(MyPlugin, { /* optional configuration */ });
```

The `use` method:
- Calls the plugin's `install` function with the Eleva instance and provided options
- Stores the plugin in an internal registry
- Returns the Eleva instance for method chaining

### Plugin Capabilities

Plugins can:

1. **Extend the Eleva Instance**
   ```js
   install(eleva) {
     eleva.newMethod = () => { /* ... */ };
   }
   ```

2. **Add Component Features**
   ```js
   install(eleva) {
     eleva.component("enhanced-component", {
       template: (ctx) => `...`,
       setup: (ctx) => ({ /* ... */ })
     });
   }
   ```

3. **Modify Component Behavior**
   ```js
   install(eleva) {
     const originalMount = eleva.mount;
     eleva.mount = function(container, compName, props) {
       // Add pre-mount logic
       const result = originalMount.call(this, container, compName, props);
       // Add post-mount logic
       return result;
     };
   }
   ```

4. **Add Global State or Services**
   ```js
   install(eleva) {
     eleva.services = {
       api: new ApiService(),
       storage: new StorageService()
     };
   }
   ```

### Plugin Development Best Practices

1. **Naming Conventions**
   - Use unique, descriptive names for plugins
   - Follow the pattern: `eleva-{plugin-name}` for published plugins

2. **Error Handling**
   - Implement proper error handling in plugin methods
   - Provide meaningful error messages for debugging

3. **Documentation**
   - Document plugin options and methods
   - Include usage examples
   - Specify any dependencies or requirements

4. **Performance**
   - Keep plugin initialization lightweight
   - Use lazy loading for heavy features
   - Clean up resources when components unmount

### Example Plugin

Here's a complete example of a custom plugin:

```js
const Logger = {
  name: "logger",
  install(eleva, options = {}) {
    const { level = "info" } = options;

    // Add logging methods to Eleva instance
    eleva.log = {
      info: (msg) => console.log(`[INFO] ${msg}`),
      warn: (msg) => console.warn(`[WARN] ${msg}`),
      error: (msg) => console.error(`[ERROR] ${msg}`),
    };

    // Enhance component mounting with logging
    const originalMount = eleva.mount;
    eleva.mount = async function(container, compName, props) {
      eleva.log.info(`Mounting component: ${compName}`);
      const result = await originalMount.call(this, container, compName, props);
      eleva.log.info(`Component mounted: ${compName}`);
      return result;
    };
  },
};

// Usage
const app = new Eleva("myApp");
app.use(Logger, { level: "debug" });
```

### Plugin Lifecycle

1. **Installation**
   - Plugin is registered with the Eleva instance
   - `install` function is called with the instance and options
   - Plugin is stored in the internal registry

2. **Runtime**
   - Plugin methods are available throughout the application lifecycle
   - Can interact with components and the Eleva instance
   - Can respond to component lifecycle events

3. **Cleanup**
   - Plugins should clean up any resources they've created
   - Remove event listeners and subscriptions
   - Reset any modified behavior

### TypeScript Support

Eleva provides TypeScript declarations for plugin development:

```typescript
interface ElevaPlugin {
  name: string;
  install(eleva: Eleva, options?: Record<string, any>): void;
}
```

This ensures type safety when developing plugins in TypeScript.

### Built-in Plugins

Eleva comes with several powerful built-in plugins that extend the framework's capabilities:

#### üéØ Attr Plugin

Advanced attribute handling for Eleva components with ARIA support, data attributes, boolean attributes, and dynamic property detection.

```javascript
import { Attr } from 'eleva/plugins';

const app = new Eleva("myApp");
app.use(Attr, {
    enableAria: true,      // Enable ARIA attribute handling
    enableData: true,      // Enable data attribute handling
    enableBoolean: true,   // Enable boolean attribute handling
    enableDynamic: true    // Enable dynamic property detection
});

// Use advanced attributes in components
app.component("myComponent", {
    template: (ctx) => `
        <button 
            aria-expanded="${ctx.isExpanded.value}"
            data-user-id="${ctx.userId.value}"
            disabled="${ctx.isLoading.value}"
            class="btn ${ctx.variant.value}"
        >
            ${ctx.text.value}
        </button>
    `
});
```

**Features:**
- üéØ **ARIA Support**: Automatic ARIA attribute handling with proper property mapping
- üìä **Data Attributes**: Seamless data attribute management
- ‚úÖ **Boolean Attributes**: Intelligent boolean attribute processing
- üîç **Dynamic Properties**: Automatic property detection and mapping
- üßπ **Attribute Cleanup**: Automatic removal of unused attributes

üìö **[Full Attr Documentation ‚Üí](./plugins/attr.md)** - Comprehensive guide with ARIA attributes, data attributes, boolean handling, and dynamic properties.

#### üöÄ Router Plugin

Advanced client-side routing with reactive state, navigation guards, and component resolution.

```javascript
import { Router } from 'eleva/plugins';

const app = new Eleva("myApp");

// Define components
const HomePage = { template: () => `<h1>Home</h1>` };
const AboutPage = { template: () => `<h1>About</h1>` };
const UserPage = { 
    template: (ctx) => `<h1>User: ${ctx.router.params.id}</h1>` 
};

// Install router with advanced configuration
const router = app.use(Router, {
    mount: '#app',                    // Mount element selector
    mode: 'hash',                     // 'hash', 'history', or 'query'
    routes: [
        { 
            path: '/', 
            component: HomePage,
            meta: { title: 'Home' }
        },
        { 
            path: '/about', 
            component: AboutPage,
            beforeEnter: (to, from) => {
                // Navigation guard
                return true;
            }
        },
        { 
            path: '/users/:id', 
            component: UserPage,
            afterEnter: (to, from) => {
                // Lifecycle hook
                console.log('User page entered');
            }
        }
    ],
    onBeforeEach: (to, from) => {
        // Global navigation guard
        return true;
    }
});

// Access reactive router state
router.currentRoute.subscribe(route => {
    console.log('Route changed:', route);
});

// Programmatic navigation
router.navigate('/users/123', { replace: true });
```

**Features:**
- üöÄ **Multiple Routing Modes**: Hash, History API, and Query parameter routing
- üõ°Ô∏è **Navigation Guards**: Global and route-specific guards
- üîÑ **Reactive State**: Real-time route state updates
- üß© **Component Resolution**: Support for inline components and async imports
- üéØ **Layout System**: Global and route-specific layouts
- üîå **Plugin System**: Router-level plugin extensibility
- üõ†Ô∏è **Error Handling**: Comprehensive error management

üìö **[Full Router Documentation ‚Üí](./plugins/router.md)** - Comprehensive guide with 13 events, 7 reactive signals, navigation guards, scroll management, and more.

#### üè™ Store Plugin

Reactive state management for sharing data across your entire Eleva application with centralized data store, persistence, and cross-component reactive updates.

```javascript
import { Store } from 'eleva/plugins';

const app = new Eleva("myApp");

// Install store with configuration
app.use(Store, {
    state: {
        theme: "light",
        counter: 0,
        user: {
            name: "John Doe",
            email: "john@example.com"
        }
    },
    actions: {
        increment: (state) => state.counter.value++,
        decrement: (state) => state.counter.value--,
        toggleTheme: (state) => {
            state.theme.value = state.theme.value === "light" ? "dark" : "light";
        },
        updateUser: (state, updates) => {
            state.user.value = { ...state.user.value, ...updates };
        }
    },
    // Optional: Namespaced modules
    namespaces: {
        auth: {
            state: { token: null, isLoggedIn: false },
            actions: {
                login: (state, token) => {
                    state.auth.token.value = token;
                    state.auth.isLoggedIn.value = true;
                },
                logout: (state) => {
                    state.auth.token.value = null;
                    state.auth.isLoggedIn.value = false;
                }
            }
        }
    },
    // Optional: State persistence
    persistence: {
        enabled: true,
        key: "myApp-store",
        storage: "localStorage",  // or "sessionStorage"
        include: ["theme", "user"] // Only persist specific keys
    }
});

// Use store in components
app.component("Counter", {
    setup({ store }) {
        return {
            count: store.state.counter,
            theme: store.state.theme,
            increment: () => store.dispatch("increment"),
            decrement: () => store.dispatch("decrement")
        };
    },
    template: (ctx) => `
        <div class="${ctx.theme.value}">
            <h3>Counter: ${ctx.count.value}</h3>
            <button @click="decrement">-</button>
            <button @click="increment">+</button>
        </div>
    `
});

// Create state and actions at runtime
app.component("TodoManager", {
    setup({ store }) {
        // Register new module dynamically
        store.registerModule("todos", {
            state: { items: [], filter: "all" },
            actions: {
                addTodo: (state, text) => {
                    state.todos.items.value.push({
                        id: Date.now(),
                        text,
                        completed: false
                    });
                },
                toggleTodo: (state, id) => {
                    const todo = state.todos.items.value.find(t => t.id === id);
                    if (todo) todo.completed = !todo.completed;
                }
            }
        });

        // Create individual state properties
        const notification = store.createState("notification", null);

        // Create individual actions
        store.createAction("showNotification", (state, message) => {
            state.notification.value = message;
            setTimeout(() => state.notification.value = null, 3000);
        });

        return {
            todos: store.state.todos.items,
            notification,
            addTodo: (text) => store.dispatch("todos.addTodo", text),
            notify: (msg) => store.dispatch("showNotification", msg)
        };
    }
});

// Subscribe to store changes
const unsubscribe = app.store.subscribe((mutation, state) => {
    console.log('Store updated:', mutation.type, state);
});

// Access store globally
console.log(app.store.getState()); // Get current state values
app.dispatch("increment");          // Dispatch actions globally
```

**Features:**
- üîÑ **Reactive State**: Uses Eleva's native signals for fine-grained reactivity
- üéØ **Action-Based Mutations**: Structured state updates through actions
- üì¶ **Namespaced Modules**: Organize state with modular architecture
- üíæ **Built-in Persistence**: LocalStorage/SessionStorage integration
- ‚ö° **Component-Level Registration**: Register state and actions from components
- üîó **Cross-Component Updates**: Automatic UI updates across all components
- üîß **Runtime Extensibility**: Add state and actions dynamically
- üéõÔ∏è **DevTools Integration**: Debug with browser developer tools

üìö **[Full Store Documentation ‚Üí](./plugins/store.md)** - Comprehensive guide with 10 API methods, persistence options, namespaces, subscriptions, and migration guides.

#### Plugin Installation

```javascript
// Import plugins
import { Attr, Router, Store } from 'eleva/plugins';

// Install multiple plugins
const app = new Eleva("myApp");
app.use(Attr);
app.use(Router, routerOptions);
app.use(Store, storeOptions);

// Or install with options
app.use(Attr, {
    enableAria: true,
    enableData: true
});

app.use(Store, {
    state: { counter: 0, theme: "light" },
    actions: {
        increment: (state) => state.counter.value++
    },
    persistence: { enabled: true }
});
```

#### Bundle Sizes

- **Core framework only**: ~6KB (minified)
- **Core + Attr plugin**: ~8KB (minified)
- **Core + Router plugin**: ~21KB (minified)
- **Core + Store plugin**: ~12KB (minified)
- **Core + All plugins**: ~21KB (minified)

**Individual Plugin Sizes:**
- **Attr plugin only**: ~2.2KB (minified)
- **Router plugin only**: ~15KB (minified)
- **Store plugin only**: ~6KB (minified)

---

## 9. Debugging & Developer Tools

- **Console Logging:** Use `console.log` in lifecycle hooks and event handlers.
- **Watchers:** Utilize signal watchers to monitor state changes.
- **Browser Dev Tools:** Inspect the DOM and network activity.
- **Verbose Mode:** Enable debug mode for detailed logs.
- **Error Handling:** Wrap code in try-catch blocks where necessary.

---

## 10. Best Practices & Use Cases

> **Quick Reference:** For a comprehensive, copy-paste ready guide, see the **[Best Practices Guide ‚Üí](./examples/patterns/best-practices.md)** which covers selectors, components, lifecycle, signals, and more.

### Best Practices

#### Component Structure Order

For consistency and readability, always define component properties in this order:

```js
app.component("MyComponent", {
  // 1. Setup - Initialize state and functions
  setup({ signal, emitter, props }) {
    const state = signal(initialValue);
    return { state, /* ...other exports */ };
  },

  // 2. Template - Define the component's HTML structure
  template: (ctx) => `
    <div>${ctx.state.value}</div>
  `,

  // 3. Style - Component-scoped CSS (optional)
  style: `
    div { color: blue; }
  `,

  // 4. Children - Child component mappings (optional)
  children: {
    ".child-container": "ChildComponent"
  }
});
```

**Why this order?**
- `setup` initializes the data that `template` and `style` might reference
- `template` defines the structure that `style` will style
- `style` applies to the template's elements
- `children` maps to elements created in the template

#### Setup Function: Patterns & Best Practices

The `setup` function initializes your component's state, functions, and lifecycle hooks. Here's how to use it effectively.

##### When to Use Setup

| Scenario | Use Setup? | Example |
|----------|------------|---------|
| Component has reactive state | ‚úÖ Yes | `signal(0)`, `signal([])` |
| Component handles events | ‚úÖ Yes | Click handlers, form submission |
| Component uses lifecycle hooks | ‚úÖ Yes | `onMount`, `onUnmount` |
| Component receives props | ‚úÖ Yes | Access via `props` parameter |
| Component emits events | ‚úÖ Yes | Access via `emitter` parameter |
| Purely static display | ‚ùå Optional | Can omit setup entirely |

```js
// ‚úÖ With setup - component has state and behavior
app.component("Counter", {
  setup: ({ signal }) => ({
    count: signal(0),
    increment: function() { this.count.value++; }
  }),
  template: (ctx) => `<button @click="increment">${ctx.count.value}</button>`
});

// ‚úÖ Without setup - purely static component
app.component("Logo", {
  template: () => `<img src="/logo.png" alt="Logo" />`
});
```

##### Destructuring the Context Parameter

The setup function receives a context object with utilities. Destructure only what you need:

```js
// ‚úÖ Destructure only what's needed
setup: ({ signal }) => {
  const count = signal(0);
  return { count };
}

// ‚úÖ Multiple utilities
setup: ({ signal, emitter, props }) => {
  const items = signal(props.initialItems || []);
  emitter.on("refresh", () => loadItems());
  return { items };
}

// ‚úÖ Full context when needed (rare)
setup: (context) => {
  const { signal, emitter, props } = context;
  // ... use all utilities
}
```

**Available context properties:**

| Property | Type | Description |
|----------|------|-------------|
| `signal` | Function | Create reactive state: `signal(initialValue)` |
| `emitter` | Object | Event bus: `emit()`, `on()`, `off()` |
| `props` | Object | Props passed from parent component |

**Lifecycle hooks** (`onBeforeMount`, `onMount`, `onBeforeUpdate`, `onUpdate`, `onUnmount`) are **returned from setup**, not destructured from context. See [Lifecycle Hooks](#lifecycle-hooks-patterns--best-practices) for details.

##### Organizing Setup Logic

Structure your setup function in this order for consistency:

```js
setup: ({ signal, emitter, props }) => {
  // 1. Props extraction (if needed)
  const { userId, initialData } = props;

  // 2. Reactive state (signals)
  const items = signal(initialData || []);
  const loading = signal(false);
  const error = signal(null);
  const selectedId = signal(null);

  // 3. Computed/derived values (functions that read signals)
  const getSelectedItem = () => items.value.find(i => i.id === selectedId.value);
  const getItemCount = () => items.value.length;

  // 4. Actions/handlers (functions that modify state)
  async function loadItems() {
    loading.value = true;
    error.value = null;
    try {
      const response = await fetch(`/api/users/${userId}/items`);
      items.value = await response.json();
    } catch (err) {
      error.value = err.message;
    } finally {
      loading.value = false;
    }
  }

  function selectItem(id) {
    selectedId.value = id;
    emitter.emit("item:selected", getSelectedItem());
  }

  function deleteItem(id) {
    items.value = items.value.filter(i => i.id !== id);
  }

  // 5. Event subscription ref (will be set in onMount)
  let unsubscribe = null;

  // 6. Return public interface + lifecycle hooks
  return {
    // State
    items,
    loading,
    error,
    selectedId,
    // Computed
    getSelectedItem,
    getItemCount,
    // Actions
    loadItems,
    selectItem,
    deleteItem,
    // Lifecycle hooks (returned, not destructured)
    onMount: () => {
      loadItems();
      unsubscribe = emitter.on("refresh:items", loadItems);
      console.log("Component mounted");
    },
    onUnmount: () => {
      if (unsubscribe) unsubscribe();
      console.log("Component unmounted");
    }
  };
}
```

##### Setup Return Value: What to Export

Only return what the template needs:

```js
// ‚ùå Avoid: Returning everything
setup: ({ signal }) => {
  const count = signal(0);
  const internalCache = new Map();  // Not needed in template
  const helperFn = () => { /* ... */ };  // Only used internally

  function increment() {
    helperFn();
    count.value++;
    internalCache.set(count.value, Date.now());
  }

  return { count, increment, internalCache, helperFn };  // Too much!
}

// ‚úÖ Better: Return only template-facing API
setup: ({ signal }) => {
  const count = signal(0);
  const internalCache = new Map();
  const helperFn = () => { /* ... */ };

  function increment() {
    helperFn();
    count.value++;
    internalCache.set(count.value, Date.now());
  }

  return { count, increment };  // Only what template needs
}
```

##### Arrow Function vs Regular Function

| Pattern | When to Use | Example |
|---------|-------------|---------|
| **Arrow with implicit return** | Simple state, no logic | `setup: ({ signal }) => ({ count: signal(0) })` |
| **Arrow with block body** | Most components | `setup: ({ signal }) => { ... return { }; }` |
| **Regular function** | Need `this` binding (rare) | `setup: function({ signal }) { ... }` |

```js
// ‚úÖ Arrow with implicit return - simplest components
app.component("SimpleCounter", {
  setup: ({ signal }) => ({ count: signal(0) }),
  template: (ctx) => `<p>${ctx.count.value}</p>`
});

// ‚úÖ Arrow with block - most common, recommended
app.component("Counter", {
  setup: ({ signal }) => {
    const count = signal(0);
    const increment = () => count.value++;
    const decrement = () => count.value--;
    return { count, increment, decrement };
  },
  template: (ctx) => `
    <button @click="decrement">-</button>
    <span>${ctx.count.value}</span>
    <button @click="increment">+</button>
  `
});
```

##### Setup Decision Guide

| Scenario | Recommendation |
|----------|----------------|
| No state, no events, no props | Omit setup entirely |
| Just one or two signals | Arrow with implicit return |
| Multiple signals + functions | Arrow with block body |
| Need lifecycle hooks | Arrow with block body |
| Complex async operations | Arrow with block, organize by category |
| Subscribing to events | Remember to unsubscribe in `onUnmount` |

#### Lifecycle Hooks: Patterns & Best Practices

Lifecycle hooks let you run code at specific points in a component's life. Here's how to use them effectively.

##### Available Hooks

| Hook | When Called | Common Use Cases |
|------|-------------|------------------|
| `onBeforeMount` | Before component renders to DOM | Validate props, prepare data |
| `onMount` | After component renders to DOM | Fetch data, set up subscriptions, DOM access |
| `onBeforeUpdate` | Before component re-renders | Compare old/new state, cancel updates |
| `onUpdate` | After component re-renders | DOM measurements, third-party library sync |
| `onUnmount` | Before component is destroyed | Cleanup subscriptions, timers, listeners |

##### Execution Order

```
Component Created
    ‚îÇ
    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ onBeforeMount   ‚îÇ  ‚Üê Props validated, initial data ready
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
    ‚ñº (DOM renders)
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ onMount         ‚îÇ  ‚Üê DOM available, fetch data, set up listeners
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
    ‚ñº (User interacts, state changes)
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ onBeforeUpdate  ‚îÇ  ‚Üê Before re-render
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
    ‚ñº (DOM updates)
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ onUpdate        ‚îÇ  ‚Üê After re-render
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
    ‚ñº (Component removed)
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ onUnmount       ‚îÇ  ‚Üê Cleanup everything
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

##### onMount: The Most Common Hook

Use `onMount` for initialization that requires the DOM or async operations:

```js
setup: ({ signal }) => {
  const users = signal([]);
  const loading = signal(true);
  const error = signal(null);

  return {
    users,
    loading,
    error,
    // Lifecycle hooks are returned, not destructured
    onMount: async () => {
      try {
        const response = await fetch("/api/users");
        users.value = await response.json();
      } catch (err) {
        error.value = err.message;
      } finally {
        loading.value = false;
      }
    }
  };
}
```

**Common onMount use cases:**
- Fetching initial data from APIs
- Setting up event listeners (window, document)
- Initializing third-party libraries
- Starting timers or intervals
- Focusing input elements

##### onUnmount: Essential for Cleanup

**Always clean up** what you set up in `onMount`:

```js
setup: ({ signal }) => {
  const windowWidth = signal(window.innerWidth);
  let intervalId = null;
  let resizeHandler = null;

  return {
    windowWidth,
    onMount: () => {
      // Set up resize listener
      resizeHandler = () => { windowWidth.value = window.innerWidth; };
      window.addEventListener("resize", resizeHandler);

      // Set up interval
      intervalId = setInterval(() => {
        console.log("Tick");
      }, 1000);
    },
    onUnmount: () => {
      // ‚úÖ Clean up everything!
      window.removeEventListener("resize", resizeHandler);
      clearInterval(intervalId);
    }
  };
}
```

**What to clean up in onUnmount:**
| Resource | Cleanup Method |
|----------|----------------|
| Event listeners | `removeEventListener()` |
| Timers | `clearTimeout()`, `clearInterval()` |
| Subscriptions | Call unsubscribe function |
| WebSocket | `socket.close()` |
| AbortController | `controller.abort()` |
| Third-party libraries | Library-specific destroy method |

##### onBeforeMount: Validation & Preparation

Use for synchronous preparation before rendering:

```js
setup: ({ props, signal }) => {
  const isValid = signal(true);
  const preparedData = signal(null);

  return {
    isValid,
    preparedData,
    onBeforeMount: () => {
      // Validate required props
      if (!props.userId) {
        console.error("userId prop is required");
        isValid.value = false;
        return;
      }

      // Prepare/transform data synchronously
      preparedData.value = {
        id: props.userId,
        timestamp: Date.now()
      };
    }
  };
}
```

##### onBeforeUpdate & onUpdate: Re-render Hooks

Use for comparing state or syncing with external systems:

```js
setup: ({ signal }) => {
  const count = signal(0);
  let previousCount = 0;

  return {
    count,
    onBeforeUpdate: () => {
      // Capture previous value before re-render
      previousCount = count.value;
    },
    onUpdate: () => {
      // Compare after re-render
      if (count.value !== previousCount) {
        console.log(`Count changed: ${previousCount} ‚Üí ${count.value}`);
      }

      // Sync with third-party library after DOM updates
      if (window.Chart) {
        window.Chart.update();
      }
    }
  };
}
```

##### Async Operations in Hooks

Handle async operations properly with cleanup:

```js
setup: ({ signal }) => {
  const data = signal(null);
  const loading = signal(true);

  // AbortController for cancellable fetch
  let abortController = null;

  return {
    data,
    loading,
    onMount: async () => {
      abortController = new AbortController();

      try {
        const response = await fetch("/api/data", {
          signal: abortController.signal
        });
        data.value = await response.json();
      } catch (err) {
        if (err.name !== "AbortError") {
          console.error("Fetch failed:", err);
        }
      } finally {
        loading.value = false;
      }
    },
    onUnmount: () => {
      // Cancel pending request on unmount
      if (abortController) {
        abortController.abort();
      }
    }
  };
}
```

##### Combining Multiple Hooks

Organize hooks logically within setup:

```js
setup: ({ signal, emitter }) => {
  // State
  const users = signal([]);
  const selectedId = signal(null);

  // Refs for cleanup
  let unsubscribe = null;
  let pollInterval = null;

  // Functions
  async function fetchUsers() {
    const response = await fetch("/api/users");
    users.value = await response.json();
  }

  // Return state, functions, and lifecycle hooks together
  return {
    users,
    selectedId,
    fetchUsers,
    // Lifecycle hooks (returned as properties)
    onBeforeMount: () => {
      console.log("Preparing component...");
    },
    onMount: () => {
      // Initial data fetch
      fetchUsers();

      // Set up polling
      pollInterval = setInterval(fetchUsers, 30000);

      // Subscribe to events
      unsubscribe = emitter.on("user:refresh", fetchUsers);
    },
    onUpdate: () => {
      console.log("Component updated, users:", users.value.length);
    },
    onUnmount: () => {
      // Clean up everything
      clearInterval(pollInterval);
      if (unsubscribe) unsubscribe();
    }
  };
}
```

##### Lifecycle Anti-Patterns

```js
// ‚ùå DON'T: Heavy synchronous work in onBeforeMount
return {
  onBeforeMount: () => {
    // This blocks rendering!
    const result = heavyComputation(millionItems);
  }
};

// ‚ùå DON'T: Forget cleanup - this causes memory leaks!
return {
  onMount: () => {
    window.addEventListener("scroll", handleScroll);
    // Memory leak if onUnmount doesn't remove it!
  }
  // Missing onUnmount!
};

// ‚ùå DON'T: Set state in onUpdate (infinite loop)
return {
  onUpdate: () => {
    count.value++;  // Triggers another update - infinite loop!
  }
};

// ‚ùå DON'T: Async in onBeforeMount (won't wait)
return {
  onBeforeMount: async () => {
    await fetchData();  // Render happens before this completes
  }
};

// ‚úÖ DO: Async in onMount
return {
  onMount: async () => {
    await fetchData();  // Safe, DOM already rendered
  }
};

// ‚úÖ DO: Always clean up what you set up
let handler = null;
return {
  onMount: () => {
    handler = () => {};
    window.addEventListener("scroll", handler);
  },
  onUnmount: () => {
    window.removeEventListener("scroll", handler);
  }
};

// ‚úÖ DO: Guard state updates in onUpdate
let synced = false;
return {
  onUpdate: () => {
    if (shouldSync && !synced) {
      syncExternalLibrary();
      synced = true;
    }
  }
};
```

##### Lifecycle Decision Guide

| Task | Recommended Hook |
|------|------------------|
| Fetch initial data | `onMount` |
| Validate props | `onBeforeMount` |
| Set up event listeners | `onMount` |
| Remove event listeners | `onUnmount` |
| Clear timers/intervals | `onUnmount` |
| Cancel pending requests | `onUnmount` |
| Initialize third-party library | `onMount` |
| Destroy third-party library | `onUnmount` |
| Focus an input element | `onMount` |
| Measure DOM elements | `onMount` or `onUpdate` |
| Sync state with external system | `onUpdate` |
| Log state changes | `onUpdate` |
| Compare previous/current state | `onBeforeUpdate` + `onUpdate` |

#### Signal Reactivity: Patterns & Best Practices

Signals are Eleva's reactivity primitive. They hold values and automatically trigger UI updates when changed. Here's how to use them effectively.

##### When to Use Signals vs Regular Variables

| Data Type | Use Signal? | Why |
|-----------|-------------|-----|
| UI state (counts, toggles, form values) | ‚úÖ Yes | Triggers re-render on change |
| Data from API | ‚úÖ Yes | UI updates when data loads |
| Derived/computed values | ‚ùå No | Use functions instead |
| Constants | ‚ùå No | Never changes |
| Internal helpers (caches, refs) | ‚ùå No | Not displayed in UI |
| Props received from parent | ‚ö†Ô∏è Depends | Pass signal itself for reactivity |

```js
setup: ({ signal }) => {
  // ‚úÖ Use signals for reactive UI state
  const count = signal(0);
  const isOpen = signal(false);
  const items = signal([]);
  const formData = signal({ name: "", email: "" });

  // ‚ùå Don't use signals for constants
  const API_URL = "/api/users";  // Regular variable
  const MAX_ITEMS = 100;         // Regular variable

  // ‚ùå Don't use signals for internal refs
  let timerRef = null;           // Regular variable
  const cache = new Map();       // Regular variable

  // ‚ùå Don't use signals for computed values
  const getItemCount = () => items.value.length;  // Function
  const getTotal = () => items.value.reduce((a, b) => a + b.price, 0);

  return { count, isOpen, items, formData, getItemCount, getTotal };
}
```

##### Creating Signals

```js
setup: ({ signal }) => {
  // Primitive values
  const count = signal(0);
  const name = signal("");
  const isActive = signal(false);

  // Arrays
  const items = signal([]);
  const users = signal([{ id: 1, name: "John" }]);

  // Objects
  const user = signal({ name: "", email: "" });
  const settings = signal({ theme: "dark", language: "en" });

  // Null/undefined (for async data)
  const data = signal(null);
  const error = signal(undefined);

  return { count, name, isActive, items, users, user, settings, data, error };
}
```

##### Accessing Signal Values

Always use `.value` to read or write:

```js
// ‚úÖ Correct: Access with .value
template: (ctx) => `
  <p>Count: ${ctx.count.value}</p>
  <p>Name: ${ctx.user.value.name}</p>
  <p>Items: ${ctx.items.value.length}</p>
`

// ‚ùå Wrong: Forgetting .value
template: (ctx) => `
  <p>Count: ${ctx.count}</p>        <!-- Shows [object Signal] -->
  <p>Name: ${ctx.user.name}</p>     <!-- undefined -->
`
```

##### Updating Signals

```js
setup: ({ signal }) => {
  const count = signal(0);
  const user = signal({ name: "John", age: 25 });
  const items = signal(["a", "b", "c"]);

  // Primitives - direct assignment
  function increment() {
    count.value++;
  }

  function setCount(n) {
    count.value = n;
  }

  // Objects - replace entire object for reactivity
  function updateName(newName) {
    user.value = { ...user.value, name: newName };
  }

  // ‚ö†Ô∏è This won't trigger update!
  function brokenUpdate(newName) {
    user.value.name = newName;  // Mutating, not replacing
  }

  // Arrays - replace entire array for reactivity
  function addItem(item) {
    items.value = [...items.value, item];
  }

  function removeItem(index) {
    items.value = items.value.filter((_, i) => i !== index);
  }

  function updateItem(index, newValue) {
    items.value = items.value.map((item, i) =>
      i === index ? newValue : item
    );
  }

  return { count, user, items, increment, setCount, updateName, addItem, removeItem, updateItem };
}
```

##### Object & Array Immutability

**Key Rule:** Always replace objects and arrays, never mutate them.

```js
const user = signal({ name: "John", settings: { theme: "dark" } });
const items = signal([1, 2, 3]);

// ‚ùå WRONG: Mutation (won't trigger re-render)
user.value.name = "Jane";
user.value.settings.theme = "light";
items.value.push(4);
items.value[0] = 10;

// ‚úÖ CORRECT: Replacement (triggers re-render)
user.value = { ...user.value, name: "Jane" };
user.value = {
  ...user.value,
  settings: { ...user.value.settings, theme: "light" }
};
items.value = [...items.value, 4];
items.value = items.value.map((v, i) => i === 0 ? 10 : v);
```

##### Computed/Derived Values

Use functions for values derived from signals:

```js
setup: ({ signal }) => {
  const items = signal([
    { name: "Widget", price: 10, qty: 2 },
    { name: "Gadget", price: 25, qty: 1 }
  ]);
  const taxRate = signal(0.08);

  // ‚úÖ Computed as functions - recalculated on each render
  const getSubtotal = () =>
    items.value.reduce((sum, item) => sum + item.price * item.qty, 0);

  const getTax = () => getSubtotal() * taxRate.value;

  const getTotal = () => getSubtotal() + getTax();

  const getItemCount = () => items.value.length;

  const getExpensiveItems = () =>
    items.value.filter(item => item.price > 20);

  return {
    items,
    taxRate,
    getSubtotal,
    getTax,
    getTotal,
    getItemCount,
    getExpensiveItems
  };
}

// In template
template: (ctx) => `
  <p>Subtotal: $${ctx.getSubtotal().toFixed(2)}</p>
  <p>Tax: $${ctx.getTax().toFixed(2)}</p>
  <p>Total: $${ctx.getTotal().toFixed(2)}</p>
  <p>Items: ${ctx.getItemCount()}</p>
`
```

##### Watching Signal Changes

Use `.watch()` to react to signal changes:

```js
setup: ({ signal }) => {
  const searchQuery = signal("");
  const results = signal([]);

  // Watch for changes and perform side effects
  const unwatch = searchQuery.watch(async (newValue) => {
    if (newValue.length >= 3) {
      const response = await fetch(`/api/search?q=${newValue}`);
      results.value = await response.json();
    } else {
      results.value = [];
    }
  });

  return {
    searchQuery,
    results,
    // Clean up watcher on unmount
    onUnmount: () => {
      unwatch();
    }
  };
}
```

**Common watch use cases:**
- Debounced search/autocomplete
- Persisting to localStorage
- Analytics tracking
- Syncing with external systems

##### Debouncing Signal Updates

For frequent updates (like search input), debounce to avoid excessive operations:

```js
setup: ({ signal }) => {
  const searchQuery = signal("");
  const results = signal([]);
  let debounceTimer = null;

  function handleSearch(query) {
    searchQuery.value = query;

    // Clear previous timer
    clearTimeout(debounceTimer);

    // Set new timer
    debounceTimer = setTimeout(async () => {
      if (query.length >= 2) {
        const response = await fetch(`/api/search?q=${query}`);
        results.value = await response.json();
      }
    }, 300);  // 300ms debounce
  }

  return {
    searchQuery,
    results,
    handleSearch,
    onUnmount: () => {
      clearTimeout(debounceTimer);
    }
  };
}
```

##### Multiple Related Signals vs Single Object Signal

| Pattern | When to Use |
|---------|-------------|
| **Multiple signals** | Independent values, updated separately |
| **Single object signal** | Related values, often updated together |

```js
// Pattern 1: Multiple signals (independent values)
const firstName = signal("");
const lastName = signal("");
const email = signal("");

// Easy to update individually
firstName.value = "John";

// Pattern 2: Single object signal (related values)
const formData = signal({
  firstName: "",
  lastName: "",
  email: ""
});

// Update requires spread
formData.value = { ...formData.value, firstName: "John" };

// But easier to reset
formData.value = { firstName: "", lastName: "", email: "" };

// And easier to pass around
submitForm(formData.value);
```

**Recommendation:** Use multiple signals for truly independent values. Use object signals for form data or related state that's often passed together.

##### Signal Anti-Patterns

```js
// ‚ùå DON'T: Create signals outside setup
const globalCount = signal(0);  // Won't work properly

// ‚ùå DON'T: Forget .value
template: (ctx) => `<p>${ctx.count}</p>`  // Shows [object Signal]

// ‚ùå DON'T: Mutate objects/arrays
items.value.push(newItem);      // Won't trigger update
user.value.name = "Jane";       // Won't trigger update

// ‚ùå DON'T: Create signals for constants
const MAX_SIZE = signal(100);   // Never changes, waste of resources

// ‚ùå DON'T: Create signals for computed values
const total = signal(items.value.reduce(...));  // Stale after items change

// ‚ùå DON'T: Update signals in render
template: (ctx) => {
  ctx.renderCount.value++;  // Infinite loop!
  return `<p>...</p>`;
}

// ‚úÖ DO: Create signals in setup
setup: ({ signal }) => {
  const count = signal(0);
  return { count };
}

// ‚úÖ DO: Use .value consistently
template: (ctx) => `<p>${ctx.count.value}</p>`

// ‚úÖ DO: Replace objects/arrays
items.value = [...items.value, newItem];

// ‚úÖ DO: Use regular variables for constants
const MAX_SIZE = 100;

// ‚úÖ DO: Use functions for computed values
const getTotal = () => items.value.reduce(...);
```

##### Signal Decision Guide

| Scenario | Recommendation |
|----------|----------------|
| Counter, toggle, form input | Single primitive signal |
| Form with multiple fields | Object signal or multiple signals |
| List of items | Array signal |
| Loading/error states | Separate boolean signals |
| Data from API | Signal initialized as `null` |
| Computed/derived value | Function, not signal |
| Constant value | Regular variable |
| Internal reference (timer, cache) | Regular variable |
| Debounced input | Signal + debounce timer |
| Persisted to localStorage | Signal + watch |

#### Async Patterns: Setup, Template & Style

Understanding when to use async functions in your component properties is crucial for performance and predictable behavior.

##### Quick Reference

| Property | Async Support | Recommendation |
|----------|---------------|----------------|
| `setup` | ‚úÖ Yes | Use sparingly; prefer sync setup + async in `onMount` |
| `template` | ‚ùå No | Never use async; must return string synchronously |
| `style` | ‚ùå No | Never use async; must return string synchronously |

##### Setup: Async Considerations

The `setup` function CAN be async, but use it carefully:

```js
// ‚ö†Ô∏è Async setup - blocks mounting until resolved
app.component("AsyncSetup", {
  setup: async ({ signal }) => {
    const data = signal(null);

    // This delays the entire component mount
    const response = await fetch("/api/config");
    data.value = await response.json();

    return { data };
  },
  template: (ctx) => `<div>${JSON.stringify(ctx.data.value)}</div>`
});
```

**When Async Setup is Acceptable:**
- Loading critical configuration before render
- Initializing a required dependency
- Component cannot render without the data

**Problems with Async Setup:**
- Blocks mounting - user sees nothing until resolved
- No loading state shown during fetch
- Error handling is more complex
- Harder to show fallback UI

##### Recommended: Sync Setup + Async in onMount

```js
// ‚úÖ RECOMMENDED: Sync setup, async data in onMount
app.component("BetterAsync", {
  setup: ({ signal }) => {
    const data = signal(null);
    const loading = signal(true);
    const error = signal(null);

    async function loadData() {
      try {
        loading.value = true;
        const response = await fetch("/api/data");
        if (!response.ok) throw new Error("Failed to load");
        data.value = await response.json();
      } catch (err) {
        error.value = err.message;
      } finally {
        loading.value = false;
      }
    }

    return {
      data,
      loading,
      error,
      loadData,
      onMount: () => loadData()  // Trigger fetch after mount
    };
  },
  template: (ctx) => `
    <div>
      ${ctx.loading.value ? `
        <p>Loading...</p>
      ` : ctx.error.value ? `
        <p class="error">${ctx.error.value}</p>
        <button @click="loadData">Retry</button>
      ` : `
        <div>${JSON.stringify(ctx.data.value)}</div>
      `}
    </div>
  `
});
```

**Benefits of this Pattern:**
- Component mounts immediately
- User sees loading state
- Easy retry on error
- Better user experience

##### Template: Never Async

The `template` property must return a string synchronously. Eleva calls template on every render cycle - async templates would break reactivity.

```js
// ‚ùå WRONG: Async template (will not work)
app.component("WrongAsync", {
  template: async (ctx) => {
    const data = await fetch("/api/data");  // DON'T DO THIS
    return `<div>${data}</div>`;
  }
});

// ‚úÖ CORRECT: Sync template, data loaded elsewhere
app.component("CorrectAsync", {
  setup: ({ signal }) => {
    const data = signal(null);
    return {
      data,
      onMount: async () => {
        const response = await fetch("/api/data");
        data.value = await response.json();
      }
    };
  },
  template: (ctx) => `
    <div>${ctx.data.value ? JSON.stringify(ctx.data.value) : "Loading..."}</div>
  `
});
```

##### Style: Never Async

Like template, the `style` property must return CSS synchronously.

```js
// ‚ùå WRONG: Async style (will not work)
app.component("WrongStyle", {
  style: async () => {
    const theme = await fetch("/api/theme");  // DON'T DO THIS
    return `.btn { color: ${theme.primary}; }`;
  }
});

// ‚úÖ CORRECT: Load theme data in setup, use in sync style
app.component("CorrectStyle", {
  setup: ({ signal }) => {
    const theme = signal({ primary: "#007bff" });  // Default
    return {
      theme,
      onMount: async () => {
        const response = await fetch("/api/theme");
        theme.value = await response.json();
      }
    };
  },
  template: (ctx) => `<button>Click me</button>`,
  style: (ctx) => `
    button { background: ${ctx.theme.value.primary}; color: white; }
  `
});
```

##### Async Decision Guide

| Scenario | Approach |
|----------|----------|
| Fetch data on component load | Sync setup + async `onMount` |
| Load critical config before render | Async setup (rare) |
| Periodic data refresh | Sync setup + `setInterval` in `onMount` |
| User-triggered fetch | Sync setup + async function called on event |
| Load theme/styles dynamically | Signal with default + async `onMount` |
| Lazy load child component | Use Router plugin with lazy routes |

##### Anti-Patterns

```js
// ‚ùå DON'T: Async template
template: async (ctx) => { ... }

// ‚ùå DON'T: Async style
style: async (ctx) => { ... }

// ‚ùå DON'T: Await in template body
template: (ctx) => {
  const data = await fetch(...);  // Syntax error / won't work
  return `...`;
}

// ‚ùå DON'T: Block setup for non-critical data
setup: async ({ signal }) => {
  const analytics = await loadAnalytics();  // User waits for analytics?
  return { ... };
}

// ‚úÖ DO: Sync setup, async operations in lifecycle
setup: ({ signal }) => {
  const data = signal(null);
  return {
    data,
    onMount: async () => { data.value = await fetchData(); }
  };
}

// ‚úÖ DO: Handle loading and error states
setup: ({ signal }) => {
  const data = signal(null);
  const loading = signal(false);
  const error = signal(null);
  return { data, loading, error, ... };
}
```

#### Style Property: String vs Function

| Scenario | Use | Example |
|----------|-----|---------|
| **Static styles** | String | `style: \`.btn { color: blue; }\`` |
| **Dynamic styles** (state-dependent) | Function | `style: (ctx) => \`.btn { color: ${ctx.isActive.value ? 'green' : 'gray'}; }\`` |

```js
// Static styles - use string (better performance)
app.component("StaticStyled", {
  setup: ({ signal }) => ({ count: signal(0) }),
  template: (ctx) => `<button>Count: ${ctx.count.value}</button>`,
  style: `
    button { background: blue; color: white; }
  `
});

// Dynamic styles - use function
app.component("DynamicStyled", {
  setup: ({ signal }) => ({ isActive: signal(false) }),
  template: (ctx) => `
    <button @click="() => isActive.value = !isActive.value">
      ${ctx.isActive.value ? 'Active' : 'Inactive'}
    </button>
  `,
  style: (ctx) => `
    button {
      background: ${ctx.isActive.value ? 'green' : 'gray'};
      color: white;
    }
  `
});
```

#### Template Property: Patterns & Best Practices

The `template` property defines your component's HTML structure. Eleva supports multiple patterns - here's when to use each.

##### Template as Function vs String

| Pattern | When to Use | Example |
|---------|-------------|---------|
| **Function with context** | Component has state, props, or functions | `template: (ctx) => \`...\`` |
| **Function without context** | Static HTML, no dynamic data | `template: () => \`...\`` |
| **String** | Not recommended | `template: \`...\`` |

```js
// ‚úÖ Function with context - most common pattern
app.component("Counter", {
  setup: ({ signal }) => ({ count: signal(0) }),
  template: (ctx) => `
    <button @click="() => count.value++">
      Count: ${ctx.count.value}
    </button>
  `
});

// ‚úÖ Function without context - for static components
app.component("Footer", {
  template: () => `
    <footer>
      <p>&copy; 2026 My Company</p>
    </footer>
  `
});

// ‚ùå Avoid: String template (no access to context)
app.component("Broken", {
  setup: ({ signal }) => ({ count: signal(0) }),
  template: `<p>Count: ${count.value}</p>`  // Error: count is not defined
});
```

##### Accessing Context: Direct vs Destructured

| Pattern | When to Use | Pros/Cons |
|---------|-------------|-----------|
| **Direct access** `(ctx)` | Many properties, consistency | Clear source, slightly verbose |
| **Destructured** `({ count, user })` | Few properties, cleaner template | Shorter, but hides source |

```js
// Pattern 1: Direct context access (Recommended for consistency)
template: (ctx) => `
  <div>
    <h1>${ctx.user.value.name}</h1>
    <p>Count: ${ctx.count.value}</p>
    <button @click="increment">+</button>
  </div>
`

// Pattern 2: Destructured context (Good for simple components)
template: ({ user, count }) => `
  <div>
    <h1>${user.value.name}</h1>
    <p>Count: ${count.value}</p>
    <button @click="increment">+</button>
  </div>
`
```

> **Note:** Event handlers (`@click`, `@input`, etc.) always use the handler name directly without `ctx.` prefix, regardless of which pattern you use. This is because events are resolved by the framework, not by JavaScript template literals.

**Recommendation:** Use direct `ctx` access for consistency across your codebase. Destructuring is acceptable for simple components with few properties.

##### Complex Logic: Function Body vs Inline

For templates with computed values or complex logic, use a function body:

```js
// ‚ùå Avoid: Complex logic inline in template
template: (ctx) => `
  <div>
    <p>Total: $${ctx.items.value.reduce((sum, item) => sum + item.price * item.qty, 0).toFixed(2)}</p>
    <p>Items: ${ctx.items.value.filter(i => i.inStock).length} in stock</p>
  </div>
`

// ‚úÖ Better: Compute values before returning template
template: (ctx) => {
  const total = ctx.items.value
    .reduce((sum, item) => sum + item.price * item.qty, 0)
    .toFixed(2);
  const inStockCount = ctx.items.value.filter(i => i.inStock).length;

  return `
    <div>
      <p>Total: $${total}</p>
      <p>Items: ${inStockCount} in stock</p>
    </div>
  `;
}

// ‚úÖ Best: Move logic to setup, keep template clean
app.component("Cart", {
  setup: ({ signal }) => {
    const items = signal([]);

    // Computed-like functions
    const getTotal = () => items.value
      .reduce((sum, item) => sum + item.price * item.qty, 0)
      .toFixed(2);

    const getInStockCount = () => items.value.filter(i => i.inStock).length;

    return { items, getTotal, getInStockCount };
  },
  template: (ctx) => `
    <div>
      <p>Total: $${ctx.getTotal()}</p>
      <p>Items: ${ctx.getInStockCount()} in stock</p>
    </div>
  `
});
```

##### Event Handlers: Inline vs Named Functions

| Pattern | When to Use | Example |
|---------|-------------|---------|
| **Named function** | Reusable, complex logic, testable | `@click="handleClick"` |
| **Inline arrow** | Simple one-liners, value updates | `@click="() => count.value++"` |
| **Inline with event** | Need event object | `@click="(e) => handleClick(e, item)"` |

```js
app.component("TodoItem", {
  setup: ({ signal, props }) => {
    const isEditing = signal(false);

    // Named function - reusable, testable
    function toggleEdit() {
      isEditing.value = !isEditing.value;
    }

    // Named function with parameters
    function handleDelete(id) {
      props.onDelete(id);
    }

    return { isEditing, toggleEdit, handleDelete, todo: props.todo };
  },
  template: (ctx) => `
    <div class="todo-item">
      <!-- Named function - clean -->
      <button @click="toggleEdit">Edit</button>

      <!-- Inline arrow - simple value toggle -->
      <input type="checkbox" @change="() => todo.done = !todo.done" />

      <!-- Inline with parameter - passes data -->
      <button @click="() => handleDelete(${ctx.todo.id})">Delete</button>

      <!-- Inline with event object -->
      <input @input="(e) => todo.title = e.target.value" />
    </div>
  `
});
```

##### Template Decision Guide

| Scenario | Recommended Pattern |
|----------|---------------------|
| Component has reactive state | `template: (ctx) => \`...\`` |
| Component is purely static | `template: () => \`...\`` |
| Need computed values in template | Use function body with `return` |
| Complex calculations | Move to `setup`, expose as functions |
| Simple state update on click | Inline arrow: `@click="() => count.value++"` |
| Complex event handling | Named function: `@click="handleSubmit"` |
| Accessing many context properties | Use `ctx` directly |
| Simple component, few properties | Destructure: `({ count }) => ...` |

#### Children Property: Patterns & Best Practices

The `children` property maps child components to DOM elements in your template. Here's how to use it effectively.

##### When to Use Children

| Scenario | Use Children? | Alternative |
|----------|---------------|-------------|
| Reusable component in template | ‚úÖ Yes | - |
| Multiple instances of same component | ‚úÖ Yes | - |
| Dynamic component based on state | ‚úÖ Yes | - |
| Simple static content | ‚ùå No | Inline HTML in template |
| One-off complex markup | ‚ùå No | Keep in template |

```js
// ‚úÖ Use children - reusable component pattern
app.component("TodoList", {
  setup: ({ signal }) => ({ todos: signal([]) }),
  template: (ctx) => `
    <ul>
      ${ctx.todos.value.map(todo => `
        <li key="${todo.id}" class="todo-item" :todo="todo"></li>
      `).join("")}
    </ul>
  `,
  children: {
    ".todo-item": "TodoItem"  // Mount TodoItem into each .todo-item
  }
});

// ‚ùå Don't use children for simple content
app.component("SimpleCard", {
  template: () => `
    <div class="card">
      <h2>Title</h2>
      <p>Content goes here</p>  <!-- No need for child component -->
    </div>
  `
  // No children needed
});
```

##### Selector Patterns

Use CSS selectors to target where children mount:

| Selector Type | Example | Use Case |
|---------------|---------|----------|
| **Class** | `".item"` | Multiple elements, list items |
| **ID** | `"#sidebar"` | Single unique element |
| **Data attribute** | `"[data-component]"` | Explicit component markers |
| **Nested** | `".container .item"` | Scoped selection |

```js
// Class selector - for lists/multiple instances
children: {
  ".user-card": "UserCard",
  ".comment": "Comment"
}

// ID selector - for unique elements
children: {
  "#header": "Header",
  "#footer": "Footer"
}

// Data attribute - explicit and clear
template: () => `
  <div data-component="sidebar"></div>
  <div data-component="content"></div>
`,
children: {
  "[data-component='sidebar']": "Sidebar",
  "[data-component='content']": "Content"
}
```

**Recommendation:** Use classes for lists, IDs for unique elements, and data attributes when you want explicit component markers.

##### Registered vs Inline Component Definitions

| Pattern | When to Use | Pros/Cons |
|---------|-------------|-----------|
| **Registered name** | Reusable across app | Clean, testable, reusable |
| **Inline definition** | One-off, tightly coupled | Colocated, but not reusable |

```js
// ‚úÖ Registered component (Recommended)
app.component("UserCard", {
  setup: ({ props }) => ({ user: props.user }),
  template: (ctx) => `<div class="user">${ctx.user.name}</div>`
});

app.component("UserList", {
  template: (ctx) => `
    <div class="users">
      ${ctx.users.value.map(u => `
        <div key="${u.id}" class="card" :user="u"></div>
      `).join("")}
    </div>
  `,
  children: {
    ".card": "UserCard"  // Reference by name
  }
});

// ‚ö†Ô∏è Inline definition (Use sparingly)
app.component("Dashboard", {
  template: () => `<div class="widget"></div>`,
  children: {
    ".widget": {
      // Inline component definition
      setup: ({ signal }) => ({ count: signal(0) }),
      template: (ctx) => `<span>${ctx.count.value}</span>`
    }
  }
});
```

**Recommendation:** Prefer registered components for reusability and testing. Use inline definitions only for tightly-coupled, one-off components.

##### Passing Props to Children

Props flow from parent template to child via `:prop` attributes:

```js
app.component("ProductList", {
  setup: ({ signal }) => {
    const products = signal([
      { id: 1, name: "Widget", price: 29.99 },
      { id: 2, name: "Gadget", price: 49.99 }
    ]);

    function handleSelect(product) {
      console.log("Selected:", product);
    }

    return { products, handleSelect };
  },
  template: (ctx) => `
    <div class="products">
      ${ctx.products.value.map(product => `
        <div key="${product.id}" class="product-card"
          :product="product"
          :onSelect="() => handleSelect(product)">
        </div>
      `).join("")}
    </div>
  `,
  children: {
    ".product-card": "ProductCard"
  }
});

// Child receives props
app.component("ProductCard", {
  setup: ({ props }) => {
    const { product, onSelect } = props;
    return { product, onSelect };
  },
  template: (ctx) => `
    <div class="card" @click="onSelect">
      <h3>${ctx.product.name}</h3>
      <p>$${ctx.product.price}</p>
    </div>
  `
});
```

##### Nesting Depth Guidelines

| Depth | Recommendation |
|-------|----------------|
| 1-2 levels | ‚úÖ Ideal, easy to understand |
| 3 levels | ‚ö†Ô∏è Acceptable, consider flattening |
| 4+ levels | ‚ùå Too deep, refactor |

```js
// ‚úÖ Good: 2 levels deep
// App ‚Üí UserList ‚Üí UserCard

// ‚ö†Ô∏è Acceptable: 3 levels
// App ‚Üí Dashboard ‚Üí WidgetList ‚Üí Widget

// ‚ùå Avoid: 4+ levels - hard to trace data flow
// App ‚Üí Page ‚Üí Section ‚Üí List ‚Üí Item ‚Üí SubItem
// Consider: Flatten structure or use Store for shared state
```

##### Multiple Children Mounting

Mount different components to different selectors:

```js
app.component("Layout", {
  template: () => `
    <div class="layout">
      <header id="header"></header>
      <nav id="nav"></nav>
      <main id="content"></main>
      <aside id="sidebar"></aside>
      <footer id="footer"></footer>
    </div>
  `,
  children: {
    "#header": "Header",
    "#nav": "Navigation",
    "#content": "MainContent",
    "#sidebar": "Sidebar",
    "#footer": "Footer"
  }
});
```

##### Dynamic Children Based on State

Conditionally render different components:

```js
app.component("TabPanel", {
  setup: ({ signal }) => {
    const activeTab = signal("home");
    const setTab = (tab) => { activeTab.value = tab; };
    return { activeTab, setTab };
  },
  template: (ctx) => `
    <div class="tabs">
      <button @click="() => setTab('home')">Home</button>
      <button @click="() => setTab('profile')">Profile</button>
      <button @click="() => setTab('settings')">Settings</button>
    </div>
    <div class="tab-content" data-tab="${ctx.activeTab.value}"></div>
  `,
  children: {
    "[data-tab='home']": "HomeTab",
    "[data-tab='profile']": "ProfileTab",
    "[data-tab='settings']": "SettingsTab"
  }
});
```

##### Children Anti-Patterns

```js
// ‚ùå DON'T: Overly generic selectors
children: {
  "div": "SomeComponent"  // Too broad, may match unintended elements
}

// ‚ùå DON'T: Deep nesting without reason
children: {
  ".a": {
    children: {
      ".b": {
        children: {
          ".c": "DeepComponent"  // Hard to follow
        }
      }
    }
  }
}

// ‚ùå DON'T: Duplicate component for same data
template: (ctx) => `
  <div class="card1" :user="user"></div>
  <div class="card2" :user="user"></div>
`,
children: {
  ".card1": "UserCard",
  ".card2": "UserCard"  // Same component, same data - unnecessary
}

// ‚úÖ DO: Use specific selectors
children: {
  ".product-card": "ProductCard",
  "#featured-product": "FeaturedProduct"
}

// ‚úÖ DO: Keep nesting shallow
children: {
  ".item": "ListItem"  // ListItem can have its own children if needed
}
```

##### Children Decision Guide

| Scenario | Recommendation |
|----------|----------------|
| List of items | Use class selector: `".item": "Item"` |
| Single unique component | Use ID selector: `"#sidebar": "Sidebar"` |
| Reusable component | Register and reference by name |
| One-off tightly coupled | Inline definition (sparingly) |
| 4+ nesting levels | Refactor or use Store |
| Dynamic component switching | Use data attributes with state |
| Passing data to child | Use `:prop` attributes in template |

#### Component Communication: Props vs Emitter vs Store

Eleva provides multiple ways to share data between components. Choosing the right method is crucial for maintainable code.

##### Props (Data Down)

**Capabilities:**
- Pass any JavaScript value (objects, arrays, functions, primitives)
- No `JSON.stringify` needed ‚Äî values are passed directly
- Child updates when parent re-renders with new prop values
- Pass signal references for true reactivity in child

```js
// Parent - pass complex data directly (no JSON.stringify!)
template: (ctx) => `
  <div class="child"
    :user="user.value"
    :items="items"
    :onSelect="handleSelect">
  </div>
`

// Child - receives actual values
setup({ props }) {
  // props.user is already an object
  // props.items is already an array
  // props.onSelect is a callable function
  return { user: props.user, items: props.items, onSelect: props.onSelect };
}

// For reactive props in child, pass the signal itself (not .value)
// Parent: :counter="counter"
// Child: props.counter.watch(() => { /* react to changes */ })
```

**Use when:** Passing data from parent to child, any data type.

##### Emitter (Events Up)

**Purpose:** Child-to-parent communication, sibling communication, decoupled messaging.

```js
// Child component - emits events
setup({ emitter }) {
  function handleClick(item) {
    emitter.emit("item:selected", item);
    emitter.emit("cart:add", { id: item.id, qty: 1 });
  }
  return { handleClick };
}

// Parent or any component - listens for events
setup({ emitter }) {
  emitter.on("item:selected", (item) => {
    console.log("Selected:", item);
  });

  emitter.on("cart:add", ({ id, qty }) => {
    // Update cart state
  });

  return {};
}
```

**Use when:**
- Child needs to notify parent of actions
- Sibling components need to communicate
- Decoupled, event-driven architecture
- Actions/commands rather than data sharing

##### Store Plugin (Global State)

**Purpose:** Shared state accessible by any component, persisted state, app-wide data.

```js
import { Store } from "eleva/plugins";

// Initialize store with state and actions
app.use(Store, {
  state: {
    user: null,
    theme: "light"
  },
  actions: {
    setUser: (state, user) => { state.user.value = user; },
    setTheme: (state, theme) => { state.theme.value = theme; },
    logout: (state) => { state.user.value = null; }
  },
  persistence: {
    enabled: true,
    key: "my-app-store",
    include: ["theme"]  // Only persist theme
  }
});

// Any component can access store via setup
app.component("UserProfile", {
  setup({ store }) {
    // Read reactive state
    const user = store.state.user;
    const theme = store.state.theme;

    // Update via actions
    function logout() {
      store.dispatch("logout");
    }

    function toggleTheme() {
      const newTheme = store.state.theme.value === "light" ? "dark" : "light";
      store.dispatch("setTheme", newTheme);
    }

    return { user, theme, logout, toggleTheme };
  },
  template: (ctx) => `
    <div class="profile">
      ${ctx.user.value
        ? `<p>Welcome, ${ctx.user.value.name}!</p>
           <button @click="logout">Logout</button>`
        : `<p>Please log in</p>`
      }
      <button @click="toggleTheme">Theme: ${ctx.theme.value}</button>
    </div>
  `
});

// Subscribe to all state changes (optional)
app.store.subscribe((mutation) => {
  console.log("State changed:", mutation);
});
```

**Use when:**
- Multiple unrelated components need the same data
- User session, authentication state
- App-wide settings (theme, language)
- Data that persists across navigation

##### Decision Guide

| Scenario | Solution | Why |
|----------|----------|-----|
| Pass any value to child | Props | Direct value passing, any type |
| Pass object/array to child | Props | No JSON.stringify needed |
| Pass function to child | Props | Function reference preserved |
| Child notifies parent of action | Emitter | Events flow up |
| Siblings need to communicate | Emitter | Decoupled messaging |
| Many components need same data | Store | Central state management |
| User session/auth state | Store | Global, persistent |
| Parent updates, child should react | Props (pass signal) | Pass signal reference, not `.value` |
| Form data in multi-step wizard | Store or Props | Depends on component structure |

##### Anti-Patterns to Avoid

```js
// ‚ùå DON'T: Use JSON.stringify for props (no longer needed!)
:data='${JSON.stringify(object)}'  // Old approach
:data="object"                     // ‚úÖ New: just pass directly

// ‚ùå DON'T: Use Store for parent-child only communication
store.dispatch("setParentData", data);  // Overkill, use props

// ‚ùå DON'T: Use Emitter for data that multiple components read
emitter.emit("userData", user);  // Use Store instead

// ‚ùå DON'T: Mutate store state directly
store.state.user.value = newUser;  // Use actions instead
store.dispatch("setUser", newUser);  // ‚úÖ Correct

// ‚úÖ DO: Use the right tool for each job
// - Props for parent‚Üíchild data
// - Emitter for child‚Üíparent events
// - Store for global/shared state
```

#### General Guidelines

- **Modularity:** Build your application using small, reusable components.
- **Reactivity:** Use signals to update only the necessary parts of your UI.
- **Simplicity:** Keep templates clean and logic minimal.
- **Naming:** Use PascalCase for component names (`UserProfile`, not `user-profile`).
- **Single Responsibility:** Each component should do one thing well.
- **Props Down, Events Up:** Pass data to children via props, communicate up via emitter.
- **Use Store Sparingly:** Only for truly global state, not for local component data.
- **Testing:** Write tests for components and plugins.
- **Documentation:** Maintain clear documentation for your application and custom plugins.

### Use Cases

- **Small to Medium Projects:** Ideal for lightweight apps and websites where performance matters.
- **Performance-Critical Applications:** Low bundle size and fast rendering are essential.
- **Rapid Prototyping:** Quick experimentation and proof-of-concept projects.
- **Highly Customizable Solutions:** Benefit from Eleva's unopinionated architecture to tailor the framework using plugins and custom logic.

---

## 11. Examples and Tutorials

Comprehensive code examples are available in a dedicated section for easy navigation and exploration.

### [View All Examples ‚Üí](./examples/index.md)

### UI Patterns

Reusable code patterns for common scenarios.

| Pattern | Description | Link |
|---------|-------------|------|
| **Forms** | Input binding, validation, submission | [View ‚Üí](./examples/patterns/forms.md) |
| **Async Data** | API fetching, loading states, pagination | [View ‚Üí](./examples/patterns/async-data.md) |
| **Conditional Rendering** | Show/hide, tabs, modals, skeletons | [View ‚Üí](./examples/patterns/conditional-rendering.md) |
| **Lists** | Search, filter, sort, drag-and-drop, CRUD | [View ‚Üí](./examples/patterns/lists.md) |
| **State Management** | Computed values, undo/redo, wizards | [View ‚Üí](./examples/patterns/state.md) |
| **Local Storage** | Persistence, session storage, caching | [View ‚Üí](./examples/patterns/storage.md) |

### Complete Apps

Full mini-applications demonstrating multiple features.

| App | Description | Link |
|-----|-------------|------|
| **Task Manager** | Filtering, sorting, priorities, localStorage | [View ‚Üí](./examples/apps/task-manager.md) |
| **Weather Dashboard** | API fetching, search history, unit conversion | [View ‚Üí](./examples/apps/weather-dashboard.md) |
| **Simple Blog** | Posts, comments, component composition | [View ‚Üí](./examples/apps/blog.md) |

### Guides

| Guide | Description | Link |
|-------|-------------|------|
| **Custom Plugins** | Create and publish your own plugins | [View ‚Üí](./examples/custom-plugin.md) |

### External Resources

- [CodePen Collection](https://codepen.io/collection/dGGqWr) - Interactive demos
- [GitHub Examples](https://github.com/TarekRaafat/eleva/tree/master/examples) - Full source code

---

## 12. FAQ

### General Questions

**Q: What is Eleva?**
_A:_ Eleva is a minimalist, lightweight (6KB) pure vanilla JavaScript frontend framework. It provides React-like component-based architecture with signal-based reactivity, but without the complexity, dependencies, or mandatory build tools of larger frameworks.

**Q: Is Eleva production-ready?**
_A:_ Yes! Eleva v1.0.0 is the first official stable release. The framework is production-ready with a stable API and comprehensive test coverage. We continue to welcome feedback and contributions to make Eleva even better.

**Q: How do I report issues or request features?**
_A:_ Please use the [GitHub Issues](https://github.com/TarekRaafat/eleva/issues) page.

### Comparison Questions

**Q: What is the difference between Eleva and React?**
_A:_ Eleva differs from React in several key ways: (1) Eleva is 6KB vs React's 42KB+ bundle size, (2) Eleva has zero dependencies while React has several, (3) Eleva uses signal-based reactivity instead of virtual DOM diffing, (4) Eleva requires no build step and works directly via CDN, (5) Eleva uses template strings instead of JSX. Choose Eleva for simpler projects where bundle size matters; choose React for larger applications needing its extensive ecosystem.

**Q: What is the difference between Eleva and Vue?**
_A:_ Both Eleva and Vue are progressive frameworks, but Eleva is smaller (6KB vs 34KB), has zero dependencies, and requires no build tools. Vue offers a more comprehensive ecosystem with Vue Router, Vuex/Pinia, and extensive tooling. Eleva's plugins (Router, Store) provide similar functionality in a lighter package. Choose Eleva for simpler projects; choose Vue for larger SPAs needing its mature ecosystem.

**Q: What is the difference between Eleva and Svelte?**
_A:_ Svelte compiles components at build time, resulting in very small runtime code (~2KB), but requires a build step. Eleva (6KB) works without any build tools via CDN. Both avoid virtual DOM. Choose Eleva for quick prototypes or when avoiding build complexity; choose Svelte for production apps where you're already using a bundler.

**Q: Is Eleva a React alternative?**
_A:_ Yes, Eleva can serve as a lightweight React alternative for projects that don't need React's full ecosystem. Eleva offers similar component-based architecture and reactivity patterns but with a much smaller footprint (6KB vs 42KB+) and zero dependencies.

### Technical Questions

**Q: How does Eleva's reactivity work?**
_A:_ Eleva uses a signal-based reactivity system similar to Solid.js. Signals are reactive containers that hold values. When a signal's value changes, any component or watcher subscribed to that signal automatically updates. This provides fine-grained reactivity without the overhead of virtual DOM diffing.

**Q: Does Eleva use Virtual DOM?**
_A:_ No. Eleva uses real DOM manipulation with an efficient diffing algorithm. Instead of maintaining a virtual DOM tree in memory and comparing it to compute changes, Eleva directly patches the real DOM. This approach is simpler and often faster for smaller applications.

**Q: Can I use Eleva with TypeScript?**
_A:_ Absolutely! Eleva includes built-in TypeScript declarations (`.d.ts` files) to help keep your codebase strongly typed. No additional `@types` packages are needed.

**Q: Does Eleva require a build step?**
_A:_ No. Eleva can be used directly via CDN without any build tools, bundlers, or transpilers. Simply include the script tag and start coding. However, you can also use Eleva with bundlers like Vite, Webpack, or Rollup if you prefer.

**Q: Is Eleva suitable for large applications?**
_A:_ Eleva is designed for small to medium applications. For large enterprise applications with complex state management, routing, and team collaboration needs, you may benefit from the more extensive ecosystems of React, Vue, or Angular. However, Eleva's plugin system (Router, Store) can handle moderately complex SPAs.

### Plugin Questions

**Q: Does Eleva include routing capabilities?**
_A:_ Yes! Eleva includes a powerful built-in Router plugin that provides advanced client-side routing with navigation guards, reactive state, and component resolution. You can import it from `eleva/plugins`.

**Q: What plugins are available with Eleva?**
_A:_ Eleva comes with three powerful built-in plugins: Attr for advanced attribute handling (ARIA, data attributes, boolean attributes), Router for client-side routing with navigation guards and reactive state, and Store for reactive state management with persistence and namespacing. Props are now evaluated natively in the core framework without requiring a plugin. All plugins are designed to work seamlessly with the core framework.

**Q: Can I create custom plugins for Eleva?**
_A:_ Yes! Eleva has a simple plugin API. Plugins are objects with an `install(eleva, options)` method. See the [Custom Plugin Guide](./examples/custom-plugin.md) for detailed instructions on creating and publishing your own plugins.

### Migration Questions

**Q: How do I migrate from React to Eleva?**
_A:_ Migration involves: (1) Replace `useState` with Eleva's `signal()`, (2) Convert JSX components to Eleva's template string components, (3) Replace `useEffect` with signal watchers or lifecycle hooks, (4) Replace React Router with Eleva's Router plugin. See the [Migration Guide](./migration/from-react.md) for detailed examples.

**Q: How do I migrate from Vue to Eleva?**
_A:_ Migration involves: (1) Convert SFCs to Eleva component objects, (2) Replace Vue's reactive/ref with Eleva's signals, (3) Convert Vue Router to Eleva's Router plugin, (4) Replace Vuex/Pinia with Eleva's Store plugin. See the [Migration Guide](./migration/from-vue.md) for detailed examples.

**Q: How do I migrate from Alpine.js to Eleva?**
_A:_ Both Alpine and Eleva share a similar philosophy‚Äîlightweight, no build step. The key difference is approach: Alpine is HTML-first with directives, Eleva is JS-first with template functions. Migration involves: (1) Replace `x-data` with `setup()` + `signal()`, (2) Convert `x-show`/`x-if` to ternary expressions, (3) Replace `x-for` with `.map().join('')`, (4) Convert `x-model` to value + `@input` pattern. See the [Migration Guide](./migration/from-alpine.md) for detailed examples.

**Q: How do I migrate from jQuery to Eleva?**
_A:_ Eleva is a great step up from jQuery for those wanting modern component architecture. Migration involves: (1) Replace DOM selection with component templates, (2) Replace jQuery events with Eleva's `@event` syntax, (3) Replace global state with signals, (4) Organize code into reusable components. See the [Migration Guide](./migration/from-jquery.md) for detailed examples.

---

## 13. Testing

Eleva has a comprehensive test suite ensuring reliability and stability.

### Test Coverage

| Metric | Value |
|--------|-------|
| **Total Tests** | 273 |
| **Line Coverage** | 100% |
| **Function Coverage** | 100% (core) |
| **Test Runner** | Bun |

### Running Tests

```bash
# Run all tests
bun test

# Run with coverage report
bun test:coverage

# Run unit tests only
bun test test/unit

# Run performance benchmarks
bun test:benchmark

# Run prepublish checks (lint + test + build)
bun run prepublishOnly
```

### Test Structure

```
test/
‚îú‚îÄ‚îÄ unit/                    # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ core/               # Core Eleva tests
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Eleva.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ modules/            # Module tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Emitter.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Renderer.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Signal.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TemplateEngine.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ plugins/            # Plugin tests
‚îÇ       ‚îú‚îÄ‚îÄ Attr.test.ts
‚îÇ       ‚îú‚îÄ‚îÄ Props.test.ts
‚îÇ       ‚îú‚îÄ‚îÄ Router.test.ts
‚îÇ       ‚îî‚îÄ‚îÄ Store.test.ts
‚îî‚îÄ‚îÄ performance/            # Performance benchmarks
    ‚îú‚îÄ‚îÄ fps-benchmark.test.ts
    ‚îî‚îÄ‚îÄ js-framework-benchmark.test.ts
```

### Writing Tests

Eleva uses [Bun's built-in test runner](https://bun.sh/docs/cli/test) with a Jest-compatible API:

```typescript
import { describe, test, expect, beforeEach } from "bun:test";
import Eleva from "../../src/index.js";

describe("MyComponent", () => {
  let app: Eleva;

  beforeEach(() => {
    document.body.innerHTML = `<div id="app"></div>`;
    app = new Eleva("TestApp");
  });

  test("should mount correctly", async () => {
    const component = {
      setup: ({ signal }) => ({ count: signal(0) }),
      template: (ctx) => `<div>${ctx.count.value}</div>`
    };

    const instance = await app.mount(
      document.getElementById("app")!,
      component
    );

    expect(instance).toBeTruthy();
    expect(document.body.innerHTML).toContain("0");
  });
});
```

---

## 14. Troubleshooting & Migration

### Troubleshooting

- **Common Issues:**

  - Check your console for error messages.
  - Verify that the correct DOM element is passed to `mount()`.
  - Ensure that component names and definitions are correct.

### Migration Guidelines

- **Review Breaking Changes:** Always check the changelog when upgrading.
- **Update Deprecated Features:** Adjust your code to remove any deprecated API usage.
- **Thorough Testing:** Test your application after each upgrade to catch potential issues.

---

## 15. API Reference

Detailed API documentation with parameter descriptions, return values, and usage examples can be found in the [docs](https://github.com/TarekRaafat/eleva/blob/master/docs/index.md) folder.

- **TemplateEngine:**  
  `parse(template, data)` and `evaluate(expr, data)`

- **Signal:**  
  `new Signal(value)`, getter/setter for `signal.value`, and `signal.watch(fn)`

- **Emitter:**  
  Methods: `on(event, handler)`, `off(event, handler)`, and `emit(event, ...args)`

- **Renderer:**  
  Methods: `patchDOM(container, newHtml)`, `diff(oldParent, newParent)`, and `updateAttributes(oldEl, newEl)`

- **Built-in Plugins:**
  - **[Attr](./plugins/attr.md):** Advanced attribute handling with ARIA support
  - **[Router](./plugins/router.md):** Client-side routing with navigation guards and reactive state
  - **[Store](./plugins/store.md):** Reactive state management with persistence and namespacing

- **Eleva (Core):**  
  `new Eleva(name, config)`, `use(plugin, options)`, `component(name, definition)`, and `mount(container, compName, props)`

---

## 16. Contributing

Contributions are welcome! Whether you're fixing bugs, adding features, or improving documentation, your input is invaluable. Please checkout the [CONTRIBUTING](https://github.com/TarekRaafat/eleva/blob/master/CONTRIBUTING.md) file for detailed guidelines on how to get started.

---

## 17. Community & Support

Join our community for support, discussions, and collaboration:

- **GitHub Discussions:** For general questions or new ideas please start a discussion on [Eleva Discussions](https://github.com/TarekRaafat/eleva/discussions)
- **GitHub Issues:** Report bugs or request features on [GitHub Issues](https://github.com/TarekRaafat/eleva/issues)
- **Stack Overflow:** For technical questions and support, please post your question on Stack Overflow using any of these tags [eleva](https://stackoverflow.com/questions/tagged/eleva), [eleva.js](https://stackoverflow.com/questions/tagged/eleva.js)
- **Reddit:** Join our subreddit community at [r/elevajs](https://www.reddit.com/r/elevajs/) to share projects, ask questions, and connect with other developers
- **Discord:** Connect with us on [Discord](https://discord.gg/Dg7cMKpvyZ) to discuss Eleva, ask questions, and contribute!
- **Telegram:** For general questions, new ideas please, or even support join us on our [Telegram](https://t.me/+TcMXcHsRX9tkMmI0) group for realtime feedback.

---

## 18. Changelog

For a detailed log of all changes and updates, please refer to the [Changelog](https://github.com/TarekRaafat/eleva/blob/master/CHANGELOG.md).

---

## 19. License

Eleva is open-source and available under the [MIT License](https://github.com/TarekRaafat/eleva/blob/master/LICENSE).

---

Thank you for exploring Eleva! I hope this documentation helps you build amazing, high-performance frontend applications using pure vanilla JavaScript. For further information, interactive demos, and community support, please visit the [GitHub Discussions](https://github.com/TarekRaafat/eleva/discussions) page.

---

## Summary

### Framework Statistics

| Metric | Value |
|--------|-------|
| **Bundle Size** | ~6KB minified, ~2.3KB gzipped |
| **Dependencies** | Zero |
| **Core Modules** | 5 (Eleva, Signal, Emitter, Renderer, TemplateEngine) |
| **Lifecycle Hooks** | 5 (onBeforeMount, onMount, onBeforeUpdate, onUpdate, onUnmount) |
| **Built-in Plugins** | 3 (Attr, Router, Store) |
| **Template Syntaxes** | 3 (${}, @event, :prop) |

### Core Modules Quick Reference

| Module | Purpose | Key Methods |
|--------|---------|-------------|
| **Eleva** | App orchestration | `component()`, `mount()`, `use()` |
| **Signal** | Reactive state | `.value`, `.watch()` |
| **Emitter** | Event handling | `.on()`, `.off()`, `.emit()` |
| **Renderer** | DOM diffing | `.patchDOM()` |
| **TemplateEngine** | Expression evaluation | `.evaluate()` |

### Component Definition Structure

```javascript
{
  setup({ signal, emitter, props }) {   // Optional: Initialize state
    const state = signal(initialValue);
    return {
      state,
      onMount: ({ container, context }) => {},   // Lifecycle hooks
      onUnmount: ({ container, context, cleanup }) => {}
    };
  },
  template(ctx) {                       // Required: Return HTML string
    return `<div>${ctx.state.value}</div>`;
  },
  style(ctx) {                          // Optional: Scoped CSS
    return `.component { color: blue; }`;
  },
  children: {                           // Optional: Child components
    ".selector": "ComponentName"
  }
}
```

<details>
<summary><strong>Data Flow Diagram</strong> (click to expand)</summary>
<pre>
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     ELEVA DATA FLOW                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  [Component Registration]                                   ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  [Mounting & Context Creation]                              ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  [setup() Execution] ‚îÄ‚îÄ‚ñ∫ Returns { state, hooks }           ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  [template() Produces HTML]                                 ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  [onBeforeMount]                                            ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  [Renderer.patchDOM()] ‚îÄ‚îÄ‚ñ∫ Diff & patch changes             ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  [TemplateEngine] ‚îÄ‚îÄ‚ñ∫ Bind @events, eval :props             ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ      [onMount]                                              ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚Ü∫ REACTIVE CYCLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                                                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [Idle: Waiting] ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [User Interaction] ‚îÄ‚îÄ‚ñ∫ Event Handler              ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [signal.value = newValue]                         ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [queueMicrotask batching]                         ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [template() Re-evaluation]                        ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [onBeforeUpdate]                                  ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [Renderer.patchDOM()]                             ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [TemplateEngine] ‚îÄ‚îÄ‚ñ∫ Re-bind @events              ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚îÇ                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ        ‚ñº                                           ‚îÇ   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  [onUpdate] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                                        ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>
</details>

### Installation Methods

| Method | Command/Code |
|--------|--------------|
| **npm** | `npm install eleva` |
| **CDN (jsDelivr)** | `<script src="https://cdn.jsdelivr.net/npm/eleva"></script>` |
| **CDN (unpkg)** | `<script src="https://unpkg.com/eleva"></script>` |
| **ESM Import** | `import Eleva from "eleva"` |
| **Plugin Import** | `import { Router, Store } from "eleva/plugins"` |

For questions or issues, visit the [GitHub repository](https://github.com/TarekRaafat/eleva).

<!-- JSON-LD Structured Data for SEO and GEO -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "Eleva.js",
  "alternateName": ["Eleva", "ElevaJS"],
  "description": "A 6KB minimalist pure vanilla JavaScript frontend framework designed for exceptional Developer Experience. Signal-based reactivity and zero dependencies.",
  "url": "https://elevajs.com",
  "applicationCategory": "DeveloperApplication",
  "applicationSubCategory": "JavaScript Framework",
  "operatingSystem": "Cross-platform (Web Browser)",
  "softwareVersion": "1.0.0",
  "datePublished": "2026-01-12",
  "releaseNotes": "First official stable release with production-ready API",
  "downloadUrl": "https://www.npmjs.com/package/eleva",
  "installUrl": "https://www.npmjs.com/package/eleva",
  "fileSize": "6KB",
  "memoryRequirements": "Minimal",
  "storageRequirements": "6KB minified, 2.3KB gzipped",
  "softwareRequirements": "Modern web browser (Chrome 71+, Firefox 69+, Safari 12.1+, Edge 79+)",
  "permissions": "None required",
  "featureList": [
    "Signal-based reactivity",
    "Zero dependencies",
    "No build step required",
    "Built-in TypeScript support",
    "Component-based architecture",
    "Direct DOM manipulation",
    "Plugin system (Router, Store, Attr)",
    "Lifecycle hooks",
    "Event handling",
    "Template literals"
  ],
  "screenshot": "https://elevajs.com/imgs/eleva.js Full Logo.png",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD",
    "availability": "https://schema.org/InStock"
  },
  "author": {
    "@type": "Person",
    "name": "Tarek Raafat",
    "url": "https://www.tarekraafat.com",
    "email": "tarek.m.raafat@gmail.com"
  },
  "maintainer": {
    "@type": "Person",
    "name": "Tarek Raafat",
    "url": "https://www.tarekraafat.com"
  },
  "license": "https://opensource.org/licenses/MIT",
  "isAccessibleForFree": true,
  "codeRepository": "https://github.com/TarekRaafat/eleva",
  "programmingLanguage": {
    "@type": "ComputerLanguage",
    "name": "JavaScript"
  },
  "runtimePlatform": "Web Browser",
  "keywords": "javascript framework, frontend framework, react alternative, vue alternative, signal-based reactivity, lightweight framework, vanilla javascript"
}
</script>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "What is Eleva.js?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Eleva is a minimalist, lightweight (6KB) pure vanilla JavaScript frontend framework. It provides React-like component-based architecture with signal-based reactivity, but without the complexity, dependencies, or mandatory build tools of larger frameworks."
      }
    },
    {
      "@type": "Question",
      "name": "Is Eleva production-ready?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes! Eleva v1.0.0 is the first official stable release. The framework is production-ready with a stable API and comprehensive test coverage (273 tests, 100% line coverage)."
      }
    },
    {
      "@type": "Question",
      "name": "What is the difference between Eleva and React?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Eleva differs from React in several key ways: (1) Eleva is 6KB vs React's 42KB+ bundle size, (2) Eleva has zero dependencies while React has several, (3) Eleva uses signal-based reactivity instead of virtual DOM diffing, (4) Eleva requires no build step and works directly via CDN, (5) Eleva uses template strings instead of JSX."
      }
    },
    {
      "@type": "Question",
      "name": "Does Eleva use Virtual DOM?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "No. Eleva uses real DOM manipulation with an efficient diffing algorithm. Instead of maintaining a virtual DOM tree in memory and comparing it to compute changes, Eleva directly patches the real DOM. This approach is simpler and often faster for smaller applications."
      }
    },
    {
      "@type": "Question",
      "name": "Does Eleva require a build step?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "No. Eleva can be used directly via CDN without any build tools, bundlers, or transpilers. Simply include the script tag and start coding. However, you can also use Eleva with bundlers like Vite, Webpack, or Rollup if you prefer."
      }
    },
    {
      "@type": "Question",
      "name": "Can I use Eleva with TypeScript?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Absolutely! Eleva includes built-in TypeScript declarations (.d.ts files) to help keep your codebase strongly typed. No additional @types packages are needed."
      }
    },
    {
      "@type": "Question",
      "name": "What plugins are available with Eleva?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Eleva comes with three powerful built-in plugins: Attr for advanced attribute handling (ARIA, data attributes, boolean attributes), Router for client-side routing with navigation guards and reactive state, and Store for reactive state management with persistence and namespacing."
      }
    },
    {
      "@type": "Question",
      "name": "How does Eleva's reactivity work?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Eleva uses a signal-based reactivity system similar to Solid.js. Signals are reactive containers that hold values. When a signal's value changes, any component or watcher subscribed to that signal automatically updates. This provides fine-grained reactivity without the overhead of virtual DOM diffing."
      }
    }
  ]
}
</script>
{"version":3,"file":"store.umd.min.js","sources":["../../src/plugins/Store.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @module eleva/plugins/store\n * @fileoverview Reactive state management plugin with namespaced modules,\n * persistence, and subscription system.\n */\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\n// -----------------------------------------------------------------------------\n// External Type Imports\n// -----------------------------------------------------------------------------\n\n/**\n * Type imports from the Eleva core library.\n * @typedef {import('eleva').Eleva} Eleva\n * @typedef {import('eleva').ComponentDefinition} ComponentDefinition\n * @typedef {import('eleva').ComponentContext} ComponentContext\n * @typedef {import('eleva').SetupResult} SetupResult\n * @typedef {import('eleva').ComponentProps} ComponentProps\n * @typedef {import('eleva').ChildrenMap} ChildrenMap\n * @typedef {import('eleva').MountResult} MountResult\n */\n\n/**\n * Generic type import.\n * @template T\n * @typedef {import('eleva').Signal<T>} Signal\n */\n\n// -----------------------------------------------------------------------------\n// Store Type Definitions\n// -----------------------------------------------------------------------------\n\n/**\n * Mutation record emitted to subscribers.\n * @typedef {Object} StoreMutation\n * @property {string} type\n *           The action name that was dispatched.\n * @property {unknown} payload\n *           The payload passed to the action.\n * @property {number} timestamp\n *           Unix timestamp of when the mutation occurred.\n * @description Record passed to subscribers when state changes via dispatch.\n * @example\n * store.subscribe((mutation, state) => {\n *   console.log(`Action: ${mutation.type}`);\n *   console.log(`Payload: ${mutation.payload}`);\n *   console.log(`Time: ${new Date(mutation.timestamp)}`);\n * });\n */\n\n/**\n * Store configuration options.\n * @typedef {Object} StoreOptions\n * @property {Record<string, unknown>} [state]\n *           Initial state object.\n * @property {Record<string, ActionFunction>} [actions]\n *           Action functions for state mutations.\n * @property {Record<string, StoreModule>} [namespaces]\n *           Namespaced modules for organizing store.\n * @property {StorePersistenceOptions} [persistence]\n *           Persistence configuration.\n * @property {boolean} [devTools]\n *           Enable development tools integration.\n * @property {StoreErrorHandler} [onError]\n *           Error handler function.\n * @description Configuration options passed to StorePlugin.install().\n * @example\n * app.use(StorePlugin, {\n *   state: { count: 0, user: null },\n *   actions: {\n *     increment: (state) => state.count.value++,\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: { enabled: true, key: 'my-app' }\n * });\n */\n\n/**\n * Namespaced store module definition.\n * @typedef {Object} StoreModule\n * @property {Record<string, unknown>} state\n *           Module state.\n * @property {Record<string, ActionFunction>} [actions]\n *           Module actions.\n * @description Defines a namespaced module for organizing related state and actions.\n * @example\n * // Define a module\n * const authModule = {\n *   state: { user: null, token: null },\n *   actions: {\n *     login: (state, { user, token }) => {\n *       state.auth.user.value = user;\n *       state.auth.token.value = token;\n *     }\n *   }\n * };\n *\n * // Register dynamically\n * store.registerModule('auth', authModule);\n */\n\n/**\n * Store persistence configuration.\n * @typedef {Object} StorePersistenceOptions\n * @property {boolean} [enabled]\n *           Enable state persistence.\n * @property {string} [key]\n *           Storage key (default: \"eleva-store\").\n * @property {'localStorage' | 'sessionStorage'} [storage]\n *           Storage type.\n * @property {string[]} [include]\n *           Dot-path prefixes to persist (e.g., \"auth.user\").\n * @property {string[]} [exclude]\n *           Dot-path prefixes to exclude.\n * @description Configuration for persisting store state to localStorage or sessionStorage.\n * @example\n * // Persist only specific state paths\n * persistence: {\n *   enabled: true,\n *   key: 'my-app-store',\n *   storage: 'localStorage',\n *   include: ['user', 'settings.theme']\n * }\n *\n * @example\n * // Exclude sensitive data\n * persistence: {\n *   enabled: true,\n *   exclude: ['auth.token', 'temp']\n * }\n */\n\n/**\n * Store error handler callback.\n * @typedef {(error: Error, context: string) => void} StoreErrorHandler\n * @description Custom error handler for store operations.\n * @example\n * app.use(StorePlugin, {\n *   onError: (error, context) => {\n *     console.error(`Store error in ${context}:`, error);\n *     // Send to error tracking service\n *     errorTracker.capture(error, { context });\n *   }\n * });\n */\n\n/**\n * Reactive state tree containing signals and nested namespaces.\n * @typedef {Record<string, Signal<unknown> | Record<string, unknown>>} StoreState\n * @description Represents the store's reactive state structure with support for nested modules.\n */\n\n/**\n * Action function signature for store actions.\n * @typedef {(state: StoreState, payload?: unknown) => unknown} ActionFunction\n * @description Function that receives state and optional payload, returns action result.\n */\n\n/**\n * Dispatch function signature for triggering actions.\n * @typedef {(actionName: string, payload?: unknown) => Promise<unknown>} DispatchFunction\n * @description Dispatches an action by name with optional payload, returns action result.\n */\n\n/**\n * Subscribe callback signature for mutation listeners.\n * @typedef {(mutation: StoreMutation, state: StoreState) => void} SubscribeCallback\n * @description Called after each successful action dispatch with mutation details and current state.\n */\n\n/**\n * Store API exposed to components via ctx.store.\n * @typedef {Object} StoreApi\n * @property {StoreState} state\n *           Reactive state signals (supports nested modules).\n * @property {DispatchFunction} dispatch\n *           Dispatch an action by name with optional payload.\n * @property {(callback: SubscribeCallback) => () => void} subscribe\n *           Subscribe to state mutations. Returns unsubscribe function.\n * @property {() => Record<string, unknown>} getState\n *           Get a snapshot of current state values.\n * @property {(namespace: string, module: StoreModule) => void} registerModule\n *           Register a namespaced module dynamically.\n * @property {(namespace: string) => void} unregisterModule\n *           Unregister a namespaced module.\n * @property {(key: string, initialValue: unknown) => Signal<unknown>} createState\n *           Create a new state signal dynamically.\n * @property {(name: string, actionFn: ActionFunction) => void} createAction\n *           Register a new action dynamically.\n * @property {new <T>(value: T) => Signal<T>} signal\n *           Signal class constructor for manual state creation.\n * @description The store API injected into component setup as `ctx.store`.\n * @example\n * app.component('Counter', {\n *   setup({ store }) {\n *     // Access reactive state\n *     const count = store.state.count;\n *\n *     // Dispatch actions\n *     const increment = () => store.dispatch('increment');\n *\n *     // Subscribe to changes\n *     const unsub = store.subscribe((mutation) => {\n *       console.log('State changed:', mutation.type);\n *     });\n *\n *     return { count, increment, onUnmount: () => unsub() };\n *   },\n *   template: (ctx) => `<button @click=\"increment\">${ctx.count.value}</button>`\n * });\n * @see StoreMutation - Mutation record structure.\n * @see StoreModule - Module definition for namespaces.\n */\n\n/**\n * @class ðŸª StorePlugin\n * @classdesc A powerful reactive state management plugin for Eleva that enables sharing\n * reactive data across the entire application. The Store plugin provides a centralized,\n * reactive data store that can be accessed from any component's setup function.\n *\n * Core Features:\n * - Centralized reactive state management using Eleva's signal system\n * - Global state accessibility through component setup functions\n * - Namespace support for organizing store modules\n * - Built-in persistence with localStorage/sessionStorage support\n * - Action-based state mutations with validation\n * - Subscription system for reactive updates\n * - DevTools integration for debugging\n * - Plugin architecture for extensibility\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(StorePlugin, {\n *   state: {\n *     user: { name: \"John\", email: \"john@example.com\" },\n *     counter: 0,\n *     todos: []\n *   },\n *   actions: {\n *     increment: (state) => state.counter.value++,\n *     addTodo: (state, todo) => state.todos.value = [...state.todos.value, todo],\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: {\n *     enabled: true,\n *     key: \"myApp-store\",\n *     storage: \"localStorage\"\n *   }\n * });\n *\n * // Use store in components\n * app.component(\"Counter\", {\n *   setup({ store }) {\n *     return {\n *       count: store.state.counter,\n *       increment: () => store.dispatch(\"increment\"),\n *       user: store.state.user\n *     };\n *   },\n *   template: (ctx) => `\n *     <div>\n *       <p>Hello ${ctx.user.value.name}!</p>\n *       <p>Count: ${ctx.count.value}</p>\n *       <button @click=\"increment\">+</button>\n *     </div>\n *   `\n * });\n */\nexport const StorePlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"store\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.1.0\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description:\n    \"Reactive state management for sharing data across the entire Eleva application\",\n\n  /**\n   * Installs the plugin into the Eleva instance.\n   *\n   * @public\n   * @param {Eleva} eleva - The Eleva instance.\n   * @param {StoreOptions} options - Plugin configuration options.\n   * @param {Record<string, unknown>} [options.state={}] - Initial state object.\n   * @param {Record<string, ActionFunction>} [options.actions={}] - Action functions for state mutations.\n   * @param {Record<string, StoreModule>} [options.namespaces={}] - Namespaced modules for organizing store.\n   * @param {StorePersistenceOptions} [options.persistence] - Persistence configuration.\n   * @param {boolean} [options.persistence.enabled=false] - Enable state persistence.\n   * @param {string} [options.persistence.key=\"eleva-store\"] - Storage key.\n   * @param {'localStorage' | 'sessionStorage'} [options.persistence.storage=\"localStorage\"] - Storage type.\n   * @param {string[]} [options.persistence.include] - Dot-path prefixes to persist (e.g., \"auth.user\")\n   * @param {string[]} [options.persistence.exclude] - Dot-path prefixes to exclude (applies when include is empty).\n   * @param {boolean} [options.devTools=false] - Enable development tools integration.\n   * @param {(error: Error, context: string) => void} [options.onError=null] - Error handler function.\n   * @returns {void}\n   * @description\n   * Installs the store and injects `store` into component setup context by wrapping\n   * `eleva.mount` and `eleva._mountComponents`. Also exposes `eleva.store` and\n   * helper methods (`eleva.dispatch`, `eleva.getState`, `eleva.subscribe`, `eleva.createAction`).\n   * Uninstall restores the originals.\n   *\n   * @example\n   * // Basic installation\n   * app.use(StorePlugin, {\n   *   state: { count: 0, user: null },\n   *   actions: {\n   *     increment: (state) => state.count.value++,\n   *     setUser: (state, user) => state.user.value = user\n   *   }\n   * });\n   *\n   * // Advanced installation with persistence and namespaces\n   * app.use(StorePlugin, {\n   *   state: { theme: \"light\" },\n   *   namespaces: {\n   *     auth: {\n   *       state: { user: null, token: null },\n   *       actions: {\n   *         login: (state, { user, token }) => {\n   *           state.auth.user.value = user;\n   *           state.auth.token.value = token;\n   *         },\n   *         logout: (state) => {\n   *           state.auth.user.value = null;\n   *           state.auth.token.value = null;\n   *         }\n   *       }\n   *     }\n   *   },\n   *   persistence: {\n   *     enabled: true,\n   *     include: [\"theme\", \"auth.user\"]\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      state = {},\n      actions = {},\n      namespaces = {},\n      persistence = {},\n      devTools = false,\n      onError = null,\n    } = options;\n\n    /**\n     * @class Store\n     * @classdesc Store instance that manages all state and provides the API.\n     * @private\n     */\n    class Store {\n      /**\n       * Creates a new Store instance.\n       * Initializes state signals, actions, persistence, and devtools integration.\n       *\n       * @constructor\n       */\n      constructor() {\n        /** @type {Record<string, Signal | Record<string, unknown>>} */\n        this.state = {};\n        /** @type {Record<string, ActionFunction | Record<string, ActionFunction>>} */\n        this.actions = {};\n        /** @type {Set<SubscribeCallback>} */\n        this.subscribers = new Set();\n        /** @type {StoreMutation[]} */\n        this.mutations = [];\n        /** @type {{enabled: boolean, key: string, storage: string, include: string[]|null, exclude: string[]|null}} */\n        this.persistence = {\n          enabled: false,\n          key: \"eleva-store\",\n          storage: \"localStorage\",\n          include: null,\n          exclude: null,\n          ...persistence,\n        };\n        /** @type {boolean} */\n        this.devTools = devTools;\n        /** @type {((error: Error, context: string) => void)|null} */\n        this.onError = onError;\n\n        this._initializeState(state, actions);\n        this._initializeNamespaces(namespaces);\n        this._loadPersistedState();\n        this._setupDevTools();\n      }\n\n      /**\n       * Initializes the root state and actions.\n       * Creates reactive signals for each state property and copies actions.\n       *\n       * @private\n       * @param {Record<string, unknown>} initialState - The initial state key-value pairs.\n       * @param {Record<string, ActionFunction>} initialActions - The action functions to register.\n       * @returns {void}\n       */\n      _initializeState(initialState, initialActions) {\n        // Create reactive signals for each state property\n        Object.entries(initialState).forEach(([key, value]) => {\n          this.state[key] = new eleva.signal(value);\n        });\n\n        // Set up actions\n        this.actions = { ...initialActions };\n      }\n\n      /**\n       * Initializes namespaced modules.\n       * Creates namespace objects and populates them with state signals and actions.\n       *\n       * @private\n       * @param {Record<string, StoreModule>} namespaces - Map of namespace names to module definitions.\n       * @returns {void}\n       */\n      _initializeNamespaces(namespaces) {\n        Object.entries(namespaces).forEach(([namespace, module]) => {\n          const { state: moduleState = {}, actions: moduleActions = {} } =\n            module;\n\n          // Create namespace object if it doesn't exist\n          if (!this.state[namespace]) {\n            this.state[namespace] = {};\n          }\n          if (!this.actions[namespace]) {\n            this.actions[namespace] = {};\n          }\n\n          // Initialize namespaced state\n          Object.entries(moduleState).forEach(([key, value]) => {\n            this.state[namespace][key] = new eleva.signal(value);\n          });\n\n          // Set up namespaced actions\n          this.actions[namespace] = { ...moduleActions };\n        });\n      }\n\n      /**\n       * Loads persisted state from storage.\n       * Reads from localStorage/sessionStorage and applies values to state signals.\n       * Does nothing if persistence is disabled or running in SSR environment.\n       *\n       * @private\n       * @returns {void}\n       */\n      _loadPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const persistedData = storage.getItem(this.persistence.key);\n\n          if (persistedData) {\n            const data = JSON.parse(persistedData);\n            this._applyPersistedData(data);\n          }\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to load persisted state\");\n          } else {\n            console.warn(\n              \"[StorePlugin] Failed to load persisted state:\",\n              error\n            );\n          }\n        }\n      }\n\n      /**\n       * Applies persisted data to the current state.\n       * Recursively updates signal values for paths that should be persisted.\n       *\n       * @private\n       * @param {Record<string, unknown>} data - The persisted data object to apply.\n       * @param {Record<string, unknown>} [currentState=this.state] - The current state object to update.\n       * @param {string} [path=\"\"] - The current dot-notation path (for include/exclude filtering).\n       * @returns {void}\n       */\n      _applyPersistedData(data, currentState = this.state, path = \"\") {\n        Object.entries(data).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (\n              currentState[key] &&\n              typeof currentState[key] === \"object\" &&\n              \"value\" in currentState[key]\n            ) {\n              // This is a signal, update its value\n              currentState[key].value = value;\n            } else if (\n              typeof value === \"object\" &&\n              value !== null &&\n              currentState[key]\n            ) {\n              // This is a nested object, recurse\n              this._applyPersistedData(value, currentState[key], fullPath);\n            }\n          }\n        });\n      }\n\n      /**\n       * Determines if a state path should be persisted.\n       * Checks against include/exclude filters configured in persistence options.\n       *\n       * @private\n       * @param {string} path - The dot-notation path to check (e.g., \"auth.user\").\n       * @returns {boolean} True if the path should be persisted, false otherwise.\n       */\n      _shouldPersist(path) {\n        const { include, exclude } = this.persistence;\n\n        if (include && include.length > 0) {\n          return include.some((includePath) => path.startsWith(includePath));\n        }\n\n        if (exclude && exclude.length > 0) {\n          return !exclude.some((excludePath) => path.startsWith(excludePath));\n        }\n\n        return true;\n      }\n\n      /**\n       * Saves current state to storage.\n       * Extracts persistable data and writes to localStorage/sessionStorage.\n       * Does nothing if persistence is disabled or running in SSR environment.\n       *\n       * @private\n       * @returns {void}\n       */\n      _saveState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const dataToSave = this._extractPersistedData();\n          storage.setItem(this.persistence.key, JSON.stringify(dataToSave));\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to save state\");\n          } else {\n            console.warn(\"[StorePlugin] Failed to save state:\", error);\n          }\n        }\n      }\n\n      /**\n       * Extracts data that should be persisted.\n       * Recursively extracts signal values for paths that pass persistence filters.\n       *\n       * @private\n       * @param {Record<string, unknown>} [currentState=this.state] - The state object to extract from.\n       * @param {string} [path=\"\"] - The current dot-notation path (for include/exclude filtering).\n       * @returns {Record<string, unknown>} The extracted data object with raw values (not signals).\n       */\n      _extractPersistedData(currentState = this.state, path = \"\") {\n        const result = {};\n\n        Object.entries(currentState).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (value && typeof value === \"object\" && \"value\" in value) {\n              // This is a signal, extract its value\n              result[key] = value.value;\n            } else if (typeof value === \"object\" && value !== null) {\n              // This is a nested object, recurse\n              const nestedData = this._extractPersistedData(value, fullPath);\n              if (Object.keys(nestedData).length > 0) {\n                result[key] = nestedData;\n              }\n            }\n          }\n        });\n\n        return result;\n      }\n\n      /**\n       * Sets up development tools integration.\n       * Registers the store with Eleva DevTools if available and enabled.\n       * Does nothing if devTools is disabled, running in SSR, or DevTools not installed.\n       *\n       * @private\n       * @returns {void}\n       */\n      _setupDevTools() {\n        if (\n          !this.devTools ||\n          typeof window === \"undefined\" ||\n          !window.__ELEVA_DEVTOOLS__\n        ) {\n          return;\n        }\n\n        window.__ELEVA_DEVTOOLS__.registerStore(this);\n      }\n\n      /**\n       * Dispatches an action to mutate the state.\n       *\n       * Execution flow:\n       * 1. Retrieves the action function (supports namespaced actions like \"auth.login\")\n       * 2. Records mutation for devtools/history (keeps last 100 mutations)\n       * 3. Executes action with await (actions can be sync or async)\n       * 4. Saves state if persistence is enabled\n       * 5. Notifies all subscribers with (mutation, state)\n       * 6. Notifies devtools if enabled\n       *\n       * @note Always returns a Promise regardless of whether the action is sync or async.\n       * Subscriber callbacks that throw are caught and passed to onError handler.\n       *\n       * @async\n       * @param {string} actionName - The name of the action to dispatch (supports dot notation for namespaces).\n       * @param {unknown} payload - The payload to pass to the action.\n       * @returns {Promise<unknown>} The result of the action (undefined if action returns nothing).\n       * @throws {Error} If action is not found or action function throws.\n       * @see subscribe - Listen for mutations triggered by dispatch.\n       * @see getState - Get current state values.\n       */\n      async dispatch(actionName, payload) {\n        try {\n          const action = this._getAction(actionName);\n\n          if (!action) {\n            const error = new Error(`Action \"${actionName}\" not found`);\n            if (this.onError) {\n              this.onError(error, actionName);\n            }\n            throw error;\n          }\n\n          const mutation = {\n            type: actionName,\n            payload,\n            timestamp: Date.now(),\n          };\n\n          // Record mutation for devtools\n          this.mutations.push(mutation);\n          if (this.mutations.length > 100) {\n            this.mutations.shift(); // Keep only last 100 mutations\n          }\n\n          // Execute the action\n          const result = await action.call(null, this.state, payload);\n\n          // Save state if persistence is enabled\n          this._saveState();\n\n          // Notify subscribers\n          this.subscribers.forEach((callback) => {\n            try {\n              callback(mutation, this.state);\n            } catch (error) {\n              if (this.onError) {\n                this.onError(error, \"Subscriber callback failed\");\n              }\n            }\n          });\n\n          // Notify devtools\n          if (\n            this.devTools &&\n            typeof window !== \"undefined\" &&\n            window.__ELEVA_DEVTOOLS__\n          ) {\n            window.__ELEVA_DEVTOOLS__.notifyMutation(mutation, this.state);\n          }\n\n          return result;\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, `Action dispatch failed: ${actionName}`);\n          }\n          throw error;\n        }\n      }\n\n      /**\n       * Gets an action by name (supports namespaced actions).\n       * Traverses the actions object using dot-notation path segments.\n       *\n       * @private\n       * @param {string} actionName - The action name, supports dot notation for namespaces (e.g., \"auth.login\").\n       * @returns {ActionFunction | null} The action function if found and is a function, null otherwise.\n       */\n      _getAction(actionName) {\n        const parts = actionName.split(\".\");\n        let current = this.actions;\n\n        for (const part of parts) {\n          if (current[part] === undefined) {\n            return null;\n          }\n          current = current[part];\n        }\n\n        return typeof current === \"function\" ? current : null;\n      }\n\n      /**\n       * Subscribes to store mutations.\n       * Callback is invoked after every successful action dispatch.\n       *\n       * @param {SubscribeCallback} callback\n       *        Called after each mutation with:\n       *        - mutation.type: The action name that was dispatched\n       *        - mutation.payload: The payload passed to the action\n       *        - mutation.timestamp: When the mutation occurred (Date.now())\n       *        - state: The current state object (contains Signals)\n       * @returns {() => void} Unsubscribe function. Call to stop receiving notifications.\n       * @throws {Error} If callback is not a function.\n       * @see dispatch - Triggers mutations that notify subscribers.\n       */\n      subscribe(callback) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Subscribe callback must be a function\");\n        }\n\n        this.subscribers.add(callback);\n\n        // Return unsubscribe function\n        return () => {\n          this.subscribers.delete(callback);\n        };\n      }\n\n      /**\n       * Gets current state values (not signals).\n       *\n       * @note When persistence include/exclude filters are configured,\n       * this returns only the filtered subset of state.\n       * @returns {Record<string, unknown>} The current state values (filtered by persistence config if set).\n       * @see replaceState - Set state values.\n       * @see subscribe - Listen for state changes.\n       */\n      getState() {\n        return this._extractPersistedData();\n      }\n\n      /**\n       * Replaces state values (useful for testing or state hydration).\n       *\n       * @note When persistence include/exclude filters are configured,\n       * this only updates the filtered subset of state.\n       * @param {Record<string, unknown>} newState - The new state object.\n       * @returns {void}\n       * @see getState - Get current state values.\n       */\n      replaceState(newState) {\n        this._applyPersistedData(newState);\n        this._saveState();\n      }\n\n      /**\n       * Clears persisted state from storage.\n       * Does nothing if persistence is disabled or running in SSR.\n       * @returns {void}\n       */\n      clearPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          storage.removeItem(this.persistence.key);\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to clear persisted state\");\n          }\n        }\n      }\n\n      /**\n       * Registers a new namespaced module at runtime.\n       * Logs a warning if the namespace already exists.\n       * Module state is nested under `state[namespace]` and actions under `actions[namespace]`.\n       * @param {string} namespace - The namespace for the module.\n       * @param {StoreModule} module - The module definition.\n       * @param {Record<string, unknown>} module.state - The module's initial state.\n       * @param {Record<string, ActionFunction>} module.actions - The module's actions.\n       * @returns {void}\n       */\n      registerModule(namespace, module) {\n        if (this.state[namespace] || this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" already exists`);\n          return;\n        }\n\n        // Initialize the module\n        this.state[namespace] = {};\n        this.actions[namespace] = {};\n\n        const namespaces = { [namespace]: module };\n        this._initializeNamespaces(namespaces);\n\n        this._saveState();\n      }\n\n      /**\n       * Unregisters a namespaced module.\n       * Logs a warning if the namespace doesn't exist.\n       * Removes both state and actions under the namespace.\n       * @param {string} namespace - The namespace to unregister.\n       * @returns {void}\n       */\n      unregisterModule(namespace) {\n        if (!this.state[namespace] && !this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" does not exist`);\n          return;\n        }\n\n        delete this.state[namespace];\n        delete this.actions[namespace];\n        this._saveState();\n      }\n\n      /**\n       * Creates a new reactive state property at runtime.\n       *\n       * @param {string} key - The state key.\n       * @param {*} initialValue - The initial value.\n       * @returns {Signal} The created signal, or existing signal if key exists.\n       */\n      createState(key, initialValue) {\n        if (this.state[key]) {\n          return this.state[key]; // Return existing state\n        }\n\n        this.state[key] = new eleva.signal(initialValue);\n        this._saveState();\n        return this.state[key];\n      }\n\n      /**\n       * Creates a new action at runtime.\n       * Overwrites existing action if name already exists.\n       * Supports dot-notation for namespaced actions (e.g., \"auth.login\").\n       * @param {string} name - The action name (supports dot notation for namespaces).\n       * @param {ActionFunction} actionFn - The action function (receives state and payload).\n       * @returns {void}\n       * @throws {Error} If actionFn is not a function.\n       * @example\n       * // Root-level action\n       * store.createAction(\"increment\", (state) => state.count.value++);\n       *\n       * // Namespaced action\n       * store.createAction(\"auth.login\", async (state, credentials) => {\n       *   // ... login logic\n       * });\n       */\n      createAction(name, actionFn) {\n        if (typeof actionFn !== \"function\") {\n          throw new Error(\"Action must be a function\");\n        }\n\n        // Fast path: no dot means simple action (avoids array allocation)\n        if (name.indexOf(\".\") === -1) {\n          this.actions[name] = actionFn;\n          return;\n        }\n\n        // Namespaced action, traverse/create nested structure\n        const parts = name.split(\".\");\n        const lastIndex = parts.length - 1;\n        let current = this.actions;\n\n        for (let i = 0; i < lastIndex; i++) {\n          current = current[parts[i]] || (current[parts[i]] = {});\n        }\n        current[parts[lastIndex]] = actionFn;\n      }\n    }\n\n    // Create the store instance\n    const store = new Store();\n\n    // Store the original mount method to override it\n    const originalMount = eleva.mount;\n\n    /**\n     * Overridden mount method that injects store context into components.\n     * Wraps the original mount to add `ctx.store` to the component's setup context.\n     *\n     * @param {HTMLElement} container - The DOM element where the component will be mounted.\n     * @param {string | ComponentDefinition} compName - Component name or definition.\n     * @param {ComponentProps} [props={}] - Optional properties to pass to the component.\n     * @returns {Promise<MountResult>} The mount result.\n     */\n    eleva.mount = async (container, compName, props = {}) => {\n      // Get the component definition\n      const componentDef =\n        typeof compName === \"string\"\n          ? eleva._components.get(compName) || compName\n          : compName;\n\n      if (!componentDef) {\n        return await originalMount.call(eleva, container, compName, props);\n      }\n\n      // Create a wrapped component that injects store into setup\n      const wrappedComponent = {\n        ...componentDef,\n        async setup(ctx) {\n          /** @type {StoreApi} */\n          ctx.store = {\n            // Core store functionality\n            state: store.state,\n            dispatch: store.dispatch.bind(store),\n            subscribe: store.subscribe.bind(store),\n            getState: store.getState.bind(store),\n\n            // Module management\n            registerModule: store.registerModule.bind(store),\n            unregisterModule: store.unregisterModule.bind(store),\n\n            // Utilities for dynamic state/action creation\n            createState: store.createState.bind(store),\n            createAction: store.createAction.bind(store),\n\n            // Access to signal constructor for manual state creation\n            signal: eleva.signal,\n          };\n\n          // Call original setup if it exists\n          const originalSetup = componentDef.setup;\n          const result = originalSetup ? await originalSetup(ctx) : {};\n\n          return result;\n        },\n      };\n\n      // Call original mount with wrapped component\n      return await originalMount.call(\n        eleva,\n        container,\n        wrappedComponent,\n        props\n      );\n    };\n\n    // Override _mountComponents to ensure child components also get store context\n    const originalMountComponents = eleva._mountComponents;\n\n    /**\n     * Overridden _mountComponents method that injects store context into child components.\n     * Wraps each child component's setup function to add `ctx.store` before mounting.\n     *\n     * @param {HTMLElement} container - The parent container element.\n     * @param {ChildrenMap} children - Map of selectors to component definitions.\n     * @param {MountResult[]} childInstances - Array to store mounted instances.\n     * @param {ComponentContext & SetupResult} context - Parent component context.\n     * @returns {Promise<void>}\n     */\n    eleva._mountComponents = async (\n      container,\n      children,\n      childInstances,\n      context\n    ) => {\n      // Create wrapped children with store injection\n      const wrappedChildren = {};\n\n      for (const [selector, childComponent] of Object.entries(children)) {\n        const componentDef =\n          typeof childComponent === \"string\"\n            ? eleva._components.get(childComponent) || childComponent\n            : childComponent;\n\n        if (componentDef && typeof componentDef === \"object\") {\n          wrappedChildren[selector] = {\n            ...componentDef,\n            async setup(ctx) {\n              /** @type {StoreApi} */\n              ctx.store = {\n                // Core store functionality\n                state: store.state,\n                dispatch: store.dispatch.bind(store),\n                subscribe: store.subscribe.bind(store),\n                getState: store.getState.bind(store),\n\n                // Module management\n                registerModule: store.registerModule.bind(store),\n                unregisterModule: store.unregisterModule.bind(store),\n\n                // Utilities for dynamic state/action creation\n                createState: store.createState.bind(store),\n                createAction: store.createAction.bind(store),\n\n                // Access to signal constructor for manual state creation\n                signal: eleva.signal,\n              };\n\n              // Call original setup if it exists\n              const originalSetup = componentDef.setup;\n              const result = originalSetup ? await originalSetup(ctx) : {};\n\n              return result;\n            },\n          };\n        } else {\n          wrappedChildren[selector] = childComponent;\n        }\n      }\n\n      // Call original _mountComponents with wrapped children\n      return await originalMountComponents.call(\n        eleva,\n        container,\n        wrappedChildren,\n        childInstances,\n        context\n      );\n    };\n\n    // Expose store instance and utilities on the Eleva instance\n    /** @type {StoreApi} */\n    eleva.store = store;\n\n    /**\n     * Expose utility methods on the Eleva instance.\n     * These are top-level helpers (e.g., `eleva.dispatch`) in addition to `eleva.store`.\n     */\n    /** @type {(name: string, actionFn: ActionFunction) => void} */\n    eleva.createAction = (name, actionFn) => {\n      store.createAction(name, actionFn);\n    };\n\n    /** @type {DispatchFunction} */\n    eleva.dispatch = (actionName, payload) => {\n      return store.dispatch(actionName, payload);\n    };\n\n    /** @type {() => Record<string, unknown>} */\n    eleva.getState = () => {\n      return store.getState();\n    };\n\n    /** @type {(callback: SubscribeCallback) => () => void} */\n    eleva.subscribe = (callback) => {\n      return store.subscribe(callback);\n    };\n\n    // Store original methods for cleanup\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance.\n   *\n   * @public\n   * @param {Eleva} eleva - The Eleva instance.\n   * @returns {void}\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   * Also removes `eleva.store` and top-level helpers (`eleva.dispatch`,\n   * `eleva.getState`, `eleva.subscribe`, `eleva.createAction`).\n   *\n   * @example\n   * // Uninstall the plugin\n   * StorePlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove store instance and utility methods\n    if (eleva.store) {\n      delete eleva.store;\n    }\n    if (eleva.createAction) {\n      delete eleva.createAction;\n    }\n    if (eleva.dispatch) {\n      delete eleva.dispatch;\n    }\n    if (eleva.getState) {\n      delete eleva.getState;\n    }\n    if (eleva.subscribe) {\n      delete eleva.subscribe;\n    }\n  },\n};\n\n// Short name export for convenience\nexport { StorePlugin as Store };\n"],"names":["StorePlugin","name","version","description","install","eleva","options","state","actions","namespaces","persistence","devTools","onError","store","_initializeState","initialState","initialActions","Object","entries","forEach","key","value","signal","_initializeNamespaces","namespace","module","moduleState","moduleActions","_loadPersistedState","enabled","window","persistedData","storage","getItem","data","JSON","parse","_applyPersistedData","error","currentState","path","fullPath","_shouldPersist","include","exclude","length","some","includePath","startsWith","excludePath","_saveState","dataToSave","_extractPersistedData","setItem","stringify","result","nestedData","keys","_setupDevTools","__ELEVA_DEVTOOLS__","registerStore","dispatch","actionName","payload","action","_getAction","Error","mutation","type","timestamp","Date","now","mutations","push","shift","call","subscribers","callback","notifyMutation","parts","split","current","part","undefined","subscribe","add","delete","getState","replaceState","newState","clearPersistedState","removeItem","registerModule","unregisterModule","createState","initialValue","createAction","actionFn","indexOf","lastIndex","i","Set","originalMount","mount","container","compName","props","componentDef","_components","get","wrappedComponent","setup","ctx","bind","originalSetup","originalMountComponents","_mountComponents","children","childInstances","context","wrappedChildren","selector","childComponent","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
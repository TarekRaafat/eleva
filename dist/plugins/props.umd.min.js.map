{"version":3,"file":"props.umd.min.js","sources":["../../src/modules/TemplateEngine.js","../../src/plugins/Props.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A secure template engine that handles interpolation and dynamic attribute parsing.\n * Provides a safe way to evaluate expressions in templates while preventing XSS attacks.\n * All methods are static and can be called directly on the class.\n *\n * @example\n * const template = \"Hello, {{name}}!\";\n * const data = { name: \"World\" };\n * const result = TemplateEngine.parse(template, data); // Returns: \"Hello, World!\"\n */\nexport class TemplateEngine {\n  /**\n   * @private {RegExp} Regular expression for matching template expressions in the format {{ expression }}\n   * @type {RegExp}\n   */\n  static expressionPattern = /\\{\\{\\s*(.*?)\\s*\\}\\}/g;\n\n  /**\n   * Parses a template string, replacing expressions with their evaluated values.\n   * Expressions are evaluated in the provided data context.\n   *\n   * @public\n   * @static\n   * @param {string} template - The template string to parse.\n   * @param {Record<string, unknown>} data - The data context for evaluating expressions.\n   * @returns {string} The parsed template with expressions replaced by their values.\n   * @example\n   * const result = TemplateEngine.parse(\"{{user.name}} is {{user.age}} years old\", {\n   *   user: { name: \"John\", age: 30 }\n   * }); // Returns: \"John is 30 years old\"\n   */\n  static parse(template, data) {\n    if (typeof template !== \"string\") return template;\n    return template.replace(this.expressionPattern, (_, expression) =>\n      this.evaluate(expression, data)\n    );\n  }\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   * The use of the `with` statement is necessary for expression evaluation but has security implications.\n   * Expressions should be carefully validated before evaluation.\n   *\n   * @public\n   * @static\n   * @param {string} expression - The expression to evaluate.\n   * @param {Record<string, unknown>} data - The data context for evaluation.\n   * @returns {unknown} The result of the evaluation, or an empty string if evaluation fails.\n   * @example\n   * const result = TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } }); // Returns: \"John\"\n   * const age = TemplateEngine.evaluate(\"user.age\", { user: { age: 30 } }); // Returns: 30\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    try {\n      return new Function(\"data\", `with(data) { return ${expression}; }`)(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\n\n/**\n * @class ðŸŽ¯ PropsPlugin\n * @classdesc A plugin that extends Eleva's props data handling to support any type of data structure\n * with automatic type detection, parsing, and reactive prop updates. This plugin enables seamless\n * passing of complex data types from parent to child components without manual parsing.\n *\n * Core Features:\n * - Automatic type detection and parsing (strings, numbers, booleans, objects, arrays, dates, etc.)\n * - Support for complex data structures including nested objects and arrays\n * - Reactive props that automatically update when parent data changes\n * - Comprehensive error handling with custom error callbacks\n * - Simple configuration with minimal setup required\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(PropsPlugin, {\n *   enableAutoParsing: true,\n *   enableReactivity: true,\n *   onError: (error, value) => {\n *     console.error('Props parsing error:', error, value);\n *   }\n * });\n *\n * // Use complex props in components\n * app.component(\"UserCard\", {\n *   template: (ctx) => `\n *     <div class=\"user-info-container\"\n *          :user='${JSON.stringify(ctx.user.value)}'\n *          :permissions='${JSON.stringify(ctx.permissions.value)}'\n *          :settings='${JSON.stringify(ctx.settings.value)}'>\n *     </div>\n *   `,\n *   children: {\n *     '.user-info-container': 'UserInfo'\n *   }\n * });\n *\n * app.component(\"UserInfo\", {\n *   setup({ props }) {\n *     return {\n *       user: props.user,        // Automatically parsed object\n *       permissions: props.permissions,  // Automatically parsed array\n *       settings: props.settings  // Automatically parsed object\n *     };\n *   }\n * });\n */\nexport const PropsPlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"props\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.0.0-rc.2\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description:\n    \"Advanced props data handling for complex data structures with automatic type detection and reactivity\",\n\n  /**\n   * Installs the plugin into the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   * @param {Object} options - Plugin configuration options\n   * @param {boolean} [options.enableAutoParsing=true] - Enable automatic type detection and parsing\n   * @param {boolean} [options.enableReactivity=true] - Enable reactive prop updates using Eleva's signal system\n   * @param {Function} [options.onError=null] - Error handler function called when parsing fails\n   *\n   * @example\n   * // Basic installation\n   * app.use(PropsPlugin);\n   *\n   * // Installation with custom options\n   * app.use(PropsPlugin, {\n   *   enableAutoParsing: true,\n   *   enableReactivity: false,\n   *   onError: (error, value) => {\n   *     console.error('Props parsing error:', error, value);\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      enableAutoParsing = true,\n      enableReactivity = true,\n      onError = null,\n    } = options;\n\n    /**\n     * Detects the type of a given value\n     * @private\n     * @param {any} value - The value to detect type for\n     * @returns {string} The detected type ('string', 'number', 'boolean', 'object', 'array', 'date', 'map', 'set', 'function', 'null', 'undefined', 'unknown')\n     *\n     * @example\n     * detectType(\"hello\")     // â†’ \"string\"\n     * detectType(42)          // â†’ \"number\"\n     * detectType(true)        // â†’ \"boolean\"\n     * detectType([1, 2, 3])   // â†’ \"array\"\n     * detectType({})          // â†’ \"object\"\n     * detectType(new Date())  // â†’ \"date\"\n     * detectType(null)        // â†’ \"null\"\n     */\n    const detectType = (value) => {\n      if (value === null) return \"null\";\n      if (value === undefined) return \"undefined\";\n      if (typeof value === \"boolean\") return \"boolean\";\n      if (typeof value === \"number\") return \"number\";\n      if (typeof value === \"string\") return \"string\";\n      if (typeof value === \"function\") return \"function\";\n      if (value instanceof Date) return \"date\";\n      if (value instanceof Map) return \"map\";\n      if (value instanceof Set) return \"set\";\n      if (Array.isArray(value)) return \"array\";\n      if (typeof value === \"object\") return \"object\";\n      return \"unknown\";\n    };\n\n    /**\n     * Parses a prop value with automatic type detection\n     * @private\n     * @param {any} value - The value to parse\n     * @returns {any} The parsed value with appropriate type\n     *\n     * @description\n     * This function automatically detects and parses different data types from string values:\n     * - Special strings: \"true\" â†’ true, \"false\" â†’ false, \"null\" â†’ null, \"undefined\" â†’ undefined\n     * - JSON objects/arrays: '{\"key\": \"value\"}' â†’ {key: \"value\"}, '[1, 2, 3]' â†’ [1, 2, 3]\n     * - Boolean-like strings: \"1\" â†’ true, \"0\" â†’ false, \"\" â†’ true\n     * - Numeric strings: \"42\" â†’ 42, \"3.14\" â†’ 3.14\n     * - Date strings: \"2023-01-01T00:00:00.000Z\" â†’ Date object\n     * - Other strings: returned as-is\n     *\n     * @example\n     * parsePropValue(\"true\")           // â†’ true\n     * parsePropValue(\"42\")             // â†’ 42\n     * parsePropValue('{\"key\": \"val\"}') // â†’ {key: \"val\"}\n     * parsePropValue('[1, 2, 3]')      // â†’ [1, 2, 3]\n     * parsePropValue(\"hello\")          // â†’ \"hello\"\n     */\n    const parsePropValue = (value) => {\n      try {\n        // Handle non-string values - return as-is\n        if (typeof value !== \"string\") {\n          return value;\n        }\n\n        // Handle special string patterns first\n        if (value === \"true\") return true;\n        if (value === \"false\") return false;\n        if (value === \"null\") return null;\n        if (value === \"undefined\") return undefined;\n\n        // Try to parse as JSON (for objects and arrays)\n        // This handles complex data structures like objects and arrays\n        if (value.startsWith(\"{\") || value.startsWith(\"[\")) {\n          try {\n            return JSON.parse(value);\n          } catch (e) {\n            // Not valid JSON, throw error to trigger error handler\n            throw new Error(`Invalid JSON: ${value}`);\n          }\n        }\n\n        // Handle boolean-like strings (including \"1\" and \"0\")\n        // These are common in HTML attributes and should be treated as booleans\n        if (value === \"1\") return true;\n        if (value === \"0\") return false;\n        if (value === \"\") return true; // Empty string is truthy in HTML attributes\n\n        // Handle numeric strings (after boolean check to avoid conflicts)\n        // This ensures \"0\" is treated as boolean false, not number 0\n        if (!isNaN(value) && value !== \"\" && !isNaN(parseFloat(value))) {\n          return Number(value);\n        }\n\n        // Handle date strings (ISO format)\n        // Recognizes standard ISO date format and converts to Date object\n        if (value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/)) {\n          const date = new Date(value);\n          if (!isNaN(date.getTime())) {\n            return date;\n          }\n        }\n\n        // Return as string if no other parsing applies\n        // This is the fallback for regular text strings\n        return value;\n      } catch (error) {\n        // Call error handler if provided\n        if (onError) {\n          onError(error, value);\n        }\n        // Fallback to original value to prevent breaking the application\n        return value;\n      }\n    };\n\n    /**\n     * Enhanced props extraction with automatic type detection\n     * @private\n     * @param {HTMLElement} element - The DOM element to extract props from\n     * @returns {Object} Object containing parsed props with appropriate types\n     *\n     * @description\n     * Extracts props from DOM element attributes that start with \":\" and automatically\n     * parses them to their appropriate types. Removes the attributes from the element\n     * after extraction.\n     *\n     * @example\n     * // HTML: <div :name=\"John\" :age=\"30\" :active=\"true\" :data='{\"key\": \"value\"}'></div>\n     * const props = extractProps(element);\n     * // Result: { name: \"John\", age: 30, active: true, data: {key: \"value\"} }\n     */\n    const extractProps = (element) => {\n      const props = {};\n      const attrs = element.attributes;\n\n      // Iterate through attributes in reverse order to handle removal correctly\n      for (let i = attrs.length - 1; i >= 0; i--) {\n        const attr = attrs[i];\n        // Only process attributes that start with \":\" (prop attributes)\n        if (attr.name.startsWith(\":\")) {\n          const propName = attr.name.slice(1); // Remove the \":\" prefix\n          // Parse the value if auto-parsing is enabled, otherwise use as-is\n          const parsedValue = enableAutoParsing\n            ? parsePropValue(attr.value)\n            : attr.value;\n          props[propName] = parsedValue;\n          // Remove the attribute from the DOM element after extraction\n          element.removeAttribute(attr.name);\n        }\n      }\n\n      return props;\n    };\n\n    /**\n     * Creates reactive props using Eleva's signal system\n     * @private\n     * @param {Object} props - The props object to make reactive\n     * @returns {Object} Object containing reactive props (Eleva signals)\n     *\n     * @description\n     * Converts regular prop values into Eleva signals for reactive updates.\n     * If a value is already a signal, it's passed through unchanged.\n     *\n     * @example\n     * const props = { name: \"John\", age: 30, active: true };\n     * const reactiveProps = createReactiveProps(props);\n     * // Result: {\n     * //   name: Signal(\"John\"),\n     * //   age: Signal(30),\n     * //   active: Signal(true)\n     * // }\n     */\n    const createReactiveProps = (props) => {\n      const reactiveProps = {};\n\n      // Convert each prop value to a reactive signal\n      Object.entries(props).forEach(([key, value]) => {\n        // Check if value is already a signal (has 'value' and 'watch' properties)\n        if (\n          value &&\n          typeof value === \"object\" &&\n          \"value\" in value &&\n          \"watch\" in value\n        ) {\n          // Value is already a signal, use it as-is\n          reactiveProps[key] = value;\n        } else {\n          // Create new signal for the prop value to make it reactive\n          reactiveProps[key] = new eleva.signal(value);\n        }\n      });\n\n      return reactiveProps;\n    };\n\n    // Override Eleva's internal _extractProps method with our enhanced version\n    eleva._extractProps = extractProps;\n\n    // Override Eleva's mount method to apply enhanced prop handling\n    const originalMount = eleva.mount;\n    eleva.mount = async (container, compName, props = {}) => {\n      // Create reactive props if reactivity is enabled\n      const enhancedProps = enableReactivity\n        ? createReactiveProps(props)\n        : props;\n\n      // Call the original mount method with enhanced props\n      return await originalMount.call(\n        eleva,\n        container,\n        compName,\n        enhancedProps\n      );\n    };\n\n    // Override Eleva's _mountComponents method to enable signal reference passing\n    const originalMountComponents = eleva._mountComponents;\n\n    // Cache to store parent contexts by container element\n    const parentContextCache = new WeakMap();\n    // Store child instances that need signal linking\n    const pendingSignalLinks = new Set();\n\n    eleva._mountComponents = async (container, children, childInstances) => {\n      for (const [selector, component] of Object.entries(children)) {\n        if (!selector) continue;\n        for (const el of container.querySelectorAll(selector)) {\n          if (!(el instanceof HTMLElement)) continue;\n\n          // Extract props from DOM attributes\n          const extractedProps = eleva._extractProps(el);\n\n          // Get parent context to check for signal references\n          let enhancedProps = extractedProps;\n\n          // Try to find parent context by looking up the DOM tree\n          let parentContext = parentContextCache.get(container);\n          if (!parentContext) {\n            let currentElement = container;\n            while (currentElement && !parentContext) {\n              if (\n                currentElement._eleva_instance &&\n                currentElement._eleva_instance.data\n              ) {\n                parentContext = currentElement._eleva_instance.data;\n                // Cache the parent context for future use\n                parentContextCache.set(container, parentContext);\n                break;\n              }\n              currentElement = currentElement.parentElement;\n            }\n          }\n\n          if (enableReactivity && parentContext) {\n            const signalProps = {};\n\n            // Check each extracted prop to see if there's a matching signal in parent context\n            Object.keys(extractedProps).forEach((propName) => {\n              if (\n                parentContext[propName] &&\n                parentContext[propName] instanceof eleva.signal\n              ) {\n                // Found a signal in parent context with the same name as the prop\n                // Pass the signal reference instead of creating a new one\n                signalProps[propName] = parentContext[propName];\n              }\n            });\n\n            // Merge signal props with regular props (signal props take precedence)\n            enhancedProps = {\n              ...extractedProps,\n              ...signalProps,\n            };\n          }\n\n          // Create reactive props for non-signal props only\n          let finalProps = enhancedProps;\n          if (enableReactivity) {\n            // Only create reactive props for values that aren't already signals\n            const nonSignalProps = {};\n            Object.entries(enhancedProps).forEach(([key, value]) => {\n              if (\n                !(\n                  value &&\n                  typeof value === \"object\" &&\n                  \"value\" in value &&\n                  \"watch\" in value\n                )\n              ) {\n                // This is not a signal, create a reactive prop for it\n                nonSignalProps[key] = value;\n              }\n            });\n\n            // Create reactive props only for non-signal values\n            const reactiveNonSignalProps = createReactiveProps(nonSignalProps);\n\n            // Merge signal props with reactive non-signal props\n            finalProps = {\n              ...reactiveNonSignalProps,\n              ...enhancedProps, // Signal props take precedence\n            };\n          }\n\n          /** @type {MountResult} */\n          const instance = await eleva.mount(el, component, finalProps);\n          if (instance && !childInstances.includes(instance)) {\n            childInstances.push(instance);\n\n            // If we have extracted props but no parent context yet, mark for later signal linking\n            if (\n              enableReactivity &&\n              Object.keys(extractedProps).length > 0 &&\n              !parentContext\n            ) {\n              pendingSignalLinks.add({\n                instance,\n                extractedProps,\n                container,\n                component,\n              });\n            }\n          }\n        }\n      }\n\n      // After mounting all children, try to link signals for pending instances\n      if (enableReactivity && pendingSignalLinks.size > 0) {\n        for (const pending of pendingSignalLinks) {\n          const { instance, extractedProps, container, component } = pending;\n\n          // Try to find parent context again\n          let parentContext = parentContextCache.get(container);\n          if (!parentContext) {\n            let currentElement = container;\n            while (currentElement && !parentContext) {\n              if (\n                currentElement._eleva_instance &&\n                currentElement._eleva_instance.data\n              ) {\n                parentContext = currentElement._eleva_instance.data;\n                parentContextCache.set(container, parentContext);\n                break;\n              }\n              currentElement = currentElement.parentElement;\n            }\n          }\n\n          if (parentContext) {\n            const signalProps = {};\n\n            // Check each extracted prop to see if there's a matching signal in parent context\n            Object.keys(extractedProps).forEach((propName) => {\n              if (\n                parentContext[propName] &&\n                parentContext[propName] instanceof eleva.signal\n              ) {\n                signalProps[propName] = parentContext[propName];\n              }\n            });\n\n            // Update the child instance's data with signal references\n            if (Object.keys(signalProps).length > 0) {\n              Object.assign(instance.data, signalProps);\n\n              // Set up signal watchers for the newly linked signals\n              Object.keys(signalProps).forEach((propName) => {\n                const signal = signalProps[propName];\n                if (signal && typeof signal.watch === \"function\") {\n                  signal.watch((newValue) => {\n                    // Trigger a re-render of the child component when the signal changes\n                    const childComponent =\n                      eleva._components.get(component) || component;\n                    if (childComponent && childComponent.template) {\n                      const templateResult =\n                        typeof childComponent.template === \"function\"\n                          ? childComponent.template(instance.data)\n                          : childComponent.template;\n                      const newHtml = TemplateEngine.parse(\n                        templateResult,\n                        instance.data\n                      );\n                      eleva.renderer.patchDOM(instance.container, newHtml);\n                    }\n                  });\n                }\n              });\n\n              // Initial re-render to show the correct signal values\n              const childComponent =\n                eleva._components.get(component) || component;\n              if (childComponent && childComponent.template) {\n                const templateResult =\n                  typeof childComponent.template === \"function\"\n                    ? childComponent.template(instance.data)\n                    : childComponent.template;\n                const newHtml = TemplateEngine.parse(\n                  templateResult,\n                  instance.data\n                );\n                eleva.renderer.patchDOM(instance.container, newHtml);\n              }\n            }\n\n            // Remove from pending list\n            pendingSignalLinks.delete(pending);\n          }\n        }\n      }\n    };\n\n    /**\n     * Expose utility methods on the Eleva instance\n     * @namespace eleva.props\n     */\n    eleva.props = {\n      /**\n       * Parse a single value with automatic type detection\n       * @param {any} value - The value to parse\n       * @returns {any} The parsed value with appropriate type\n       *\n       * @example\n       * app.props.parse(\"42\")             // â†’ 42\n       * app.props.parse(\"true\")           // â†’ true\n       * app.props.parse('{\"key\": \"val\"}') // â†’ {key: \"val\"}\n       */\n      parse: (value) => {\n        // Return value as-is if auto parsing is disabled\n        if (!enableAutoParsing) {\n          return value;\n        }\n        // Use our enhanced parsing function\n        return parsePropValue(value);\n      },\n\n      /**\n       * Detect the type of a value\n       * @param {any} value - The value to detect type for\n       * @returns {string} The detected type\n       *\n       * @example\n       * app.props.detectType(\"hello\")     // â†’ \"string\"\n       * app.props.detectType(42)          // â†’ \"number\"\n       * app.props.detectType([1, 2, 3])   // â†’ \"array\"\n       */\n      detectType,\n    };\n\n    // Store original methods for uninstall\n    eleva._originalExtractProps = eleva._extractProps;\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   *\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   *\n   * @example\n   * // Uninstall the plugin\n   * PropsPlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original _extractProps method\n    if (eleva._originalExtractProps) {\n      eleva._extractProps = eleva._originalExtractProps;\n      delete eleva._originalExtractProps;\n    }\n\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove plugin utility methods\n    if (eleva.props) {\n      delete eleva.props;\n    }\n  },\n};\n"],"names":["TemplateEngine","static","parse","template","data","replace","this","expressionPattern","_","expression","evaluate","Function","name","version","description","install","eleva","options","enableAutoParsing","enableReactivity","onError","parsePropValue","value","startsWith","JSON","e","Error","isNaN","parseFloat","Number","match","date","Date","getTime","error","createReactiveProps","props","reactiveProps","Object","entries","forEach","key","signal","_extractProps","element","attrs","attributes","i","length","attr","propName","slice","parsedValue","removeAttribute","originalMount","mount","async","container","compName","enhancedProps","call","originalMountComponents","_mountComponents","parentContextCache","WeakMap","pendingSignalLinks","Set","children","childInstances","selector","component","el","querySelectorAll","HTMLElement","extractedProps","parentContext","get","currentElement","_eleva_instance","set","parentElement","signalProps","keys","finalProps","nonSignalProps","instance","includes","push","add","size","pending","assign","watch","newValue","childComponent","_components","templateResult","newHtml","renderer","patchDOM","delete","detectType","undefined","Map","Array","isArray","_originalExtractProps","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
{"version":3,"file":"store.umd.min.js","sources":["../../src/plugins/Store.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸª StorePlugin\n * @classdesc A powerful reactive state management plugin for Eleva.js that enables sharing\n * reactive data across the entire application. The Store plugin provides a centralized,\n * reactive data store that can be accessed from any component's setup function.\n *\n * Core Features:\n * - Centralized reactive state management using Eleva's signal system\n * - Global state accessibility through component setup functions\n * - Namespace support for organizing store modules\n * - Built-in persistence with localStorage/sessionStorage support\n * - Action-based state mutations with validation\n * - Subscription system for reactive updates\n * - DevTools integration for debugging\n * - Plugin architecture for extensibility\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(StorePlugin, {\n *   state: {\n *     user: { name: \"John\", email: \"john@example.com\" },\n *     counter: 0,\n *     todos: []\n *   },\n *   actions: {\n *     increment: (state) => state.counter.value++,\n *     addTodo: (state, todo) => state.todos.value.push(todo),\n *     setUser: (state, user) => state.user.value = user\n *   },\n *   persistence: {\n *     enabled: true,\n *     key: \"myApp-store\",\n *     storage: \"localStorage\"\n *   }\n * });\n *\n * // Use store in components\n * app.component(\"Counter\", {\n *   setup({ store }) {\n *     return {\n *       count: store.state.counter,\n *       increment: () => store.dispatch(\"increment\"),\n *       user: store.state.user\n *     };\n *   },\n *   template: (ctx) => `\n *     <div>\n *       <p>Hello ${ctx.user.value.name}!</p>\n *       <p>Count: ${ctx.count.value}</p>\n *       <button onclick=\"ctx.increment()\">+</button>\n *     </div>\n *   `\n * });\n */\nexport const StorePlugin = {\n  /**\n   * Unique identifier for the plugin\n   * @type {string}\n   */\n  name: \"store\",\n\n  /**\n   * Plugin version\n   * @type {string}\n   */\n  version: \"1.0.0-rc.1\",\n\n  /**\n   * Plugin description\n   * @type {string}\n   */\n  description:\n    \"Reactive state management for sharing data across the entire Eleva application\",\n\n  /**\n   * Installs the plugin into the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   * @param {Object} options - Plugin configuration options\n   * @param {Object} [options.state={}] - Initial state object\n   * @param {Object} [options.actions={}] - Action functions for state mutations\n   * @param {Object} [options.namespaces={}] - Namespaced modules for organizing store\n   * @param {Object} [options.persistence] - Persistence configuration\n   * @param {boolean} [options.persistence.enabled=false] - Enable state persistence\n   * @param {string} [options.persistence.key=\"eleva-store\"] - Storage key\n   * @param {\"localStorage\" | \"sessionStorage\"} [options.persistence.storage=\"localStorage\"] - Storage type\n   * @param {Array<string>} [options.persistence.include] - State keys to persist (if not provided, all state is persisted)\n   * @param {Array<string>} [options.persistence.exclude] - State keys to exclude from persistence\n   * @param {boolean} [options.devTools=false] - Enable development tools integration\n   * @param {Function} [options.onError=null] - Error handler function\n   *\n   * @example\n   * // Basic installation\n   * app.use(StorePlugin, {\n   *   state: { count: 0, user: null },\n   *   actions: {\n   *     increment: (state) => state.count.value++,\n   *     setUser: (state, user) => state.user.value = user\n   *   }\n   * });\n   *\n   * // Advanced installation with persistence and namespaces\n   * app.use(StorePlugin, {\n   *   state: { theme: \"light\" },\n   *   namespaces: {\n   *     auth: {\n   *       state: { user: null, token: null },\n   *       actions: {\n   *         login: (state, { user, token }) => {\n   *           state.user.value = user;\n   *           state.token.value = token;\n   *         },\n   *         logout: (state) => {\n   *           state.user.value = null;\n   *           state.token.value = null;\n   *         }\n   *       }\n   *     }\n   *   },\n   *   persistence: {\n   *     enabled: true,\n   *     include: [\"theme\", \"auth.user\"]\n   *   }\n   * });\n   */\n  install(eleva, options = {}) {\n    const {\n      state = {},\n      actions = {},\n      namespaces = {},\n      persistence = {},\n      devTools = false,\n      onError = null,\n    } = options;\n\n    /**\n     * Store instance that manages all state and provides the API\n     * @private\n     */\n    class Store {\n      constructor() {\n        this.state = {};\n        this.actions = {};\n        this.subscribers = new Set();\n        this.mutations = [];\n        this.persistence = {\n          enabled: false,\n          key: \"eleva-store\",\n          storage: \"localStorage\",\n          include: null,\n          exclude: null,\n          ...persistence,\n        };\n        this.devTools = devTools;\n        this.onError = onError;\n\n        this._initializeState(state, actions);\n        this._initializeNamespaces(namespaces);\n        this._loadPersistedState();\n        this._setupDevTools();\n      }\n\n      /**\n       * Initializes the root state and actions\n       * @private\n       */\n      _initializeState(initialState, initialActions) {\n        // Create reactive signals for each state property\n        Object.entries(initialState).forEach(([key, value]) => {\n          this.state[key] = new eleva.signal(value);\n        });\n\n        // Set up actions\n        this.actions = { ...initialActions };\n      }\n\n      /**\n       * Initializes namespaced modules\n       * @private\n       */\n      _initializeNamespaces(namespaces) {\n        Object.entries(namespaces).forEach(([namespace, module]) => {\n          const { state: moduleState = {}, actions: moduleActions = {} } =\n            module;\n\n          // Create namespace object if it doesn't exist\n          if (!this.state[namespace]) {\n            this.state[namespace] = {};\n          }\n          if (!this.actions[namespace]) {\n            this.actions[namespace] = {};\n          }\n\n          // Initialize namespaced state\n          Object.entries(moduleState).forEach(([key, value]) => {\n            this.state[namespace][key] = new eleva.signal(value);\n          });\n\n          // Set up namespaced actions\n          this.actions[namespace] = { ...moduleActions };\n        });\n      }\n\n      /**\n       * Loads persisted state from storage\n       * @private\n       */\n      _loadPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const persistedData = storage.getItem(this.persistence.key);\n\n          if (persistedData) {\n            const data = JSON.parse(persistedData);\n            this._applyPersistedData(data);\n          }\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to load persisted state\");\n          } else {\n            console.warn(\n              \"[StorePlugin] Failed to load persisted state:\",\n              error\n            );\n          }\n        }\n      }\n\n      /**\n       * Applies persisted data to the current state\n       * @private\n       */\n      _applyPersistedData(data, currentState = this.state, path = \"\") {\n        Object.entries(data).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (\n              currentState[key] &&\n              typeof currentState[key] === \"object\" &&\n              \"value\" in currentState[key]\n            ) {\n              // This is a signal, update its value\n              currentState[key].value = value;\n            } else if (\n              typeof value === \"object\" &&\n              value !== null &&\n              currentState[key]\n            ) {\n              // This is a nested object, recurse\n              this._applyPersistedData(value, currentState[key], fullPath);\n            }\n          }\n        });\n      }\n\n      /**\n       * Determines if a state path should be persisted\n       * @private\n       */\n      _shouldPersist(path) {\n        const { include, exclude } = this.persistence;\n\n        if (include && include.length > 0) {\n          return include.some((includePath) => path.startsWith(includePath));\n        }\n\n        if (exclude && exclude.length > 0) {\n          return !exclude.some((excludePath) => path.startsWith(excludePath));\n        }\n\n        return true;\n      }\n\n      /**\n       * Saves current state to storage\n       * @private\n       */\n      _saveState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          const dataToSave = this._extractPersistedData();\n          storage.setItem(this.persistence.key, JSON.stringify(dataToSave));\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to save state\");\n          } else {\n            console.warn(\"[StorePlugin] Failed to save state:\", error);\n          }\n        }\n      }\n\n      /**\n       * Extracts data that should be persisted\n       * @private\n       */\n      _extractPersistedData(currentState = this.state, path = \"\") {\n        const result = {};\n\n        Object.entries(currentState).forEach(([key, value]) => {\n          const fullPath = path ? `${path}.${key}` : key;\n\n          if (this._shouldPersist(fullPath)) {\n            if (value && typeof value === \"object\" && \"value\" in value) {\n              // This is a signal, extract its value\n              result[key] = value.value;\n            } else if (typeof value === \"object\" && value !== null) {\n              // This is a nested object, recurse\n              const nestedData = this._extractPersistedData(value, fullPath);\n              if (Object.keys(nestedData).length > 0) {\n                result[key] = nestedData;\n              }\n            }\n          }\n        });\n\n        return result;\n      }\n\n      /**\n       * Sets up development tools integration\n       * @private\n       */\n      _setupDevTools() {\n        if (\n          !this.devTools ||\n          typeof window === \"undefined\" ||\n          !window.__ELEVA_DEVTOOLS__\n        ) {\n          return;\n        }\n\n        window.__ELEVA_DEVTOOLS__.registerStore(this);\n      }\n\n      /**\n       * Dispatches an action to mutate the state\n       * @param {string} actionName - The name of the action to dispatch (supports namespaced actions like \"auth.login\")\n       * @param {any} payload - The payload to pass to the action\n       * @returns {Promise<any>} The result of the action\n       */\n      async dispatch(actionName, payload) {\n        try {\n          const action = this._getAction(actionName);\n\n          if (!action) {\n            const error = new Error(`Action \"${actionName}\" not found`);\n            if (this.onError) {\n              this.onError(error, actionName);\n            }\n            throw error;\n          }\n\n          const mutation = {\n            type: actionName,\n            payload,\n            timestamp: Date.now(),\n          };\n\n          // Record mutation for devtools\n          this.mutations.push(mutation);\n          if (this.mutations.length > 100) {\n            this.mutations.shift(); // Keep only last 100 mutations\n          }\n\n          // Execute the action\n          const result = await action.call(null, this.state, payload);\n\n          // Save state if persistence is enabled\n          this._saveState();\n\n          // Notify subscribers\n          this.subscribers.forEach((callback) => {\n            try {\n              callback(mutation, this.state);\n            } catch (error) {\n              if (this.onError) {\n                this.onError(error, \"Subscriber callback failed\");\n              }\n            }\n          });\n\n          // Notify devtools\n          if (\n            this.devTools &&\n            typeof window !== \"undefined\" &&\n            window.__ELEVA_DEVTOOLS__\n          ) {\n            window.__ELEVA_DEVTOOLS__.notifyMutation(mutation, this.state);\n          }\n\n          return result;\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, `Action dispatch failed: ${actionName}`);\n          }\n          throw error;\n        }\n      }\n\n      /**\n       * Gets an action by name (supports namespaced actions)\n       * @private\n       */\n      _getAction(actionName) {\n        const parts = actionName.split(\".\");\n        let current = this.actions;\n\n        for (const part of parts) {\n          if (current[part] === undefined) {\n            return null;\n          }\n          current = current[part];\n        }\n\n        return typeof current === \"function\" ? current : null;\n      }\n\n      /**\n       * Subscribes to store mutations\n       * @param {Function} callback - Callback function to call on mutations\n       * @returns {Function} Unsubscribe function\n       */\n      subscribe(callback) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Subscribe callback must be a function\");\n        }\n\n        this.subscribers.add(callback);\n\n        // Return unsubscribe function\n        return () => {\n          this.subscribers.delete(callback);\n        };\n      }\n\n      /**\n       * Gets a deep copy of the current state values (not signals)\n       * @returns {Object} The current state values\n       */\n      getState() {\n        return this._extractPersistedData();\n      }\n\n      /**\n       * Replaces the entire state (useful for testing or state hydration)\n       * @param {Object} newState - The new state object\n       */\n      replaceState(newState) {\n        this._applyPersistedData(newState);\n        this._saveState();\n      }\n\n      /**\n       * Clears persisted state from storage\n       */\n      clearPersistedState() {\n        if (!this.persistence.enabled || typeof window === \"undefined\") {\n          return;\n        }\n\n        try {\n          const storage = window[this.persistence.storage];\n          storage.removeItem(this.persistence.key);\n        } catch (error) {\n          if (this.onError) {\n            this.onError(error, \"Failed to clear persisted state\");\n          }\n        }\n      }\n\n      /**\n       * Registers a new namespaced module at runtime\n       * @param {string} namespace - The namespace for the module\n       * @param {Object} module - The module definition\n       * @param {Object} module.state - The module's initial state\n       * @param {Object} module.actions - The module's actions\n       */\n      registerModule(namespace, module) {\n        if (this.state[namespace] || this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" already exists`);\n          return;\n        }\n\n        // Initialize the module\n        this.state[namespace] = {};\n        this.actions[namespace] = {};\n\n        const namespaces = { [namespace]: module };\n        this._initializeNamespaces(namespaces);\n\n        this._saveState();\n      }\n\n      /**\n       * Unregisters a namespaced module\n       * @param {string} namespace - The namespace to unregister\n       */\n      unregisterModule(namespace) {\n        if (!this.state[namespace] && !this.actions[namespace]) {\n          console.warn(`[StorePlugin] Module \"${namespace}\" does not exist`);\n          return;\n        }\n\n        delete this.state[namespace];\n        delete this.actions[namespace];\n        this._saveState();\n      }\n\n      /**\n       * Creates a new reactive state property at runtime\n       * @param {string} key - The state key\n       * @param {*} initialValue - The initial value\n       * @returns {Object} The created signal\n       */\n      createState(key, initialValue) {\n        if (this.state[key]) {\n          return this.state[key]; // Return existing state\n        }\n\n        this.state[key] = new eleva.signal(initialValue);\n        this._saveState();\n        return this.state[key];\n      }\n\n      /**\n       * Creates a new action at runtime\n       * @param {string} name - The action name\n       * @param {Function} actionFn - The action function\n       */\n      createAction(name, actionFn) {\n        if (typeof actionFn !== \"function\") {\n          throw new Error(\"Action must be a function\");\n        }\n\n        this.actions[name] = actionFn;\n      }\n    }\n\n    // Create the store instance\n    const store = new Store();\n\n    // Store the original mount method to override it\n    const originalMount = eleva.mount;\n\n    /**\n     * Override the mount method to inject store context into components\n     */\n    eleva.mount = async (container, compName, props = {}) => {\n      // Get the component definition\n      const componentDef =\n        typeof compName === \"string\"\n          ? eleva._components.get(compName) || compName\n          : compName;\n\n      if (!componentDef) {\n        return await originalMount.call(eleva, container, compName, props);\n      }\n\n      // Create a wrapped component that injects store into setup\n      const wrappedComponent = {\n        ...componentDef,\n        async setup(ctx) {\n          // Inject store into the context with enhanced API\n          ctx.store = {\n            // Core store functionality\n            state: store.state,\n            dispatch: store.dispatch.bind(store),\n            subscribe: store.subscribe.bind(store),\n            getState: store.getState.bind(store),\n\n            // Module management\n            registerModule: store.registerModule.bind(store),\n            unregisterModule: store.unregisterModule.bind(store),\n\n            // Utilities for dynamic state/action creation\n            createState: store.createState.bind(store),\n            createAction: store.createAction.bind(store),\n\n            // Access to signal constructor for manual state creation\n            signal: eleva.signal,\n          };\n\n          // Call original setup if it exists\n          const originalSetup = componentDef.setup;\n          const result = originalSetup ? await originalSetup(ctx) : {};\n\n          return result;\n        },\n      };\n\n      // Call original mount with wrapped component\n      return await originalMount.call(\n        eleva,\n        container,\n        wrappedComponent,\n        props\n      );\n    };\n\n    // Override _mountComponents to ensure child components also get store context\n    const originalMountComponents = eleva._mountComponents;\n    eleva._mountComponents = async (container, children, childInstances) => {\n      // Create wrapped children with store injection\n      const wrappedChildren = {};\n\n      for (const [selector, childComponent] of Object.entries(children)) {\n        const componentDef =\n          typeof childComponent === \"string\"\n            ? eleva._components.get(childComponent) || childComponent\n            : childComponent;\n\n        if (componentDef && typeof componentDef === \"object\") {\n          wrappedChildren[selector] = {\n            ...componentDef,\n            async setup(ctx) {\n              // Inject store into the context with enhanced API\n              ctx.store = {\n                // Core store functionality\n                state: store.state,\n                dispatch: store.dispatch.bind(store),\n                subscribe: store.subscribe.bind(store),\n                getState: store.getState.bind(store),\n\n                // Module management\n                registerModule: store.registerModule.bind(store),\n                unregisterModule: store.unregisterModule.bind(store),\n\n                // Utilities for dynamic state/action creation\n                createState: store.createState.bind(store),\n                createAction: store.createAction.bind(store),\n\n                // Access to signal constructor for manual state creation\n                signal: eleva.signal,\n              };\n\n              // Call original setup if it exists\n              const originalSetup = componentDef.setup;\n              const result = originalSetup ? await originalSetup(ctx) : {};\n\n              return result;\n            },\n          };\n        } else {\n          wrappedChildren[selector] = childComponent;\n        }\n      }\n\n      // Call original _mountComponents with wrapped children\n      return await originalMountComponents.call(\n        eleva,\n        container,\n        wrappedChildren,\n        childInstances\n      );\n    };\n\n    // Expose store instance and utilities on the Eleva instance\n    eleva.store = store;\n\n    /**\n     * Expose utility methods on the Eleva instance\n     * @namespace eleva.store\n     */\n    eleva.createAction = (name, actionFn) => {\n      store.actions[name] = actionFn;\n    };\n\n    eleva.dispatch = (actionName, payload) => {\n      return store.dispatch(actionName, payload);\n    };\n\n    eleva.getState = () => {\n      return store.getState();\n    };\n\n    eleva.subscribe = (callback) => {\n      return store.subscribe(callback);\n    };\n\n    // Store original methods for cleanup\n    eleva._originalMount = originalMount;\n    eleva._originalMountComponents = originalMountComponents;\n  },\n\n  /**\n   * Uninstalls the plugin from the Eleva instance\n   *\n   * @param {Object} eleva - The Eleva instance\n   *\n   * @description\n   * Restores the original Eleva methods and removes all plugin-specific\n   * functionality. This method should be called when the plugin is no\n   * longer needed.\n   *\n   * @example\n   * // Uninstall the plugin\n   * StorePlugin.uninstall(app);\n   */\n  uninstall(eleva) {\n    // Restore original mount method\n    if (eleva._originalMount) {\n      eleva.mount = eleva._originalMount;\n      delete eleva._originalMount;\n    }\n\n    // Restore original _mountComponents method\n    if (eleva._originalMountComponents) {\n      eleva._mountComponents = eleva._originalMountComponents;\n      delete eleva._originalMountComponents;\n    }\n\n    // Remove store instance and utility methods\n    if (eleva.store) {\n      delete eleva.store;\n    }\n    if (eleva.createAction) {\n      delete eleva.createAction;\n    }\n    if (eleva.dispatch) {\n      delete eleva.dispatch;\n    }\n    if (eleva.getState) {\n      delete eleva.getState;\n    }\n    if (eleva.subscribe) {\n      delete eleva.subscribe;\n    }\n  },\n};\n"],"names":["name","version","description","install","eleva","options","state","actions","namespaces","persistence","devTools","onError","store","constructor","this","subscribers","Set","mutations","_extends","enabled","key","storage","include","exclude","_initializeState","_initializeNamespaces","_loadPersistedState","_setupDevTools","initialState","initialActions","Object","entries","forEach","value","signal","namespace","module","moduleState","moduleActions","window","persistedData","getItem","data","JSON","parse","_applyPersistedData","error","currentState","path","fullPath","_shouldPersist","length","some","includePath","startsWith","excludePath","_saveState","dataToSave","_extractPersistedData","setItem","stringify","result","nestedData","keys","__ELEVA_DEVTOOLS__","registerStore","dispatch","actionName","payload","action","_getAction","Error","mutation","type","timestamp","Date","now","push","shift","call","callback","notifyMutation","parts","split","current","part","undefined","subscribe","add","delete","getState","replaceState","newState","clearPersistedState","removeItem","registerModule","unregisterModule","createState","initialValue","createAction","actionFn","originalMount","mount","async","container","compName","props","componentDef","_components","get","wrappedComponent","setup","ctx","bind","originalSetup","originalMountComponents","_mountComponents","children","childInstances","wrappedChildren","selector","childComponent","_originalMount","_originalMountComponents","uninstall"],"mappings":"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"}
{"version":3,"file":"eleva.umd.min.js","sources":["../src/modules/TemplateEngine.js","../src/modules/Signal.js","../src/modules/Emitter.js","../src/modules/Renderer.js","../src/core/Eleva.js"],"sourcesContent":["\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @typedef {Record<string, unknown>} ContextData\n *           Data context for expression evaluation\n */\n\n/**\n * @typedef {string} Expression\n *           A JavaScript expression to be evaluated in the data context\n */\n\n/**\n * @typedef {unknown} EvaluationResult\n *           The result of evaluating an expression (string, number, boolean, object, function, etc.)\n */\n\n/**\n * @class ðŸ”’ TemplateEngine\n * @classdesc A minimal expression evaluator for Eleva's directive attributes.\n * Evaluates JavaScript expressions against a component's context data.\n * Used internally for `@event` handlers and `:prop` bindings.\n *\n * All methods are static and can be called directly on the class.\n *\n * @example\n * // Property access\n * TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } });\n * // Result: \"John\"\n *\n * @example\n * // Function reference (for @event handlers)\n * TemplateEngine.evaluate(\"handleClick\", { handleClick: () => console.log(\"clicked\") });\n * // Result: [Function]\n *\n * @example\n * // Signal values (for :prop bindings)\n * TemplateEngine.evaluate(\"count.value\", { count: { value: 42 } });\n * // Result: 42\n *\n * @example\n * // Complex expressions\n * TemplateEngine.evaluate(\"items.filter(i => i.active)\", { items: [{active: true}, {active: false}] });\n * // Result: [{active: true}]\n */\nexport class TemplateEngine {\n  /**\n   * Cache for compiled expression functions.\n   * Stores compiled Function objects keyed by expression string for O(1) lookup.\n   *\n   * @static\n   * @private\n   * @type {Map<string, Function>}\n   */\n  static _functionCache = new Map();\n\n  /**\n   * Evaluates an expression in the context of the provided data object.\n   * Used for resolving `@event` handlers and `:prop` bindings.\n   *\n   * Note: This does not provide a true sandbox and evaluated expressions may access global scope.\n   * The use of the `with` statement is necessary for expression evaluation but has security implications.\n   * Only use with trusted templates. User input should never be directly interpolated.\n   *\n   * @public\n   * @static\n   * @param {Expression|unknown} expression - The expression to evaluate.\n   * @param {ContextData} data - The data context for evaluation.\n   * @returns {EvaluationResult} The result of the evaluation, or empty string if evaluation fails.\n   *\n   * @example\n   * // Property access\n   * TemplateEngine.evaluate(\"user.name\", { user: { name: \"John\" } });\n   * // Result: \"John\"\n   *\n   * @example\n   * // Function reference\n   * TemplateEngine.evaluate(\"increment\", { increment: () => count++ });\n   * // Result: [Function]\n   *\n   * @example\n   * // Nested property with Signal\n   * TemplateEngine.evaluate(\"count.value\", { count: { value: 42 } });\n   * // Result: 42\n   *\n   * @example\n   * // Object reference (no JSON.stringify needed)\n   * TemplateEngine.evaluate(\"user\", { user: { name: \"John\", age: 30 } });\n   * // Result: { name: \"John\", age: 30 }\n   *\n   * @example\n   * // Expressions\n   * TemplateEngine.evaluate(\"items.length > 0\", { items: [1, 2, 3] });\n   * // Result: true\n   *\n   * @example\n   * // Failed evaluation returns empty string\n   * TemplateEngine.evaluate(\"nonexistent.property\", {});\n   * // Result: \"\"\n   */\n  static evaluate(expression, data) {\n    if (typeof expression !== \"string\") return expression;\n    if (!expression.trim()) return \"\";\n\n    let fn = this._functionCache.get(expression);\n    if (!fn) {\n      try {\n        fn = new Function(\"data\", `with(data) { return ${expression}; }`);\n        this._functionCache.set(expression, fn);\n      } catch {\n        return \"\";\n      }\n    }\n    try {\n      return fn(data);\n    } catch {\n      return \"\";\n    }\n  }\n}\n","\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @template T\n * @callback SignalWatcher\n * @param {T} value - The new value of the signal\n * @returns {void}\n */\n\n/**\n * @callback SignalUnsubscribe\n * @returns {boolean} True if the watcher was successfully removed\n */\n\n/**\n * @template T\n * @typedef {Object} SignalLike\n * @property {T} value - The current value\n * @property {function(SignalWatcher<T>): SignalUnsubscribe} watch - Subscribe to changes\n */\n\n/**\n * @class âš¡ Signal\n * @classdesc A reactive data holder that enables fine-grained reactivity in the Eleva framework.\n * Signals notify registered watchers synchronously when their value changes, enabling efficient\n * DOM updates through targeted patching rather than full re-renders.\n * Synchronous notification preserves stack traces and allows immediate value inspection.\n * Render batching is handled at the component level, not the signal level.\n * The class is generic, allowing type-safe handling of any value type T.\n *\n * @template T The type of value held by this signal\n *\n * @example\n * // Basic usage\n * const count = new Signal(0);\n * count.watch((value) => console.log(`Count changed to: ${value}`));\n * count.value = 1; // Logs: \"Count changed to: 1\"\n *\n * @example\n * // With unsubscribe\n * const name = new Signal(\"John\");\n * const unsubscribe = name.watch((value) => console.log(value));\n * name.value = \"Jane\"; // Logs: \"Jane\"\n * unsubscribe(); // Stop watching\n * name.value = \"Bob\"; // No log output\n *\n * @example\n * // With objects\n * /** @type {Signal<{x: number, y: number}>} *\\/\n * const position = new Signal({ x: 0, y: 0 });\n * position.value = { x: 10, y: 20 }; // Triggers watchers\n *\n * @implements {SignalLike<T>}\n */\nexport class Signal {\n  /**\n   * Creates a new Signal instance with the specified initial value.\n   *\n   * @public\n   * @param {T} value - The initial value of the signal.\n   *\n   * @example\n   * // Primitive types\n   * const count = new Signal(0);        // Signal<number>\n   * const name = new Signal(\"John\");    // Signal<string>\n   * const active = new Signal(true);    // Signal<boolean>\n   *\n   * @example\n   * // Complex types (use JSDoc for type inference)\n   * /** @type {Signal<string[]>} *\\/\n   * const items = new Signal([]);\n   *\n   * /** @type {Signal<{id: number, name: string} | null>} *\\/\n   * const user = new Signal(null);\n   */\n  constructor(value) {\n    /**\n     * Internal storage for the signal's current value.\n     * @private\n     * @type {T}\n     */\n    this._value = value;\n    /**\n     * Collection of callback functions to be notified when value changes.\n     * @private\n     * @type {Set<SignalWatcher<T>>}\n     */\n    this._watchers = new Set();\n  }\n\n  /**\n   * Gets the current value of the signal.\n   *\n   * @public\n   * @returns {T} The current value.\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * Sets a new value for the signal and synchronously notifies all registered watchers if the value has changed.\n   * Synchronous notification preserves stack traces and ensures immediate value consistency.\n   *\n   * @public\n   * @param {T} newVal - The new value to set.\n   * @returns {void}\n   */\n  set value(newVal) {\n    if (this._value !== newVal) {\n      this._value = newVal;\n      this._notify();\n    }\n  }\n\n  /**\n   * Registers a watcher function that will be called whenever the signal's value changes.\n   * The watcher will receive the new value as its argument.\n   *\n   * @public\n   * @param {SignalWatcher<T>} fn - The callback function to invoke on value change.\n   * @returns {SignalUnsubscribe} A function to unsubscribe the watcher.\n   *\n   * @example\n   * // Basic watching\n   * const unsubscribe = signal.watch((value) => console.log(value));\n   *\n   * @example\n   * // Stop watching\n   * unsubscribe(); // Returns true if watcher was removed\n   *\n   * @example\n   * // Multiple watchers\n   * const unsub1 = signal.watch((v) => console.log(\"Watcher 1:\", v));\n   * const unsub2 = signal.watch((v) => console.log(\"Watcher 2:\", v));\n   * signal.value = \"test\"; // Both watchers are called\n   */\n  watch(fn) {\n    this._watchers.add(fn);\n    return () => this._watchers.delete(fn);\n  }\n\n  /**\n   * Synchronously notifies all registered watchers of the value change.\n   * This preserves stack traces for debugging and ensures immediate\n   * value consistency. Render batching is handled at the component level.\n   *\n   * @private\n   * @returns {void}\n   */\n  _notify() {\n    for (const fn of this._watchers) fn(this._value);\n  }\n}\n","\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @template T\n * @callback EventHandler\n * @param {...T} args - Event arguments\n * @returns {void|Promise<void>}\n */\n\n/**\n * @callback EventUnsubscribe\n * @returns {void}\n */\n\n/**\n * @typedef {`${string}:${string}`} EventName\n *           Event names follow the format 'namespace:action' (e.g., 'user:login', 'cart:update')\n */\n\n/**\n * @typedef {Object} EmitterLike\n * @property {function(string, EventHandler<unknown>): EventUnsubscribe} on - Subscribe to an event\n * @property {function(string, EventHandler<unknown>=): void} off - Unsubscribe from an event\n * @property {function(string, ...unknown): void} emit - Emit an event\n */\n\n/**\n * @class ðŸ“¡ Emitter\n * @classdesc A robust event emitter that enables inter-component communication through a publish-subscribe pattern.\n * Components can emit events and listen for events from other components, facilitating loose coupling\n * and reactive updates across the application.\n * Events are handled synchronously in the order they were registered, with proper cleanup\n * of unsubscribed handlers.\n *\n * Event names should follow the format 'namespace:action' for consistency and organization.\n *\n * @example\n * // Basic usage\n * const emitter = new Emitter();\n * emitter.on('user:login', (user) => console.log(`User logged in: ${user.name}`));\n * emitter.emit('user:login', { name: 'John' }); // Logs: \"User logged in: John\"\n *\n * @example\n * // With unsubscribe\n * const unsub = emitter.on('cart:update', (items) => {\n *   console.log(`Cart has ${items.length} items`);\n * });\n * emitter.emit('cart:update', [{ id: 1, name: 'Book' }]); // Logs: \"Cart has 1 items\"\n * unsub(); // Stop listening\n * emitter.emit('cart:update', []); // No log output\n *\n * @example\n * // Multiple arguments\n * emitter.on('order:placed', (orderId, amount, currency) => {\n *   console.log(`Order ${orderId}: ${amount} ${currency}`);\n * });\n * emitter.emit('order:placed', 'ORD-123', 99.99, 'USD');\n *\n * @example\n * // Common event patterns\n * // Lifecycle events\n * emitter.on('component:mount', (component) => {});\n * emitter.on('component:unmount', (component) => {});\n * // State events\n * emitter.on('state:change', (newState, oldState) => {});\n * // Navigation events\n * emitter.on('router:navigate', (to, from) => {});\n *\n * @implements {EmitterLike}\n */\nexport class Emitter {\n  /**\n   * Creates a new Emitter instance.\n   *\n   * @public\n   *\n   * @example\n   * const emitter = new Emitter();\n   */\n  constructor() {\n    /**\n     * Map of event names to their registered handler functions\n     * @private\n     * @type {Map<string, Set<EventHandler<unknown>>>}\n     */\n    this._events = new Map();\n  }\n\n  /**\n   * Registers an event handler for the specified event name.\n   * The handler will be called with the event data when the event is emitted.\n   * Event names should follow the format 'namespace:action' for consistency.\n   *\n   * @public\n   * @template T\n   * @param {string} event - The name of the event to listen for (e.g., 'user:login').\n   * @param {EventHandler<T>} handler - The callback function to invoke when the event occurs.\n   * @returns {EventUnsubscribe} A function to unsubscribe the event handler.\n   *\n   * @example\n   * // Basic subscription\n   * const unsubscribe = emitter.on('user:login', (user) => console.log(user));\n   *\n   * @example\n   * // Typed handler\n   * emitter.on('user:update', (/** @type {{id: number, name: string}} *\\/ user) => {\n   *   console.log(`User ${user.id}: ${user.name}`);\n   * });\n   *\n   * @example\n   * // Cleanup\n   * unsubscribe(); // Stops listening for the event\n   */\n  on(event, handler) {\n    let h = this._events.get(event);\n    if (!h) this._events.set(event, (h = new Set()));\n    h.add(handler);\n    return () => this.off(event, handler);\n  }\n\n  /**\n   * Removes an event handler for the specified event name.\n   * If no handler is provided, all handlers for the event are removed.\n   * Automatically cleans up empty event sets to prevent memory leaks.\n   *\n   * @public\n   * @template T\n   * @param {string} event - The name of the event to remove handlers from.\n   * @param {EventHandler<T>} [handler] - The specific handler function to remove.\n   * @returns {void}\n   *\n   * @example\n   * // Remove a specific handler\n   * const loginHandler = (user) => console.log(user);\n   * emitter.on('user:login', loginHandler);\n   * emitter.off('user:login', loginHandler);\n   *\n   * @example\n   * // Remove all handlers for an event\n   * emitter.off('user:login');\n   */\n  off(event, handler) {\n    if (!this._events.has(event)) return;\n    if (handler) {\n      const handlers = this._events.get(event);\n      handlers.delete(handler);\n      if (handlers.size === 0) this._events.delete(event);\n    } else {\n      this._events.delete(event);\n    }\n  }\n\n  /**\n   * Emits an event with the specified data to all registered handlers.\n   * Handlers are called synchronously in the order they were registered.\n   * If no handlers are registered for the event, the emission is silently ignored.\n   *\n   * @public\n   * @template T\n   * @param {string} event - The name of the event to emit.\n   * @param {...T} args - Optional arguments to pass to the event handlers.\n   * @returns {void}\n   *\n   * @example\n   * // Emit an event with data\n   * emitter.emit('user:login', { name: 'John', role: 'admin' });\n   *\n   * @example\n   * // Emit an event with multiple arguments\n   * emitter.emit('order:placed', 'ORD-123', 99.99, 'USD');\n   *\n   * @example\n   * // Emit without data\n   * emitter.emit('app:ready');\n   */\n  emit(event, ...args) {\n    const handlers = this._events.get(event);\n    if (handlers) for (const handler of handlers) handler(...args);\n  }\n}\n","\"use strict\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n/**\n * @typedef {Map<string, Node>} KeyMap\n *          Map of key attribute values to their corresponding DOM nodes for O(1) lookup\n */\n\n/**\n * @typedef {Object} RendererLike\n * @property {function(HTMLElement, string): void} patchDOM - Patches the DOM with new HTML\n */\n\n/**\n * Properties that can diverge from attributes via user interaction.\n * @private\n * @type {string[]}\n */\nconst SYNC_PROPS = [\"value\", \"checked\", \"selected\"];\n\n/**\n * @class ðŸŽ¨ Renderer\n * @classdesc A high-performance DOM renderer that implements an optimized two-pointer diffing\n * algorithm with key-based node reconciliation. The renderer efficiently updates the DOM by\n * computing the minimal set of operations needed to transform the current state to the desired state.\n *\n * Key features:\n * - Two-pointer diffing algorithm for efficient DOM updates\n * - Key-based node reconciliation for optimal list performance (O(1) lookup)\n * - Preserves DOM node identity during reordering (maintains event listeners, focus, animations)\n * - Intelligent attribute synchronization (skips Eleva event attributes)\n * - Preservation of Eleva-managed component instances and style elements\n *\n * @example\n * // Basic usage\n * const renderer = new Renderer();\n * renderer.patchDOM(container, '<div>Updated content</div>');\n *\n * @example\n * // With keyed elements for optimal list updates\n * const html = items.map(item => `<li key=\"${item.id}\">${item.name}</li>`).join('');\n * renderer.patchDOM(listContainer, `<ul>${html}</ul>`);\n *\n * @example\n * // Keyed elements preserve DOM identity during reordering\n * // Before: [A, B, C] -> After: [C, A, B]\n * // The actual DOM nodes are moved, not recreated\n * renderer.patchDOM(container, '<div key=\"C\">C</div><div key=\"A\">A</div><div key=\"B\">B</div>');\n *\n * @implements {RendererLike}\n */\nexport class Renderer {\n  /**\n   * Creates a new Renderer instance.\n   *\n   * @public\n   *\n   * @example\n   * const renderer = new Renderer();\n   */\n  constructor() {\n    /**\n     * Temporary container for parsing new HTML content.\n     * Reused across patch operations to minimize memory allocation.\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this._tempContainer = document.createElement(\"div\");\n  }\n\n  /**\n   * Patches the DOM of the given container with the provided HTML string.\n   * Uses an optimized two-pointer diffing algorithm to minimize DOM operations.\n   * The algorithm computes the minimal set of insertions, deletions, and updates\n   * needed to transform the current DOM state to match the new HTML.\n   *\n   * @public\n   * @param {HTMLElement} container - The container element to patch.\n   * @param {string} newHtml - The new HTML string to render.\n   * @returns {void}\n   *\n   * @example\n   * // Simple content update\n   * renderer.patchDOM(container, '<div class=\"updated\">New content</div>');\n   *\n   * @example\n   * // List with keyed items (optimal for reordering)\n   * renderer.patchDOM(container, '<ul><li key=\"1\">First</li><li key=\"2\">Second</li></ul>');\n   *\n   * @example\n   * // Empty the container\n   * renderer.patchDOM(container, '');\n   */\n  patchDOM(container, newHtml) {\n    this._tempContainer.innerHTML = newHtml;\n    this._diff(container, this._tempContainer);\n  }\n\n  /**\n   * Performs a diff between two DOM nodes and patches the old node to match the new node.\n   * Uses a two-pointer algorithm with key-based reconciliation for optimal performance.\n   *\n   * Algorithm overview:\n   * 1. Compare children from start using two pointers\n   * 2. For mismatches, build a key map lazily for O(1) lookup\n   * 3. Move or insert nodes as needed\n   * 4. Clean up remaining nodes at the end\n   *\n   * @private\n   * @param {HTMLElement} oldParent - The original DOM element to update.\n   * @param {HTMLElement} newParent - The new DOM element with desired state.\n   * @returns {void}\n   */\n  _diff(oldParent, newParent) {\n    // Early exit for leaf nodes (no children)\n    if (!oldParent.firstChild && !newParent.firstChild) return;\n\n    const oldChildren = Array.from(oldParent.childNodes);\n    const newChildren = Array.from(newParent.childNodes);\n    let oldStart = 0,\n      newStart = 0;\n    let oldEnd = oldChildren.length - 1;\n    let newEnd = newChildren.length - 1;\n    let keyMap = null;\n\n    // Two-pointer algorithm with key-based reconciliation\n    while (oldStart <= oldEnd && newStart <= newEnd) {\n      const oldNode = oldChildren[oldStart];\n      const newNode = newChildren[newStart];\n\n      if (!oldNode) {\n        oldStart++;\n        continue;\n      }\n\n      if (this._isSameNode(oldNode, newNode)) {\n        this._patchNode(oldNode, newNode);\n        oldStart++;\n        newStart++;\n      } else {\n        // Build key map lazily for O(1) lookup\n        if (!keyMap) {\n          keyMap = this._createKeyMap(oldChildren, oldStart, oldEnd);\n        }\n\n        const key = this._getNodeKey(newNode);\n        const matchedNode = key ? keyMap.get(key) : null;\n\n        // Only use matched node if tag also matches\n        if (matchedNode && matchedNode.nodeName === newNode.nodeName) {\n          // Move existing keyed node (preserves DOM identity)\n          this._patchNode(matchedNode, newNode);\n          oldParent.insertBefore(matchedNode, oldNode);\n          oldChildren[oldChildren.indexOf(matchedNode)] = null;\n        } else {\n          // Insert new node\n          oldParent.insertBefore(newNode.cloneNode(true), oldNode);\n        }\n        newStart++;\n      }\n    }\n\n    // Add remaining new nodes\n    if (oldStart > oldEnd) {\n      const refNode = newChildren[newEnd + 1] ? oldChildren[oldStart] : null;\n      for (let i = newStart; i <= newEnd; i++) {\n        if (newChildren[i]) {\n          oldParent.insertBefore(newChildren[i].cloneNode(true), refNode);\n        }\n      }\n    }\n    // Remove remaining old nodes\n    else if (newStart > newEnd) {\n      for (let i = oldStart; i <= oldEnd; i++) {\n        if (oldChildren[i]) this._removeNode(oldParent, oldChildren[i]);\n      }\n    }\n  }\n\n  /**\n   * Patches a single node, updating its content and attributes to match the new node.\n   * Handles text nodes by updating nodeValue, and element nodes by updating attributes\n   * and recursively diffing children.\n   *\n   * Skips nodes that are managed by Eleva component instances to prevent interference\n   * with nested component state.\n   *\n   * @private\n   * @param {Node} oldNode - The original DOM node to update.\n   * @param {Node} newNode - The new DOM node with desired state.\n   * @returns {void}\n   */\n  _patchNode(oldNode, newNode) {\n    // Skip nodes managed by Eleva component instances\n    if (oldNode._eleva_instance) return;\n\n    if (oldNode.nodeType === 3) {\n      if (oldNode.nodeValue !== newNode.nodeValue) {\n        oldNode.nodeValue = newNode.nodeValue;\n      }\n    } else if (oldNode.nodeType === 1) {\n      this._updateAttributes(oldNode, newNode);\n      this._diff(oldNode, newNode);\n    }\n  }\n\n  /**\n   * Removes a node from its parent, with special handling for Eleva-managed elements.\n   * Style elements with the `data-e-style` attribute are preserved to maintain\n   * component-scoped styles across re-renders.\n   *\n   * @private\n   * @param {HTMLElement} parent - The parent element containing the node.\n   * @param {Node} node - The node to remove.\n   * @returns {void}\n   */\n  _removeNode(parent, node) {\n    // Preserve Eleva-managed style elements\n    if (node.nodeName === \"STYLE\" && node.hasAttribute(\"data-e-style\")) return;\n    parent.removeChild(node);\n  }\n\n  /**\n   * Updates the attributes of an element to match a new element's attributes.\n   * Adds new attributes, updates changed values, and removes attributes no longer present.\n   * Also syncs DOM properties that can diverge from attributes after user interaction.\n   *\n   * Event attributes (prefixed with `@`) are skipped as they are handled separately\n   * by Eleva's event binding system.\n   *\n   * @private\n   * @param {HTMLElement} oldEl - The original element to update.\n   * @param {HTMLElement} newEl - The new element with target attributes.\n   * @returns {void}\n   */\n  _updateAttributes(oldEl, newEl) {\n    // Add/update attributes from new element\n    for (const attr of newEl.attributes) {\n      // Skip event attributes (handled by Eleva's event system)\n      if (attr.name[0] === \"@\") continue;\n\n      if (oldEl.getAttribute(attr.name) !== attr.value) {\n        oldEl.setAttribute(attr.name, attr.value);\n      }\n\n      // Sync property if it exists and is writable (handles value, checked, selected, disabled, etc.)\n      if (attr.name in oldEl) {\n        try {\n          const newProp =\n            typeof oldEl[attr.name] === \"boolean\"\n              ? attr.value !== \"false\" // Attribute presence = true, unless explicitly \"false\"\n              : attr.value;\n          if (oldEl[attr.name] !== newProp) oldEl[attr.name] = newProp;\n        } catch {\n          continue; // Property is readonly\n        }\n      }\n    }\n\n    // Remove attributes no longer present\n    for (let i = oldEl.attributes.length - 1; i >= 0; i--) {\n      const name = oldEl.attributes[i].name;\n      if (!newEl.hasAttribute(name)) {\n        oldEl.removeAttribute(name);\n      }\n    }\n\n    // Sync properties that can diverge from attributes via user interaction\n    for (const prop of SYNC_PROPS) {\n      if (prop in newEl && oldEl[prop] !== newEl[prop])\n        oldEl[prop] = newEl[prop];\n    }\n  }\n\n  /**\n   * Determines if two nodes are the same for reconciliation purposes.\n   * Two nodes are considered the same if:\n   * - Both have keys: keys match AND tag names match\n   * - Neither has keys: node types match AND node names match\n   * - One has key, other doesn't: not the same\n   *\n   * This ensures keyed elements are only reused when both key and tag match,\n   * preventing bugs like `<div key=\"a\">` incorrectly matching `<span key=\"a\">`.\n   *\n   * @private\n   * @param {Node} oldNode - The first node to compare.\n   * @param {Node} newNode - The second node to compare.\n   * @returns {boolean} True if the nodes are considered the same for reconciliation.\n   */\n  _isSameNode(oldNode, newNode) {\n    if (!oldNode || !newNode) return false;\n\n    const oldKey = this._getNodeKey(oldNode);\n    const newKey = this._getNodeKey(newNode);\n\n    // If both have keys, compare by key AND tag name\n    if (oldKey && newKey) {\n      return oldKey === newKey && oldNode.nodeName === newNode.nodeName;\n    }\n\n    // Otherwise, compare by type and name\n    return (\n      !oldKey &&\n      !newKey &&\n      oldNode.nodeType === newNode.nodeType &&\n      oldNode.nodeName === newNode.nodeName\n    );\n  }\n\n  /**\n   * Extracts the key attribute from a node if it exists.\n   * Only element nodes (nodeType === 1) can have key attributes.\n   *\n   * @private\n   * @param {Node|null|undefined} node - The node to extract the key from.\n   * @returns {string|null} The key attribute value, or null if not an element or no key.\n   */\n  _getNodeKey(node) {\n    return node?.nodeType === 1 ? node.getAttribute(\"key\") : null;\n  }\n\n  /**\n   * Creates a key map for efficient O(1) lookup of keyed elements during diffing.\n   * The map is built lazily only when needed (when a mismatch occurs during diffing).\n   *\n   * @private\n   * @param {Array<ChildNode>} children - The array of child nodes to map.\n   * @param {number} start - The start index (inclusive) for mapping.\n   * @param {number} end - The end index (inclusive) for mapping.\n   * @returns {KeyMap} A Map of key strings to their corresponding DOM nodes.\n   */\n  _createKeyMap(children, start, end) {\n    const map = new Map();\n    for (let i = start; i <= end; i++) {\n      const key = this._getNodeKey(children[i]);\n      if (key) map.set(key, children[i]);\n    }\n    return map;\n  }\n}\n","\"use strict\";\n\nimport { TemplateEngine } from \"../modules/TemplateEngine.js\";\nimport { Signal } from \"../modules/Signal.js\";\nimport { Emitter } from \"../modules/Emitter.js\";\nimport { Renderer } from \"../modules/Renderer.js\";\n\n// ============================================================================\n// TYPE DEFINITIONS - TypeScript-friendly JSDoc types for IDE support\n// ============================================================================\n\n// -----------------------------------------------------------------------------\n// Configuration Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ElevaConfig\n * @property {boolean} [debug=false]\n *           Enable debug mode for verbose logging\n * @property {string} [prefix='e']\n *           Prefix for component style scoping\n * @property {boolean} [async=true]\n *           Enable async component setup\n */\n\n// -----------------------------------------------------------------------------\n// Component Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ComponentDefinition\n * @property {SetupFunction} [setup]\n *           Optional setup function that initializes the component's state and returns reactive data\n * @property {TemplateFunction|string} template\n *           Required function or string that defines the component's HTML structure\n * @property {StyleFunction|string} [style]\n *           Optional function or string that provides component-scoped CSS styles\n * @property {ChildrenMap} [children]\n *           Optional object defining nested child components\n */\n\n/**\n * @callback SetupFunction\n * @param {ComponentContext} ctx - The component context with props, emitter, and signal factory\n * @returns {SetupResult|Promise<SetupResult>} Reactive data and lifecycle hooks\n */\n\n/**\n * @typedef {Record<string, unknown> & LifecycleHooks} SetupResult\n *           Data returned from setup function, may include lifecycle hooks\n */\n\n/**\n * @callback TemplateFunction\n * @param {ComponentContext} ctx - The component context\n * @returns {string|Promise<string>} HTML template string\n */\n\n/**\n * @callback StyleFunction\n * @param {ComponentContext} ctx - The component context\n * @returns {string} CSS styles string\n */\n\n/**\n * @typedef {Record<string, ComponentDefinition|string>} ChildrenMap\n *           Map of CSS selectors to component definitions or registered component names\n */\n\n// -----------------------------------------------------------------------------\n// Context Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ComponentContext\n * @property {ComponentProps} props\n *           Component properties passed during mounting\n * @property {Emitter} emitter\n *           Event emitter instance for component event handling\n * @property {SignalFactory} signal\n *           Factory function to create reactive Signal instances\n */\n\n/**\n * @typedef {Record<string, unknown>} ComponentProps\n *           Properties passed to a component during mounting\n */\n\n/**\n * @callback SignalFactory\n * @template T\n * @param {T} initialValue - The initial value for the signal\n * @returns {Signal<T>} A new Signal instance\n */\n\n// -----------------------------------------------------------------------------\n// Lifecycle Hook Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} LifecycleHooks\n * @property {LifecycleHook} [onBeforeMount]\n *           Hook called before component mounting\n * @property {LifecycleHook} [onMount]\n *           Hook called after component mounting\n * @property {LifecycleHook} [onBeforeUpdate]\n *           Hook called before component update\n * @property {LifecycleHook} [onUpdate]\n *           Hook called after component update\n * @property {UnmountHook} [onUnmount]\n *           Hook called during component unmounting\n */\n\n/**\n * @callback LifecycleHook\n * @param {LifecycleHookContext} ctx - Context with container and component data\n * @returns {void|Promise<void>}\n */\n\n/**\n * @callback UnmountHook\n * @param {UnmountHookContext} ctx - Context with cleanup resources\n * @returns {void|Promise<void>}\n */\n\n/**\n * @typedef {Object} LifecycleHookContext\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {ComponentContext & SetupResult} context\n *           The component's reactive state and context data\n */\n\n/**\n * @typedef {Object} UnmountHookContext\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {ComponentContext & SetupResult} context\n *           The component's reactive state and context data\n * @property {CleanupResources} cleanup\n *           Object containing cleanup functions and instances\n */\n\n/**\n * @typedef {Object} CleanupResources\n * @property {Array<UnsubscribeFunction>} watchers\n *           Signal watcher cleanup functions\n * @property {Array<UnsubscribeFunction>} listeners\n *           Event listener cleanup functions\n * @property {Array<MountResult>} children\n *           Child component instances\n */\n\n// -----------------------------------------------------------------------------\n// Mount Result Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} MountResult\n * @property {HTMLElement} container\n *           The DOM element where the component is mounted\n * @property {ComponentContext & SetupResult} data\n *           The component's reactive state and context data\n * @property {UnmountFunction} unmount\n *           Function to clean up and unmount the component\n */\n\n/**\n * @callback UnmountFunction\n * @returns {Promise<void>}\n */\n\n/**\n * @callback UnsubscribeFunction\n * @returns {void|boolean}\n */\n\n// -----------------------------------------------------------------------------\n// Plugin Types\n// -----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ElevaPlugin\n * @property {PluginInstallFunction} install\n *           Function that installs the plugin into the Eleva instance\n * @property {string} name\n *           Unique identifier name for the plugin\n * @property {PluginUninstallFunction} [uninstall]\n *           Optional function to uninstall the plugin\n */\n\n/**\n * @callback PluginInstallFunction\n * @param {Eleva} eleva - The Eleva instance\n * @param {PluginOptions} options - Plugin configuration options\n * @returns {void|Eleva|unknown} Optionally returns the Eleva instance or plugin result\n */\n\n/**\n * @callback PluginUninstallFunction\n * @param {Eleva} eleva - The Eleva instance\n * @returns {void}\n */\n\n/**\n * @typedef {Record<string, unknown>} PluginOptions\n *           Configuration options passed to a plugin during installation\n */\n\n// -----------------------------------------------------------------------------\n// Event Types\n// -----------------------------------------------------------------------------\n\n/**\n * @callback EventHandler\n * @param {Event} event - The DOM event object\n * @returns {void}\n */\n\n/**\n * @typedef {'click'|'submit'|'input'|'change'|'focus'|'blur'|'keydown'|'keyup'|'keypress'|'mouseenter'|'mouseleave'|'mouseover'|'mouseout'|'mousedown'|'mouseup'|'touchstart'|'touchend'|'touchmove'|'scroll'|'resize'|'load'|'error'|string} DOMEventName\n *           Common DOM event names (prefixed with @ in templates)\n */\n\n/**\n * @class ðŸ§© Eleva\n * @classdesc A modern, signal-based component runtime framework that provides lifecycle hooks,\n * scoped styles, and plugin support. Eleva manages component registration, plugin integration,\n * event handling, and DOM rendering with a focus on performance and developer experience.\n *\n * @example\n * // Basic component creation and mounting\n * const app = new Eleva(\"myApp\");\n * app.component(\"myComponent\", {\n *   setup: (ctx) => ({ count: ctx.signal(0) }),\n *   template: (ctx) => `<div>Hello ${ctx.props.name}</div>`\n * });\n * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n *\n * @example\n * // Using lifecycle hooks\n * app.component(\"lifecycleDemo\", {\n *   setup: () => {\n *     return {\n *       onMount: ({ container, context }) => {\n *         console.log('Component mounted!');\n *       }\n *     };\n *   },\n *   template: `<div>Lifecycle Demo</div>`\n * });\n */\nexport class Eleva {\n  /**\n   * Creates a new Eleva instance with the specified name and configuration.\n   *\n   * @public\n   * @param {string} name - The unique identifier name for this Eleva instance.\n   * @param {Record<string, unknown>} [config={}] - Optional configuration object for the instance.\n   *        May include framework-wide settings and default behaviors.\n   * @throws {Error} If the name is not provided or is not a string.\n   * @returns {Eleva} A new Eleva instance.\n   *\n   * @example\n   * const app = new Eleva(\"myApp\");\n   * app.component(\"myComponent\", {\n   *   setup: (ctx) => ({ count: ctx.signal(0) }),\n   *   template: (ctx) => `<div>Hello ${ctx.props.name}!</div>`\n   * });\n   * app.mount(document.getElementById(\"app\"), \"myComponent\", { name: \"World\" });\n   *\n   */\n  constructor(name, config = {}) {\n    if (!name || typeof name !== \"string\") {\n      throw new Error(\"Eleva: name must be a non-empty string\");\n    }\n    /** @public {string} The unique identifier name for this Eleva instance */\n    this.name = name;\n    /** @public {Object<string, unknown>} Optional configuration object for the Eleva instance */\n    this.config = config;\n    /** @public {Emitter} Instance of the event emitter for handling component events */\n    this.emitter = new Emitter();\n    /** @public {typeof Signal} Static reference to the Signal class for creating reactive state */\n    this.signal = Signal;\n    /** @public {typeof TemplateEngine} Static reference to the TemplateEngine class for template parsing */\n    this.templateEngine = TemplateEngine;\n    /** @public {Renderer} Instance of the renderer for handling DOM updates and patching */\n    this.renderer = new Renderer();\n\n    /** @private {Map<string, ComponentDefinition>} Registry of all component definitions by name */\n    this._components = new Map();\n    /** @private {Map<string, ElevaPlugin>} Collection of installed plugin instances by name */\n    this._plugins = new Map();\n    /** @private {number} Counter for generating unique component IDs */\n    this._componentCounter = 0;\n  }\n\n  /**\n   * Integrates a plugin with the Eleva framework.\n   * The plugin's install function will be called with the Eleva instance and provided options.\n   * After installation, the plugin will be available for use by components.\n   *\n   * Note: Plugins that wrap core methods (e.g., mount) must be uninstalled in reverse order\n   * of installation (LIFO - Last In, First Out) to avoid conflicts.\n   *\n   * @public\n   * @param {ElevaPlugin} plugin - The plugin object which must have an `install` function.\n   * @param {Object<string, unknown>} [options={}] - Optional configuration options for the plugin.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If plugin does not have an install function.\n   * @example\n   * app.use(myPlugin, { option1: \"value1\" });\n   *\n   * @example\n   * // Correct uninstall order (LIFO)\n   * app.use(PluginA);\n   * app.use(PluginB);\n   * // Uninstall in reverse order:\n   * PluginB.uninstall(app);\n   * PluginA.uninstall(app);\n   */\n  use(plugin, options = {}) {\n    if (!plugin?.install || typeof plugin.install !== \"function\") {\n      throw new Error(\"Eleva: plugin must have an install function\");\n    }\n    this._plugins.set(plugin.name, plugin);\n    const result = plugin.install(this, options);\n\n    return result !== undefined ? result : this;\n  }\n\n  /**\n   * Registers a new component with the Eleva instance.\n   * The component will be available for mounting using its registered name.\n   *\n   * @public\n   * @param {string} name - The unique name of the component to register.\n   * @param {ComponentDefinition} definition - The component definition including setup, template, style, and children.\n   * @returns {Eleva} The Eleva instance (for method chaining).\n   * @throws {Error} If name is not a non-empty string or definition has no template.\n   * @example\n   * app.component(\"myButton\", {\n   *   template: (ctx) => `<button>${ctx.props.text}</button>`,\n   *   style: `button { color: blue; }`\n   * });\n   */\n  component(name, definition) {\n    if (!name || typeof name !== \"string\") {\n      throw new Error(\"Eleva: component name must be a non-empty string\");\n    }\n    if (!definition?.template) {\n      throw new Error(`Eleva: component \"${name}\" must have a template`);\n    }\n    /** @type {Map<string, ComponentDefinition>} */\n    this._components.set(name, definition);\n    return this;\n  }\n\n  /**\n   * Mounts a registered component to a DOM element.\n   * This will initialize the component, set up its reactive state, and render it to the DOM.\n   *\n   * @public\n   * @param {HTMLElement} container - The DOM element where the component will be mounted.\n   * @param {string|ComponentDefinition} compName - The name of the registered component or a direct component definition.\n   * @param {Object<string, unknown>} [props={}] - Optional properties to pass to the component.\n   * @returns {Promise<MountResult>}\n   *          A Promise that resolves to an object containing:\n   *          - container: The mounted component's container element\n   *          - data: The component's reactive state and context\n   *          - unmount: Function to clean up and unmount the component\n   * @throws {Error} If container is not a DOM element or component is not registered.\n   * @example\n   * const instance = await app.mount(document.getElementById(\"app\"), \"myComponent\", { text: \"Click me\" });\n   * // Later...\n   * instance.unmount();\n   */\n  async mount(container, compName, props = {}) {\n    if (!container?.nodeType) {\n      throw new Error(\"Eleva: container must be a DOM element\");\n    }\n\n    if (container._eleva_instance) return container._eleva_instance;\n\n    /** @type {ComponentDefinition} */\n    const definition =\n      typeof compName === \"string\" ? this._components.get(compName) : compName;\n    if (!definition) throw new Error(`Component \"${compName}\" not registered.`);\n\n    /** @type {string} */\n    const compId = `c${++this._componentCounter}`;\n\n    /**\n     * Destructure the component definition to access core functionality.\n     * - setup: Optional function for component initialization and state management\n     * - template: Required function or string that returns the component's HTML structure\n     * - style: Optional function or string for component-scoped CSS styles\n     * - children: Optional object defining nested child components\n     */\n    const { setup, template, style, children } = definition;\n\n    /** @type {ComponentContext} */\n    const context = {\n      props,\n      emitter: this.emitter,\n      /** @type {(v: unknown) => Signal<unknown>} */\n      signal: (v) => new this.signal(v),\n    };\n\n    /**\n     * Processes the mounting of the component.\n     * This function handles:\n     * 1. Merging setup data with the component context\n     * 2. Setting up reactive watchers\n     * 3. Rendering the component\n     * 4. Managing component lifecycle\n     *\n     * @param {Object<string, unknown>} data - Data returned from the component's setup function\n     * @returns {Promise<MountResult>} An object containing:\n     *   - container: The mounted component's container element\n     *   - data: The component's reactive state and context\n     *   - unmount: Function to clean up and unmount the component\n     */\n    const processMount = async (data) => {\n      /** @type {ComponentContext} */\n      const mergedContext = { ...context, ...data };\n      /** @type {Array<() => void>} */\n      const watchers = [];\n      /** @type {Array<MountResult>} */\n      const childInstances = [];\n      /** @type {Array<() => void>} */\n      const listeners = [];\n      /** @private {boolean} Local mounted state for this component instance */\n      let isMounted = false;\n\n      // ========================================================================\n      // Render Batching\n      // ========================================================================\n\n      /** @private {boolean} Flag to prevent concurrent renders */\n      let renderScheduled = false;\n\n      /**\n       * Schedules a render using microtask batching.\n       * Since signals now notify watchers synchronously, multiple signal\n       * changes in the same synchronous block will each call this function,\n       * but only one render will be scheduled via queueMicrotask.\n       * This separates concerns: signals handle state, components handle scheduling.\n       * @private\n       */\n      const scheduleRender = () => {\n        if (renderScheduled) return;\n        renderScheduled = true;\n        queueMicrotask(async () => {\n          renderScheduled = false;\n          await render();\n        });\n      };\n\n      /**\n       * Renders the component by:\n       * 1. Executing lifecycle hooks\n       * 2. Processing the template\n       * 3. Updating the DOM\n       * 4. Processing events, injecting styles, and mounting child components.\n       */\n      const render = async () => {\n        const html =\n          typeof template === \"function\"\n            ? await template(mergedContext)\n            : template;\n\n        // Execute before hooks\n        if (!isMounted) {\n          await mergedContext.onBeforeMount?.({\n            container,\n            context: mergedContext,\n          });\n        } else {\n          await mergedContext.onBeforeUpdate?.({\n            container,\n            context: mergedContext,\n          });\n        }\n\n        this.renderer.patchDOM(container, html);\n        this._processEvents(container, mergedContext, listeners);\n        if (style) this._injectStyles(container, compId, style, mergedContext);\n        if (children)\n          await this._mountComponents(\n            container,\n            children,\n            childInstances,\n            mergedContext\n          );\n\n        // Execute after hooks\n        if (!isMounted) {\n          await mergedContext.onMount?.({\n            container,\n            context: mergedContext,\n          });\n          isMounted = true;\n        } else {\n          await mergedContext.onUpdate?.({\n            container,\n            context: mergedContext,\n          });\n        }\n      };\n\n      /**\n       * Sets up reactive watchers for all Signal instances in the component's data.\n       * When a Signal's value changes, a batched render is scheduled.\n       * Multiple changes within the same frame are collapsed into one render.\n       * Stores unsubscribe functions to clean up watchers when component unmounts.\n       */\n      for (const val of Object.values(data)) {\n        if (val instanceof Signal) watchers.push(val.watch(scheduleRender));\n      }\n\n      await render();\n\n      const instance = {\n        container,\n        data: mergedContext,\n        /**\n         * Unmounts the component, cleaning up watchers and listeners, child components, and clearing the container.\n         *\n         * @returns {void}\n         */\n        unmount: async () => {\n          /** @type {UnmountHookContext} */\n          await mergedContext.onUnmount?.({\n            container,\n            context: mergedContext,\n            cleanup: {\n              watchers: watchers,\n              listeners: listeners,\n              children: childInstances,\n            },\n          });\n          for (const fn of watchers) fn();\n          for (const fn of listeners) fn();\n          for (const child of childInstances) await child.unmount();\n          container.innerHTML = \"\";\n          delete container._eleva_instance;\n        },\n      };\n\n      container._eleva_instance = instance;\n      return instance;\n    };\n\n    // Handle asynchronous setup.\n    const setupResult = typeof setup === \"function\" ? await setup(context) : {};\n    return await processMount(setupResult);\n  }\n\n  /**\n   * Processes DOM elements for event binding based on attributes starting with \"@\".\n   * This method handles the event delegation system and ensures proper cleanup of event listeners.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element in which to search for event attributes.\n   * @param {ComponentContext} context - The current component context containing event handler definitions.\n   * @param {Array<() => void>} listeners - Array to collect cleanup functions for each event listener.\n   * @returns {void}\n   */\n  _processEvents(container, context, listeners) {\n    /** @type {NodeListOf<Element>} */\n    const elements = container.querySelectorAll(\"*\");\n    for (const el of elements) {\n      /** @type {NamedNodeMap} */\n      const attrs = el.attributes;\n      for (let i = 0; i < attrs.length; i++) {\n        /** @type {Attr} */\n        const attr = attrs[i];\n\n        if (!attr.name.startsWith(\"@\")) continue;\n\n        /** @type {keyof HTMLElementEventMap} */\n        const event = attr.name.slice(1);\n        /** @type {string} */\n        const handlerName = attr.value;\n        /** @type {(event: Event) => void} */\n        const handler =\n          context[handlerName] ||\n          this.templateEngine.evaluate(handlerName, context);\n        if (typeof handler === \"function\") {\n          el.addEventListener(event, handler);\n          el.removeAttribute(attr.name);\n          listeners.push(() => el.removeEventListener(event, handler));\n        }\n      }\n    }\n  }\n\n  /**\n   * Injects scoped styles into the component's container.\n   * The styles are automatically prefixed to prevent style leakage to other components.\n   *\n   * @private\n   * @param {HTMLElement} container - The container element where styles should be injected.\n   * @param {string} compId - The component ID used to identify the style element.\n   * @param {(function(ComponentContext): string)|string} styleDef - The component's style definition (function or string).\n   * @param {ComponentContext} context - The current component context for style interpolation.\n   * @returns {void}\n   */\n  _injectStyles(container, compId, styleDef, context) {\n    /** @type {string} */\n    const newStyle =\n      typeof styleDef === \"function\" ? styleDef(context) : styleDef;\n\n    /** @type {HTMLStyleElement|null} */\n    let styleEl = container.querySelector(`style[data-e-style=\"${compId}\"]`);\n\n    if (styleEl && styleEl.textContent === newStyle) return;\n    if (!styleEl) {\n      styleEl = document.createElement(\"style\");\n      styleEl.setAttribute(\"data-e-style\", compId);\n      container.appendChild(styleEl);\n    }\n\n    styleEl.textContent = newStyle;\n  }\n\n  /**\n   * Extracts and evaluates props from an element's attributes that start with `:`.\n   * Prop values are evaluated as expressions against the component context,\n   * allowing direct passing of objects, arrays, and other complex types.\n   *\n   * @private\n   * @param {HTMLElement} element - The DOM element to extract props from\n   * @param {ComponentContext} context - The component context for evaluating prop expressions\n   * @returns {Record<string, string>} An object containing the evaluated props\n   * @example\n   * // For an element with attributes:\n   * // <div :name=\"user.name\" :data=\"items\">\n   * // With context: { user: { name: \"John\" }, items: [1, 2, 3] }\n   * // Returns: { name: \"John\", data: [1, 2, 3] }\n   */\n  _extractProps(element, context) {\n    if (!element.attributes) return {};\n\n    const props = {};\n    const attrs = element.attributes;\n\n    for (let i = attrs.length - 1; i >= 0; i--) {\n      const attr = attrs[i];\n      if (attr.name.startsWith(\":\")) {\n        const propName = attr.name.slice(1);\n        props[propName] = this.templateEngine.evaluate(attr.value, context);\n        element.removeAttribute(attr.name);\n      }\n    }\n    return props;\n  }\n\n  /**\n   * Mounts all components within the parent component's container.\n   * This method handles mounting of explicitly defined children components.\n   *\n   * The mounting process follows these steps:\n   * 1. Cleans up any existing component instances\n   * 2. Mounts explicitly defined children components\n   *\n   * @private\n   * @param {HTMLElement} container - The container element to mount components in\n   * @param {Object<string, ComponentDefinition>} children - Map of selectors to component definitions for explicit children\n   * @param {Array<MountResult>} childInstances - Array to store all mounted component instances\n   * @param {ComponentContext} context - The parent component context for evaluating prop expressions\n   * @returns {Promise<void>}\n   *\n   * @example\n   * // Explicit children mounting:\n   * const children = {\n   *   'UserProfile': UserProfileComponent,\n   *   '#settings-panel': \"settings-panel\"\n   * };\n   */\n  async _mountComponents(container, children, childInstances, context) {\n    for (const [selector, component] of Object.entries(children)) {\n      if (!selector) continue;\n      for (const el of container.querySelectorAll(selector)) {\n        if (!(el instanceof HTMLElement)) continue;\n        /** @type {Record<string, string>} */\n        const props = this._extractProps(el, context);\n        /** @type {MountResult} */\n        const instance = await this.mount(el, component, props);\n        if (instance && !childInstances.includes(instance)) {\n          childInstances.push(instance);\n        }\n      }\n    }\n  }\n}\n"],"names":["TemplateEngine","evaluate","expression","data","trim","fn","_functionCache","get","Function","set","Map","Signal","value","_value","newVal","_notify","watch","_watchers","add","delete","Set","Emitter","on","event","handler","h","_events","off","has","handlers","size","emit","args","SYNC_PROPS","Renderer","patchDOM","container","newHtml","_tempContainer","innerHTML","_diff","oldParent","newParent","firstChild","oldChildren","Array","from","childNodes","newChildren","oldStart","newStart","oldEnd","length","newEnd","keyMap","oldNode","newNode","_isSameNode","_patchNode","_createKeyMap","key","_getNodeKey","matchedNode","nodeName","insertBefore","indexOf","cloneNode","refNode","i","_removeNode","_eleva_instance","nodeType","nodeValue","_updateAttributes","parent","node","hasAttribute","removeChild","oldEl","newEl","attr","attributes","name","getAttribute","setAttribute","newProp","removeAttribute","prop","oldKey","newKey","children","start","end","map","document","createElement","use","plugin","options","install","Error","_plugins","result","undefined","component","definition","template","_components","mount","compName","props","compId","_componentCounter","setup","style","context","emitter","signal","v","processMount","mergedContext","watchers","childInstances","listeners","isMounted","renderScheduled","scheduleRender","queueMicrotask","render","html","onBeforeUpdate","onBeforeMount","renderer","_processEvents","_injectStyles","_mountComponents","onUpdate","onMount","val","Object","values","push","instance","unmount","onUnmount","cleanup","child","setupResult","el","querySelectorAll","attrs","startsWith","slice","handlerName","templateEngine","addEventListener","removeEventListener","styleDef","newStyle","styleEl","querySelector","textContent","appendChild","_extractProps","element","selector","entries","HTMLElement","includes","config"],"mappings":"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"}
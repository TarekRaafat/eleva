{"version":3,"file":"props.umd.min.js","sources":["../../src/plugins/Props.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @class ðŸŽ¯ PropsPlugin\n * @classdesc A plugin that extends Eleva's props data handling to support any type of data structure\n * with automatic type detection, parsing, and reactive prop updates. This plugin enables seamless\n * passing of complex data types from parent to child components without manual parsing.\n * \n * Core Features:\n * - Automatic type detection and parsing (strings, numbers, booleans, objects, arrays, dates, etc.)\n * - Support for complex data structures including nested objects and arrays\n * - Reactive props that automatically update when parent data changes\n * - Comprehensive error handling with custom error callbacks\n * - Simple configuration with minimal setup required\n *\n * @example\n * // Install the plugin\n * const app = new Eleva(\"myApp\");\n * app.use(PropsPlugin, {\n *   enableAutoParsing: true,\n *   enableReactivity: true,\n *   onError: (error, value) => {\n *     console.error('Props parsing error:', error, value);\n *   }\n * });\n *\n * // Use complex props in components\n * app.component(\"UserCard\", {\n *   template: (ctx) => `\n *     <div class=\"user-info-container\"\n *          :user='${JSON.stringify(ctx.user.value)}'\n *          :permissions='${JSON.stringify(ctx.permissions.value)}'\n *          :settings='${JSON.stringify(ctx.settings.value)}'>\n *     </div>\n *   `,\n *   children: {\n *     '.user-info-container': 'UserInfo'\n *   }\n * });\n * \n * app.component(\"UserInfo\", {\n *   setup({ props }) {\n *     return {\n *       user: props.user,        // Automatically parsed object\n *       permissions: props.permissions,  // Automatically parsed array\n *       settings: props.settings  // Automatically parsed object\n *     };\n *   }\n * });\n */\nexport const PropsPlugin = {\n    /**\n     * Unique identifier for the plugin\n     * @type {string}\n     */\n    name: \"props\",\n\n    /**\n     * Plugin version\n     * @type {string}\n     */\n    version: \"1.0.0-rc.1\",\n\n    /**\n     * Plugin description\n     * @type {string}\n     */\n    description: \"Advanced props data handling for complex data structures with automatic type detection and reactivity\",\n\n    /**\n     * Installs the plugin into the Eleva instance\n     *\n     * @param {Object} eleva - The Eleva instance\n     * @param {Object} options - Plugin configuration options\n     * @param {boolean} [options.enableAutoParsing=true] - Enable automatic type detection and parsing\n     * @param {boolean} [options.enableReactivity=true] - Enable reactive prop updates using Eleva's signal system\n     * @param {Function} [options.onError=null] - Error handler function called when parsing fails\n     * \n     * @example\n     * // Basic installation\n     * app.use(PropsPlugin);\n     * \n     * // Installation with custom options\n     * app.use(PropsPlugin, {\n     *   enableAutoParsing: true,\n     *   enableReactivity: false,\n     *   onError: (error, value) => {\n     *     console.error('Props parsing error:', error, value);\n     *   }\n     * });\n     */\n    install(eleva, options = {}) {\n        const {\n            enableAutoParsing = true,\n            enableReactivity = true,\n            onError = null\n        } = options;\n\n        /**\n         * Detects the type of a given value\n         * @private\n         * @param {any} value - The value to detect type for\n         * @returns {string} The detected type ('string', 'number', 'boolean', 'object', 'array', 'date', 'map', 'set', 'function', 'null', 'undefined', 'unknown')\n         * \n         * @example\n         * detectType(\"hello\")     // â†’ \"string\"\n         * detectType(42)          // â†’ \"number\"\n         * detectType(true)        // â†’ \"boolean\"\n         * detectType([1, 2, 3])   // â†’ \"array\"\n         * detectType({})          // â†’ \"object\"\n         * detectType(new Date())  // â†’ \"date\"\n         * detectType(null)        // â†’ \"null\"\n         */\n        const detectType = (value) => {\n            if (value === null) return 'null';\n            if (value === undefined) return 'undefined';\n            if (typeof value === 'boolean') return 'boolean';\n            if (typeof value === 'number') return 'number';\n            if (typeof value === 'string') return 'string';\n            if (typeof value === 'function') return 'function';\n            if (value instanceof Date) return 'date';\n            if (value instanceof Map) return 'map';\n            if (value instanceof Set) return 'set';\n            if (Array.isArray(value)) return 'array';\n            if (typeof value === 'object') return 'object';\n            return 'unknown';\n        };\n\n        /**\n         * Parses a prop value with automatic type detection\n         * @private\n         * @param {any} value - The value to parse\n         * @returns {any} The parsed value with appropriate type\n         * \n         * @description\n         * This function automatically detects and parses different data types from string values:\n         * - Special strings: \"true\" â†’ true, \"false\" â†’ false, \"null\" â†’ null, \"undefined\" â†’ undefined\n         * - JSON objects/arrays: '{\"key\": \"value\"}' â†’ {key: \"value\"}, '[1, 2, 3]' â†’ [1, 2, 3]\n         * - Boolean-like strings: \"1\" â†’ true, \"0\" â†’ false, \"\" â†’ true\n         * - Numeric strings: \"42\" â†’ 42, \"3.14\" â†’ 3.14\n         * - Date strings: \"2023-01-01T00:00:00.000Z\" â†’ Date object\n         * - Other strings: returned as-is\n         * \n         * @example\n         * parsePropValue(\"true\")           // â†’ true\n         * parsePropValue(\"42\")             // â†’ 42\n         * parsePropValue('{\"key\": \"val\"}') // â†’ {key: \"val\"}\n         * parsePropValue('[1, 2, 3]')      // â†’ [1, 2, 3]\n         * parsePropValue(\"hello\")          // â†’ \"hello\"\n         */\n        const parsePropValue = (value) => {\n            try {\n                // Handle non-string values - return as-is\n                if (typeof value !== 'string') {\n                    return value;\n                }\n\n                // Handle special string patterns first\n                if (value === 'true') return true;\n                if (value === 'false') return false;\n                if (value === 'null') return null;\n                if (value === 'undefined') return undefined;\n\n                // Try to parse as JSON (for objects and arrays)\n                // This handles complex data structures like objects and arrays\n                if (value.startsWith('{') || value.startsWith('[')) {\n                    try {\n                        return JSON.parse(value);\n                    } catch (e) {\n                        // Not valid JSON, throw error to trigger error handler\n                        throw new Error(`Invalid JSON: ${value}`);\n                    }\n                }\n\n                // Handle boolean-like strings (including \"1\" and \"0\")\n                // These are common in HTML attributes and should be treated as booleans\n                if (value === '1') return true;\n                if (value === '0') return false;\n                if (value === '') return true; // Empty string is truthy in HTML attributes\n\n                // Handle numeric strings (after boolean check to avoid conflicts)\n                // This ensures \"0\" is treated as boolean false, not number 0\n                if (!isNaN(value) && value !== '' && !isNaN(parseFloat(value))) {\n                    return Number(value);\n                }\n\n                // Handle date strings (ISO format)\n                // Recognizes standard ISO date format and converts to Date object\n                if (value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/)) {\n                    const date = new Date(value);\n                    if (!isNaN(date.getTime())) {\n                        return date;\n                    }\n                }\n\n                // Return as string if no other parsing applies\n                // This is the fallback for regular text strings\n                return value;\n\n            } catch (error) {\n                // Call error handler if provided\n                if (onError) {\n                    onError(error, value);\n                }\n                // Fallback to original value to prevent breaking the application\n                return value;\n            }\n        };\n\n        /**\n         * Enhanced props extraction with automatic type detection\n         * @private\n         * @param {HTMLElement} element - The DOM element to extract props from\n         * @returns {Object} Object containing parsed props with appropriate types\n         * \n         * @description\n         * Extracts props from DOM element attributes that start with \":\" and automatically\n         * parses them to their appropriate types. Removes the attributes from the element\n         * after extraction.\n         * \n         * @example\n         * // HTML: <div :name=\"John\" :age=\"30\" :active=\"true\" :data='{\"key\": \"value\"}'></div>\n         * const props = extractProps(element);\n         * // Result: { name: \"John\", age: 30, active: true, data: {key: \"value\"} }\n         */\n        const extractProps = (element) => {\n            const props = {};\n            const attrs = element.attributes;\n\n            // Iterate through attributes in reverse order to handle removal correctly\n            for (let i = attrs.length - 1; i >= 0; i--) {\n                const attr = attrs[i];\n                // Only process attributes that start with \":\" (prop attributes)\n                if (attr.name.startsWith(\":\")) {\n                    const propName = attr.name.slice(1); // Remove the \":\" prefix\n                    // Parse the value if auto-parsing is enabled, otherwise use as-is\n                    const parsedValue = enableAutoParsing ? parsePropValue(attr.value) : attr.value;\n                    props[propName] = parsedValue;\n                    // Remove the attribute from the DOM element after extraction\n                    element.removeAttribute(attr.name);\n                }\n            }\n\n            return props;\n        };\n\n        /**\n         * Creates reactive props using Eleva's signal system\n         * @private\n         * @param {Object} props - The props object to make reactive\n         * @returns {Object} Object containing reactive props (Eleva signals)\n         * \n         * @description\n         * Converts regular prop values into Eleva signals for reactive updates.\n         * If a value is already a signal, it's passed through unchanged.\n         * \n         * @example\n         * const props = { name: \"John\", age: 30, active: true };\n         * const reactiveProps = createReactiveProps(props);\n         * // Result: { \n         * //   name: Signal(\"John\"), \n         * //   age: Signal(30), \n         * //   active: Signal(true) \n         * // }\n         */\n        const createReactiveProps = (props) => {\n            const reactiveProps = {};\n\n            // Convert each prop value to a reactive signal\n            Object.entries(props).forEach(([key, value]) => {\n                // Check if value is already a signal (has 'value' and 'watch' properties)\n                if (value && typeof value === 'object' && 'value' in value && 'watch' in value) {\n                    // Value is already a signal, use it as-is\n                    reactiveProps[key] = value;\n                } else {\n                    // Create new signal for the prop value to make it reactive\n                    reactiveProps[key] = new eleva.signal(value);\n                }\n            });\n\n            return reactiveProps;\n        };\n\n        // Override Eleva's internal _extractProps method with our enhanced version\n        eleva._extractProps = extractProps;\n\n        // Override Eleva's mount method to apply enhanced prop handling\n        const originalMount = eleva.mount;\n        eleva.mount = async (container, compName, props = {}) => {\n            // Create reactive props if reactivity is enabled\n            const enhancedProps = enableReactivity ? createReactiveProps(props) : props;\n\n            // Call the original mount method with enhanced props\n            return await originalMount.call(eleva, container, compName, enhancedProps);\n        };\n\n        /**\n         * Expose utility methods on the Eleva instance\n         * @namespace eleva.props\n         */\n        eleva.props = {\n            /**\n             * Parse a single value with automatic type detection\n             * @param {any} value - The value to parse\n             * @returns {any} The parsed value with appropriate type\n             * \n             * @example\n             * app.props.parse(\"42\")             // â†’ 42\n             * app.props.parse(\"true\")           // â†’ true\n             * app.props.parse('{\"key\": \"val\"}') // â†’ {key: \"val\"}\n             */\n            parse: (value) => {\n                // Return value as-is if auto parsing is disabled\n                if (!enableAutoParsing) {\n                    return value;\n                }\n                // Use our enhanced parsing function\n                return parsePropValue(value);\n            },\n\n            /**\n             * Detect the type of a value\n             * @param {any} value - The value to detect type for\n             * @returns {string} The detected type\n             * \n             * @example\n             * app.props.detectType(\"hello\")     // â†’ \"string\"\n             * app.props.detectType(42)          // â†’ \"number\"\n             * app.props.detectType([1, 2, 3])   // â†’ \"array\"\n             */\n            detectType\n        };\n\n        // Store original methods for uninstall\n        eleva._originalExtractProps = eleva._extractProps;\n        eleva._originalMount = originalMount;\n    },\n\n    /**\n     * Uninstalls the plugin from the Eleva instance\n     *\n     * @param {Object} eleva - The Eleva instance\n     * \n     * @description\n     * Restores the original Eleva methods and removes all plugin-specific\n     * functionality. This method should be called when the plugin is no\n     * longer needed.\n     * \n     * @example\n     * // Uninstall the plugin\n     * PropsPlugin.uninstall(app);\n     */\n    uninstall(eleva) {\n        // Restore original _extractProps method\n        if (eleva._originalExtractProps) {\n            eleva._extractProps = eleva._originalExtractProps;\n            delete eleva._originalExtractProps;\n        }\n\n        // Restore original mount method\n        if (eleva._originalMount) {\n            eleva.mount = eleva._originalMount;\n            delete eleva._originalMount;\n        }\n\n        // Remove plugin utility methods\n        if (eleva.props) {\n            delete eleva.props;\n        }\n    }\n};"],"names":["name","version","description","install","eleva","options","enableAutoParsing","enableReactivity","onError","parsePropValue","value","startsWith","JSON","parse","e","Error","isNaN","parseFloat","Number","match","date","Date","getTime","error","_extractProps","element","props","attrs","attributes","i","length","attr","propName","slice","parsedValue","removeAttribute","originalMount","mount","async","container","compName","enhancedProps","reactiveProps","Object","entries","forEach","key","signal","createReactiveProps","call","detectType","undefined","Map","Set","Array","isArray","_originalExtractProps","_originalMount","uninstall"],"mappings":";wDAkD2B,CAKvBA,KAAM,QAMNC,QAAS,aAMTC,YAAa,wGAwBbC,OAAAA,CAAQC,EAAOC,EAAU,IACrB,MAAMC,kBACFA,GAAoB,EAAIC,iBACxBA,GAAmB,EAAIC,QACvBA,EAAU,MACVH,EAsDEI,EAAkBC,IACpB,IAEI,GAAqB,iBAAVA,EACP,OAAOA,EAIX,GAAc,SAAVA,EAAkB,OAAO,EAC7B,GAAc,UAAVA,EAAmB,OAAO,EAC9B,GAAc,SAAVA,EAAkB,OAAO,KAC7B,GAAc,cAAVA,EAAuB,OAI3B,GAAIA,EAAMC,WAAW,MAAQD,EAAMC,WAAW,KAC1C,IACI,OAAOC,KAAKC,MAAMH,EACtB,CAAE,MAAOI,GAEL,MAAM,IAAIC,MAAM,iBAAiBL,IACrC,CAKJ,GAAc,MAAVA,EAAe,OAAO,EAC1B,GAAc,MAAVA,EAAe,OAAO,EAC1B,GAAc,KAAVA,EAAc,OAAO,EAIzB,IAAKM,MAAMN,IAAoB,KAAVA,IAAiBM,MAAMC,WAAWP,IACnD,OAAOQ,OAAOR,GAKlB,GAAIA,EAAMS,MAAM,wCAAyC,CACrD,MAAMC,EAAO,IAAIC,KAAKX,GACtB,IAAKM,MAAMI,EAAKE,WACZ,OAAOF,CAEf,CAIA,OAAOV,CAEX,CAAE,MAAOa,GAML,OAJIf,GACAA,EAAQe,EAAOb,GAGZA,CACX,GA8EJN,EAAMoB,cA3DgBC,IAClB,MAAMC,EAAQ,CAAA,EACRC,EAAQF,EAAQG,WAGtB,IAAK,IAAIC,EAAIF,EAAMG,OAAS,EAAGD,GAAK,EAAGA,IAAK,CACxC,MAAME,EAAOJ,EAAME,GAEnB,GAAIE,EAAK/B,KAAKW,WAAW,KAAM,CAC3B,MAAMqB,EAAWD,EAAK/B,KAAKiC,MAAM,GAE3BC,EAAc5B,EAAoBG,EAAesB,EAAKrB,OAASqB,EAAKrB,MAC1EgB,EAAMM,GAAYE,EAElBT,EAAQU,gBAAgBJ,EAAK/B,KACjC,CACJ,CAEA,OAAO0B,GA4CX,MAAMU,EAAgBhC,EAAMiC,MAC5BjC,EAAMiC,MAAQC,MAAOC,EAAWC,EAAUd,EAAQ,CAAA,KAE9C,MAAMe,EAAgBlC,EAzBGmB,KACzB,MAAMgB,EAAgB,CAAA,EActB,OAXAC,OAAOC,QAAQlB,GAAOmB,QAAQ,EAAEC,EAAKpC,MAI7BgC,EAAcI,GAFdpC,GAA0B,iBAAVA,GAAsB,UAAWA,GAAS,UAAWA,EAEhDA,EAGA,IAAIN,EAAM2C,OAAOrC,KAIvCgC,GAUkCM,CAAoBtB,GAASA,EAGtE,aAAaU,EAAca,KAAK7C,EAAOmC,EAAWC,EAAUC,IAOhErC,EAAMsB,MAAQ,CAWVb,MAAQH,GAECJ,EAIEG,EAAeC,GAHXA,EAgBfwC,WAzNgBxC,GACF,OAAVA,EAAuB,YACbyC,IAAVzC,EAA4B,YACX,kBAAVA,EAA4B,UAClB,iBAAVA,EAA2B,SACjB,iBAAVA,EAA2B,SACjB,mBAAVA,EAA6B,WACpCA,aAAiBW,KAAa,OAC9BX,aAAiB0C,IAAY,MAC7B1C,aAAiB2C,IAAY,MAC7BC,MAAMC,QAAQ7C,GAAe,QACZ,iBAAVA,EAA2B,SAC/B,WAiNXN,EAAMoD,sBAAwBpD,EAAMoB,cACpCpB,EAAMqD,eAAiBrB,CAC3B,EAgBAsB,SAAAA,CAAUtD,GAEFA,EAAMoD,wBACNpD,EAAMoB,cAAgBpB,EAAMoD,6BACrBpD,EAAMoD,uBAIbpD,EAAMqD,iBACNrD,EAAMiC,MAAQjC,EAAMqD,sBACbrD,EAAMqD,gBAIbrD,EAAMsB,cACCtB,EAAMsB,KAErB"}